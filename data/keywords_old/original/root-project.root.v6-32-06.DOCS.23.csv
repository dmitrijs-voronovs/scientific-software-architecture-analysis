id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10727,Deployability,patch,patch,10727,", for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11320,Deployability,patch,patch,11320,"ting; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11393,Deployability,patch,patch,11393,"ting; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11626,Deployability,patch,patch,11626,"-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11663,Deployability,patch,patch,11663,"-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11745,Deployability,patch,patch,11745," during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11901,Deployability,patch,patch,11901,"ost true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13208,Deployability,patch,patch,13208," You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13483,Deployability,patch,patch,13483,"lf to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15189,Deployability,patch,patch,15189,"line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the revi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15921,Deployability,patch,patch,15921,"review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phab",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:16150,Deployability,patch,patch,16150,"):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:17020,Deployability,deploy,deploying,17020,"date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for this is, but; note that it is a derivative of an existing open source project, and so not; trivially a good fit for an official LLVM project. .. _LLVM's Phabricator: https://reviews.llvm.org; .. _`https://reviews.llvm.org`: https://reviews.llvm.org; .. _Code Repository Browser: https://reviews.llvm.org/diffusion/; .. _Arcanist Quick Start: https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/; .. _Arcanist User Guide: https://secure.phabricator.com/book/phabricator/article/arcanist/; .. _llvm-reviews GitHub project: https://github.com/r4nt/llvm-reviews/; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:876,Energy Efficiency,power,power,876,".. _phabricator-reviews:. =============================; Code Reviews with Phabricator; =============================. .. warning::. Phabricator is deprecated and will be switched to read-only mode in October; 2023, for new code contributions use :ref:`GitHub Pull Requests <github-reviews>`. .. contents::; :local:. If you prefer to use a web user interface for code reviews, you can now submit; your patches for Clang and LLVM at `LLVM's Phabricator`_ instance. While Phabricator is a useful tool for some, the relevant -commits mailing list; is the system of record for all LLVM code review. The mailing list should be; added as a subscriber on all reviews, and Phabricator users should be prepared; to respond to free-form comments in mail sent to the commits list. Sign up; -------. To get started with Phabricator, navigate to `https://reviews.llvm.org`_ and; click the power icon in the top right. You can register with a GitHub account,; a Google account, or you can create your own profile. Make *sure* that the email address registered with Phabricator is subscribed; to the relevant -commits mailing list. If you are not subscribed to the commit; list, all mail sent by Phabricator on your behalf will be held for moderation. Note that if you use your git user name as Phabricator user name,; Phabricator will automatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7831,Energy Efficiency,adapt,adapted,7831," ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code tha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:349,Integrability,interface,interface,349,".. _phabricator-reviews:. =============================; Code Reviews with Phabricator; =============================. .. warning::. Phabricator is deprecated and will be switched to read-only mode in October; 2023, for new code contributions use :ref:`GitHub Pull Requests <github-reviews>`. .. contents::; :local:. If you prefer to use a web user interface for code reviews, you can now submit; your patches for Clang and LLVM at `LLVM's Phabricator`_ instance. While Phabricator is a useful tool for some, the relevant -commits mailing list; is the system of record for all LLVM code review. The mailing list should be; added as a subscriber on all reviews, and Phabricator users should be prepared; to respond to free-form comments in mail sent to the commits list. Sign up; -------. To get started with Phabricator, navigate to `https://reviews.llvm.org`_ and; click the power icon in the top right. You can register with a GitHub account,; a Google account, or you can create your own profile. Make *sure* that the email address registered with Phabricator is subscribed; to the relevant -commits mailing list. If you are not subscribed to the commit; list, all mail sent by Phabricator on your behalf will be held for moderation. Note that if you use your git user name as Phabricator user name,; Phabricator will automatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:2289,Integrability,message,message,2289,"omatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:2494,Integrability,interface,interface,2494,"bricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sur",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:3163,Integrability,interface,interface,3163,"od part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sure it is formatted properly, as; described in :ref:`How to Submit a Patch <format patches>`. To upload a new patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the text diff or browse to the patch file. Leave this first Repository; field blank. (We'll fill in the Repository later, when sending the review.); Click *Create Diff*.; * Leave the drop down on *Create a new Revision...* and click *Continue*.; * Enter a descriptive title and summary. The title and summary are usually; in the form of a :ref:`commit message <commit messages>`.; * Add reviewer",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:4031,Integrability,message,message,4031,"th your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sure it is formatted properly, as; described in :ref:`How to Submit a Patch <format patches>`. To upload a new patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the text diff or browse to the patch file. Leave this first Repository; field blank. (We'll fill in the Repository later, when sending the review.); Click *Create Diff*.; * Leave the drop down on *Create a new Revision...* and click *Continue*.; * Enter a descriptive title and summary. The title and summary are usually; in the form of a :ref:`commit message <commit messages>`.; * Add reviewers (see below for advice). (If you set the Repository field; correctly, llvm-commits or cfe-commits will be subscribed automatically;; otherwise, you will have to manually subscribe them.); * In the Repository field, enter ""rG LLVM Github Monorepo"".; * Click *Save*. To submit an updated patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the updated diff or browse to the updated patch file. Click *Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-comm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:4047,Integrability,message,messages,4047,"th your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sure it is formatted properly, as; described in :ref:`How to Submit a Patch <format patches>`. To upload a new patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the text diff or browse to the patch file. Leave this first Repository; field blank. (We'll fill in the Repository later, when sending the review.); Click *Create Diff*.; * Leave the drop down on *Create a new Revision...* and click *Continue*.; * Enter a descriptive title and summary. The title and summary are usually; in the form of a :ref:`commit message <commit messages>`.; * Add reviewers (see below for advice). (If you set the Repository field; correctly, llvm-commits or cfe-commits will be subscribed automatically;; otherwise, you will have to manually subscribe them.); * In the Repository field, enter ""rG LLVM Github Monorepo"".; * Click *Save*. To submit an updated patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the updated diff or browse to the updated patch file. Click *Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-comm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5453,Integrability,interface,interface,5453,"owse to the updated patch file. Click *Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5479,Integrability,interface,interface,5479,"Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5618,Integrability,interface,interface,5618,"lick; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uplo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6130,Integrability,interface,interface,6130,"ating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6598,Integrability,interface,interface,6598,"tor review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6682,Integrability,interface,interface,6682,"ast review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6771,Integrability,message,message,6771," where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; y",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7172,Integrability,interface,interface,7172,"s with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7339,Integrability,interface,interface,7339," of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit wi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7546,Integrability,message,messages,7546,"o new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:8268,Integrability,interface,interface,8268,"g review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code that you are modifying.; * Look in CODE_OWNERS.TXT to see who might be responsible for that area.; * If you've discussed the change on a dev list, the people who participated; might be appropriate reviewers. Even if you think the code owner is the busiest person in the world, it's still; okay to put them as a reviewer. Being the code owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phab",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10112,Integrability,interface,interface,10112," owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phabricator; -------------------------------. Phabricator allows you to add inline comments as well as overall comments; to a revision. To add an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10241,Integrability,interface,interface,10241," owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phabricator; -------------------------------. Phabricator allows you to add inline comments as well as overall comments; to a revision. To add an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10433,Integrability,integrat,integration,10433,"t; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repos",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11605,Integrability,depend,dependencies,11605,"-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13642,Integrability,message,message,13642,"onal Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14215,Integrability,message,message,14215,"ting a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14422,Integrability,message,message,14422,"omeone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corres",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14699,Integrability,message,message,14699,"e:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. :",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15374,Integrability,message,message,15374,"ll retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15470,Integrability,message,message,15470,"e; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7831,Modifiability,adapt,adapted,7831," ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code tha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12809,Modifiability,enhance,enhancement,12809,"bricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version histo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13911,Safety,detect,detect,13911,"ntact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11481,Security,hash,hash,11481,"-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13322,Security,access,access,13322,"sts.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13519,Security,access,access,13519,"opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:17529,Security,secur,secure,17529,"date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for this is, but; note that it is a derivative of an existing open source project, and so not; trivially a good fit for an official LLVM project. .. _LLVM's Phabricator: https://reviews.llvm.org; .. _`https://reviews.llvm.org`: https://reviews.llvm.org; .. _Code Repository Browser: https://reviews.llvm.org/diffusion/; .. _Arcanist Quick Start: https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/; .. _Arcanist User Guide: https://secure.phabricator.com/book/phabricator/article/arcanist/; .. _llvm-reviews GitHub project: https://github.com/r4nt/llvm-reviews/; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:17633,Security,secur,secure,17633,"date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for this is, but; note that it is a derivative of an existing open source project, and so not; trivially a good fit for an official LLVM project. .. _LLVM's Phabricator: https://reviews.llvm.org; .. _`https://reviews.llvm.org`: https://reviews.llvm.org; .. _Code Repository Browser: https://reviews.llvm.org/diffusion/; .. _Arcanist Quick Start: https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/; .. _Arcanist User Guide: https://secure.phabricator.com/book/phabricator/article/arcanist/; .. _llvm-reviews GitHub project: https://github.com/r4nt/llvm-reviews/; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:2829,Testability,test,testing,2829,"ng a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sure it is formatted properly, as; described in :ref:`How to Submit a Patch <format patches>`. To upload a new patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the text diff or browse to the patch file. Leave this first Repository; field blank. (We'll fill in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:8716,Testability,log,log,8716,"that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code that you are modifying.; * Look in CODE_OWNERS.TXT to see who might be responsible for that area.; * If you've discussed the change on a dev list, the people who participated; might be appropriate reviewers. Even if you think the code owner is the busiest person in the world, it's still; okay to put them as a reviewer. Being the code owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phabricator; -------------------------------. Phabricator allows you to add inline comments as well as overall comments; to a revision. To add an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many usefu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10348,Testability,test,testing,10348,"mments; to a revision. To add an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10368,Testability,test,testing,10368,"an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be ab",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10410,Testability,test,tests,10410,"t; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repos",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10590,Testability,test,testing,10590,"your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabric",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10837,Testability,test,testing,10837,"ion Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigge",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11341,Testability,test,tested,11341,"ting; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11783,Testability,test,tests,11783," during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12129,Testability,test,tests,12129,"e-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12197,Testability,test,test,12197,"vm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12278,Testability,test,test,12278,"ng one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12426,Testability,test,testing,12426,". Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15989,Testability,test,tests,15989," change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you mig",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:16954,Testability,test,testable,16954,"date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you might like. However, we've put exactly what we're deploying up; on an `llvm-reviews GitHub project`_ where folks can hack on it and post pull; requests. We're looking into what the right long-term hosting for this is, but; note that it is a derivative of an existing open source project, and so not; trivially a good fit for an official LLVM project. .. _LLVM's Phabricator: https://reviews.llvm.org; .. _`https://reviews.llvm.org`: https://reviews.llvm.org; .. _Code Repository Browser: https://reviews.llvm.org/diffusion/; .. _Arcanist Quick Start: https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/; .. _Arcanist User Guide: https://secure.phabricator.com/book/phabricator/article/arcanist/; .. _llvm-reviews GitHub project: https://github.com/r4nt/llvm-reviews/; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:1661,Usability,learn,learn,1661," to respond to free-form comments in mail sent to the commits list. Sign up; -------. To get started with Phabricator, navigate to `https://reviews.llvm.org`_ and; click the power icon in the top right. You can register with a GitHub account,; a Google account, or you can create your own profile. Make *sure* that the email address registered with Phabricator is subscribed; to the relevant -commits mailing list. If you are not subscribed to the commit; list, all mail sent by Phabricator on your behalf will be held for moderation. Note that if you use your git user name as Phabricator user name,; Phabricator will automatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14262,Usability,simpl,simplify,14262,"omeone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corres",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14546,Usability,guid,guide,14546,"If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Phabricator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:280,Availability,avail,available,280,"========================; LLVM Programmer's Manual; ========================. .. contents::; :local:. .. warning::; This is always a work in progress. .. _introduction:. Introduction; ============. This document is meant to highlight some of the important classes and interfaces; available in the LLVM source-base. This manual is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:4691,Availability,failure,failure,4691,"LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``llvm/Support/Casting.h`` (`doxygen; <https://llvm.org/doxygen/Casting_8h_source.html>`__) file (note that you very; rarely have to include this file directly). ``isa<>``:; The ``isa<>`` operator works exactly like the Java ""``instanceof``"" operator.; It returns true or false depending on whether a reference or pointer points to; an instance of the specified class. This can be very useful for constraint; checking of various sorts (example below). ``cast<>``:; The ``cast<>`` operator is a ""checked cast"" operation. It converts a pointer; or reference from a base class to a derived class, causing an assertion; failure if it is not really an instance of the right type. This should be; used in cases where you have some information that makes you believe that; something is of the right type. An example of the ``isa<>`` and ``cast<>``; template is:. .. code-block:: c++. static bool isLoopInvariant(const Value *V, const Loop *L) {; if (isa<Constant>(V) || isa<Argument>(V) || isa<GlobalValue>(V)); return true;. // Otherwise, it must be an instruction...; return !L->contains(cast<Instruction>(V)->getParent());; }. Note that you should **not** use an ``isa<>`` test followed by a ``cast<>``,; for that use the ``dyn_cast<>`` operator. ``dyn_cast<>``:; The ``dyn_cast<>`` operator is a ""checking cast"" operation. It checks to see; if the operand is of the specified type, and if so, returns a pointer to it; (this operator does not work with references). If the operand is not of the; correct type, a null pointer is returned. Thus, this works very much like; the ``dynamic_cast<>`` operato",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8572,Availability,avail,available,8572,"LLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; instance, which can be used directly or converted to an ``std::string`` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` (`doxygen; <https://llvm.org/doxygen/StringRef_8h_source.html>`__) for more; information. You should rarely use the ``StringRef`` class directly, because it contains; pointers to external memory it is not generally safe to sto",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16354,Availability,error,error,16354,"eferencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16437,Availability,error,errors,16437,"eferencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16525,Availability,recover,recoverable,16525,"t; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unrea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16649,Availability,error,errors,16649,""" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16831,Availability,failure,failure,16831,"atv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16961,Availability,error,errors,16961,"rmatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17624,Availability,error,errors,17624,"iants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17644,Availability,error,error,17644,"iants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17704,Availability,failure,failure,17704,"iants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17793,Availability,error,errors,17793,"iding some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17917,Availability,error,error,17917," errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18008,Availability,recover,recovery,18008," errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18065,Availability,error,error,18065,"ssage describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very che",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18230,Availability,error,error,18230,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18340,Availability,error,error,18340,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18470,Availability,error,errors,18470,"ndle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18544,Availability,error,errors,18544,"rors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertTo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18611,Availability,error,error,18611,"rors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertTo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18735,Availability,error,error,18735,"ped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18811,Availability,error,error,18811,"ped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:19973,Availability,error,error,19973,"de-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:20473,Availability,error,error,20473,"ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:20558,Availability,failure,failure,20558,") const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // O",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:20783,Availability,error,error,20783,"file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrEr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21161,Availability,error,error,21161,"t can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21598,Availability,error,error,21598,"the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:22434,Availability,error,error,22434,"rocessFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Suc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:22988,Availability,error,error,22988," avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23136,Availability,failure,failure,23136,"Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23281,Availability,error,error,23281,"uffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, follo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23637,Availability,error,error,23637," can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23999,Availability,error,error,23999," On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error valu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:24305,Availability,error,error,24305,"aking it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not foun",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:24620,Availability,error,error,24620,"to Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` excep",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:24844,Availability,error,error,24844,"even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:24974,Availability,error,error,24974," .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25631,Availability,error,error,25631,"c type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. Strin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25771,Availability,error,error,25771,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25854,Availability,error,errors,25854,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25986,Availability,error,errors,25986,"he error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26036,Availability,error,errors,26036,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26073,Availability,error,error,26073,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26109,Availability,error,error,26109,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26563,Availability,error,error,26563,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26642,Availability,error,errors,26642,"ction should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26657,Availability,recover,recovery,26657,"ction should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26825,Availability,error,error,26825,"merly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability yo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26957,Availability,error,error,26957," unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stop",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27361,Availability,error,error,27361,"can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expect",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27676,Availability,error,error,27676,"at can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of caller",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27788,Availability,error,errors,27788,"rovides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28509,Availability,error,error,28509," done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29210,Availability,error,errorToErrorCode,29210,"rrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; functi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29246,Availability,error,errorCodeToError,29246,"rrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; functi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29392,Availability,error,errorOrToExpected,29392,"tner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify too",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29623,Availability,error,error,29623," in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29683,Availability,recover,recovery,29683," and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the sta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29876,Availability,error,errors,29876," was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29952,Availability,error,errors,29952,"roperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30018,Availability,error,error,30018,"td::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30085,Availability,error,error,30085,"td::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30159,Availability,error,error,30159,"rror Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30452,Availability,recover,recoverable,30452," that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30464,Availability,error,error,30464," that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30599,Availability,error,error,30599,"andlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` val",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30650,Availability,error,error,30650,"andlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` val",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30952,Availability,error,error,30952,"be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31030,Availability,failure,failure,31030,"be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31426,Availability,failure,failure,31426,"lly command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31439,Availability,error,error,31439,"lly command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31793,Availability,error,error,31793,"ll is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is g",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32725,Availability,error,error,32725,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32828,Availability,error,error,32828,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32943,Availability,failure,failure,32943,"in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32957,Availability,error,error,32957,"in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33027,Availability,failure,failure,33027,"cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33611,Availability,error,errors,33611,"ity, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33711,Availability,error,error,33711,"ity, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:34381,Availability,error,errors,34381,"ol and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to construct a Foo receive either a; well-formed Foo or an Error, never an object in an invalid state. Propagating and consuming errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` fun",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:34507,Availability,error,error,34507,"r other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to construct a Foo receive either a; well-formed Foo or an Error, never an object in an invalid state. Propagating and consuming errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:34614,Availability,error,error,34614,"r other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to construct a Foo receive either a; well-formed Foo or an Error, never an object in an invalid state. Propagating and consuming errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:34790,Availability,error,errors,34790,"idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to construct a Foo receive either a; well-formed Foo or an Error, never an object in an invalid state. Propagating and consuming errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:34897,Availability,error,error,34897,"static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to construct a Foo receive either a; well-formed Foo or an Error, never an object in an invalid state. Propagating and consuming errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; comp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:35797,Availability,error,errors,35797," errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and retur",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:35876,Availability,error,errors,35876,"are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36427,Availability,error,error,36427," = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is succ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36496,Availability,error,errors,36496," = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is succ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36604,Availability,error,errors,36604,"); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36639,Availability,error,errors,36639,""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36773,Availability,error,errors,36773,""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:37055,Availability,error,error,37055,"rror walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:37584,Availability,error,error,37584,"pe and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38453,Availability,error,errors,38453," loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_ite",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38608,Availability,error,error,38608," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38635,Availability,error,error,38635," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38753,Availability,error,error,38753," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38861,Availability,redundant,redundant,38861," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38871,Availability,error,error,38871," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45730,Availability,avail,available,45730," -debug-only=foo; 'foo' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=bar; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45832,Availability,avail,available,45832,"ypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're interested to see; how many times it makes a certain transformation. Although you can do this with; hand inspection, or some ad-hoc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49839,Availability,down,down,49839," Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG_COUNTER(DeleteAnInstruction, ""passname-delete-instruction"",; 		""Controls which instructions get delete"");. The ``DEBUG_COUNTER`` macro defines a static variable, whose name; is specified by the first argument. The name of the counter; (which is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:50070,Availability,down,down,50070,"vars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG_COUNTER(DeleteAnInstruction, ""passname-delete-instruction"",; 		""Controls which instructions get delete"");. The ``DEBUG_COUNTER`` macro defines a static variable, whose name; is specified by the first argument. The name of the counter; (which is used on the command line) is specified by the second; argument, and the description used in the help is specified by the; third argument. Whatever code you want that control, use ``DebugCounter::shouldExecute`` to control it. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:52634,Availability,avail,available,52634," -passname. This will skip the above code the first time we hit it, then execute it twice, then skip the rest of the executions. So if executed on the following code:. .. code-block:: llvm. %1 = add i32 %a, %b; %2 = add i32 %a, %b; %3 = add i32 %a, %b; %4 = add i32 %a, %b. It would delete number ``%2`` and ``%3``. A utility is provided in `utils/bisect-skip-count` to binary search; skip and count arguments. It can be used to automatically minimize the; skip and count for a debug-counter variable. .. _ViewGraph:. Viewing graphs while debugging code; -----------------------------------. Several of the important data structures in LLVM are graphs: for example CFGs; made out of LLVM :ref:`BasicBlocks <BasicBlock>`, CFGs made out of LLVM; :ref:`MachineBasicBlocks <MachineBasicBlock>`, and :ref:`Instruction Selection; DAGs <SelectionDAG>`. In many cases, while debugging various parts of the; compiler, it is nice to instantly visualize these graphs. LLVM provides several callbacks that are available in a debug build to do; exactly that. If you call the ``Function::viewCFG()`` method, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixel",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53569,Availability,down,download,53569,"graphs. LLVM provides several callbacks that are available in a debug build to do; exactly that. If you call the ``Function::viewCFG()`` method, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph vi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57570,Availability,avail,available,57570," arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usuall",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:69800,Availability,down,down,69800,"t_sentinel:. Sentinels; ^^^^^^^^^. ``ilist``\ s have another specialty that must be considered. To be a good; citizen in the C++ ecosystem, it needs to support the standard container; operations, such as ``begin`` and ``end`` iterators, etc. Also, the; ``operator--`` must work correctly on the ``end`` iterator in the case of; non-empty ``ilist``\ s. The only sensible solution to this problem is to allocate a so-called *sentinel*; along with the intrusive list, which serves as the ``end`` iterator, providing; the back-link to the last element. However conforming to the C++ convention it; is illegal to ``operator++`` beyond the sentinel and it also must not be; dereferenced. These constraints allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70645,Availability,avail,available,70645,"`. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. ll",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71433,Availability,avail,available,71433,"augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72749,Availability,alive,alive,72749,"a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75448,Availability,down,downside,75448,"current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The ma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:96686,Availability,avail,available,96686,"complexity of add or remove; operations is logarithmic in the size of the original map. .. _dss_othermap:. Other Map-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multimap and; std::unordered_map. We never use containers like unordered_map because; they are generally very expensive (each insertion requires a malloc). std::multimap is useful if you want to map a key to multiple values, but has all; the drawbacks of std::map. A sorted vector or some other approach is almost; always better. .. _ds_bit:. Bit storage containers; ------------------------------------------------------------------------. There are several bit storage containers, and choosing when to use each is; relatively straightforward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98296,Availability,down,downside,98296,"e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. Howev",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:107285,Availability,error,error,107285,"ode-block:: c++. BasicBlock& BB = ...; for (Instruction &I : BB); // The next statement works since operator<<(ostream&,...); // is overloaded for Instruction&; errs() << I << ""\n"";. However, this isn't really the best way to print out the contents of a; ``BasicBlock``! Since the ostream operators are overloaded for virtually; anything you'll care about, you could have just invoked the print routine on the; basic block itself: ``errs() << BB << ""\n"";``. .. _iterate_insiter:. Iterating over the ``Instruction`` in a ``Function``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If you're finding that you commonly iterate over a ``Function``'s; ``BasicBlock``\ s and then that ``BasicBlock``'s ``Instruction``\ s,; ``InstIterator`` should be used instead. You'll need to include; ``llvm/IR/InstIterator.h`` (`doxygen; <https://llvm.org/doxygen/InstIterator_8h.html>`__) and then instantiate; ``InstIterator``\ s explicitly in your code. Here's a small example that shows; how to dump all instructions in a function to the standard error stream:. .. code-block:: c++. #include ""llvm/IR/InstIterator.h"". // F is a pointer to a Function instance; for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I); errs() << *I << ""\n"";. Easy, isn't it? You can also use ``InstIterator``\ s to fill a work list with; its initial contents. For example, if you wanted to initialize a work list to; contain all instructions in a ``Function`` F, all you would need to do is; something like:. .. code-block:: c++. std::set<Instruction*> worklist;; // or better yet, SmallPtrSet<Instruction*, 64> worklist;. for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I); worklist.insert(&*I);. The STL set ``worklist`` would now contain all instructions in the ``Function``; pointed to by F. .. _iterate_convert:. Turning an iterator into a class pointer (and vice-versa); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes, it'll be useful to grab a reference (or pointer) t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129912,Availability,down,down,129912," .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; er",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:142066,Availability,avail,available,142066,"is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Constant_\ s, Argument_\ s. Even Instruction_\ s and :ref:`Function; <c_Function>`\ s are ``Value``\ s. A particular ``Value`` may be used many times in the LLVM representation for a; program. For example, an incoming argument to a function (represented with an; instance of the Argument_ class) is ""used"" by every instruction in the function; that references the argument. To keep track of this relationship, the ``Value``; class keeps a list of all of the ``User``\ s that is using it (the User_ class; is a base class for all nodes in the LLVM graph that can refer to ``Value``\ s).; This use list is how LLVM represents def-use information in the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:142873,Availability,avail,available,142873,"the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; convent",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:631,Deployability,continuous,continuously,631,"========================; LLVM Programmer's Manual; ========================. .. contents::; :local:. .. warning::; This is always a work in progress. .. _introduction:. Introduction; ============. This document is meant to highlight some of the important classes and interfaces; available in the LLVM source-base. This manual is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18330,Deployability,install,installed,18330,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29475,Deployability,patch,patches,29475," types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29488,Deployability,update,update,29488," types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32983,Deployability,release,release,32983,"cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53433,Deployability,install,install,53433,"`Instruction Selection; DAGs <SelectionDAG>`. In many cases, while debugging various parts of the; compiler, it is nice to instantly visualize these graphs. LLVM provides several callbacks that are available in a debug build to do; exactly that. If you call the ``Function::viewCFG()`` method, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/inf",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53583,Deployability,install,install,53583,"graphs. LLVM provides several callbacks that are available in a debug build to do; exactly that. If you call the ``Function::viewCFG()`` method, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph vi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53732,Deployability,install,install,53732,"hod, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53854,Deployability,install,installed,53854,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:61731,Deployability,update,updates,61731,"ment for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an API should use the ``SmallVectorImpl<T>``; class, which is the ""vector header"" (and methods) without the elements; allocated after it. Note that ``SmallVector<T, N>`` inherits from; ``SmallVectorImpl<T>`` so the conversion is implicit and costs nothing. E.g. .. code-block:: c++. // DISCOURAGED: Clients cannot pass e.g. raw arrays.; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92314,Deployability,update,update,92314,"ization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101899,Deployability,release,release-mode,101899,"functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:138822,Deployability,update,update,138822,"e; linker. The ``Module`` class keeps track of a list of :ref:`Function; <c_Function>`\ s, a list of GlobalVariable_\ s, and a SymbolTable_.; Additionally, it contains a few helpful member functions that try to make common; operations easy. .. _m_Module:. Important Public Members of the ``Module`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157698,Deployability,update,update,157698,"r not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surpr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:6401,Energy Efficiency,efficient,efficient,6401,"; if the operand is of the specified type, and if so, returns a pointer to it; (this operator does not work with references). If the operand is not of the; correct type, a null pointer is returned. Thus, this works very much like; the ``dynamic_cast<>`` operator in C++, and should be used in the same; circumstances. Typically, the ``dyn_cast<>`` operator is used in an ``if``; statement or some other flow control statement like this:. .. code-block:: c++. if (auto *AI = dyn_cast<AllocationInst>(Val)) {; // ...; }. This form of the ``if`` statement effectively combines together a call to; ``isa<>`` and a call to ``cast<>`` into one statement, which is very; convenient. Note that the ``dyn_cast<>`` operator, like C++'s ``dynamic_cast<>`` or Java's; ``instanceof`` operator, can be abused. In particular, you should not use big; chained ``if/then/else`` blocks to check for lots of different variants of; classes. If you find yourself wanting to do this, it is much cleaner and more; efficient to use the ``InstVisitor`` class to dispatch over the instruction; type directly. ``isa_and_nonnull<>``:; The ``isa_and_nonnull<>`` operator works just like the ``isa<>`` operator,; except that it allows for a null pointer as an argument (which it then; returns false). This can sometimes be useful, allowing you to combine several; null checks into one. ``cast_or_null<>``:; The ``cast_or_null<>`` operator works just like the ``cast<>`` operator,; except that it allows for a null pointer as an argument (which it then; propagates). This can sometimes be useful, allowing you to combine several; null checks into one. ``dyn_cast_or_null<>``:; The ``dyn_cast_or_null<>`` operator works just like the ``dyn_cast<>``; operator, except that it allows for a null pointer as an argument (which it; then propagates). This can sometimes be useful, allowing you to combine; several null checks into one. These five templates can be used with any classes, whether they have a v-table; or not. If you want to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8347,Energy Efficiency,efficient,efficiently,8347,"hese five templates can be used with any classes, whether they have a v-table; or not. If you want to add support for these templates, see the document; :doc:`How to set up LLVM-style RTTI for your class hierarchy; <HowToSetUpLLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; instance, which can be used directly or converted to an ``std::string`` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:9857,Energy Efficiency,efficient,efficient,9857,"erator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; instance, which can be used directly or converted to an ``std::string`` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` (`doxygen; <https://llvm.org/doxygen/StringRef_8h_source.html>`__) for more; information. You should rarely use the ``StringRef`` class directly, because it contains; pointers to external memory it is not generally safe to store an instance of the; class (unless you know that the external storage will not be freed).; ``StringRef`` is small and pervasive enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``S",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:10268,Energy Efficiency,allocate,allocated,10268,"` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` (`doxygen; <https://llvm.org/doxygen/StringRef_8h_source.html>`__) for more; information. You should rarely use the ``StringRef`` class directly, because it contains; pointers to external memory it is not generally safe to store an instance of the; class (unless you know that the external storage will not be freed).; ``StringRef`` is small and pervasive enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM do",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:10552,Energy Efficiency,efficient,efficiently,10552," safe to store an instance of the; class (unless you know that the external storage will not be freed).; ``StringRef`` is small and pervasive enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is per",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11069,Energy Efficiency,efficient,efficiently,11069,".. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11788,Energy Efficiency,reduce,reduces,11788," As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14194,Energy Efficiency,adapt,adapter,14194,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17205,Energy Efficiency,allocate,allocated,17205,")); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45470,Energy Efficiency,schedul,scheduling,45470,"bug type\n"");; #undef DEBUG_TYPE. Then you can run your pass like this:. .. code-block:: none. $ opt < a.bc > /dev/null -mypass; <no output>; $ opt < a.bc > /dev/null -mypass -debug; 'foo' debug type; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo; 'foo' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=bar; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to ke",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54646,Energy Efficiency,reduce,reduce,54646,"ram; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mappi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55393,Energy Efficiency,efficient,efficient,55393,"attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not suppor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55480,Energy Efficiency,efficient,efficient,55480," current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequenti",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55592,Energy Efficiency,efficient,efficient,55592,"ization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55707,Energy Efficiency,efficient,efficient,55707,"e+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatical",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56034,Energy Efficiency,efficient,efficient,56034,"pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56226,Energy Efficiency,efficient,efficient,56226,"s the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvect",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56356,Energy Efficiency,efficient,efficient,56356,"tainer if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the ele",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56397,Energy Efficiency,efficient,efficient,56397,"tainer if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the ele",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56622,Energy Efficiency,efficient,efficient,56622," two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58350,Energy Efficiency,allocate,allocated,58350,"nts to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58530,Energy Efficiency,allocate,allocated,58530,"-. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it suppo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58654,Energy Efficiency,allocate,allocated,58654,"s_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59526,Energy Efficiency,efficient,efficient,59526,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59644,Energy Efficiency,efficient,efficient,59644,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59695,Energy Efficiency,efficient,efficient,59695,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59787,Energy Efficiency,allocate,allocates,59787,"constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice porta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:60315,Energy Efficiency,allocate,allocate,60315,"s container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice portable and efficient replacement for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:60809,Energy Efficiency,efficient,efficient,60809,"or some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice portable and efficient replacement for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:61919,Energy Efficiency,allocate,allocated,61919,"ment for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an API should use the ``SmallVectorImpl<T>``; class, which is the ""vector header"" (and methods) without the elements; allocated after it. Note that ``SmallVector<T, N>`` inherits from; ``SmallVectorImpl<T>`` so the conversion is implicit and costs nothing. E.g. .. code-block:: c++. // DISCOURAGED: Clients cannot pass e.g. raw arrays.; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63109,Energy Efficiency,allocate,allocates,63109,".; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insert",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64304,Energy Efficiency,allocate,allocate,64304,"is is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65540,Energy Efficiency,efficient,efficient,65540,"ements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not inva",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66217,Energy Efficiency,efficient,efficient,66217,"at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliase",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66995,Energy Efficiency,efficient,efficiently,66995,":list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. Useful for storing a vector of values using only a few number of bits for each; value. Apart from the standard operations of a vector-like container, it can; also perform an 'or' set operation. For example:. .. code-block:: c++. enum State {; None = 0x0,; FirstCondition = 0x1,; SecondCondition = 0x2,; Both = 0x3; };. State get",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:69195,Energy Efficiency,allocate,allocate,69195,"[0]; // returns 'Both'.; }. .. _dss_ilist_traits:. ilist_traits; ^^^^^^^^^^^^. ``ilist_traits<T>`` is ``ilist<T>``'s customization mechanism. ``ilist<T>``; publicly derives from this traits class. .. _dss_ilist_node:. llvm/ADT/ilist_node.h; ^^^^^^^^^^^^^^^^^^^^^. ``ilist_node<T>`` implements the forward and backward links that are expected; by the ``ilist<T>`` (and analogous containers) in the default manner. ``ilist_node<T>``\ s are meant to be embedded in the node type ``T``, usually; ``T`` publicly derives from ``ilist_node<T>``. .. _dss_ilist_sentinel:. Sentinels; ^^^^^^^^^. ``ilist``\ s have another specialty that must be considered. To be a good; citizen in the C++ ecosystem, it needs to support the standard container; operations, such as ``begin`` and ``end`` iterators, etc. Also, the; ``operator--`` must work correctly on the ``end`` iterator in the case of; non-empty ``ilist``\ s. The only sensible solution to this problem is to allocate a so-called *sentinel*; along with the intrusive list, which serves as the ``end`` iterator, providing; the back-link to the last element. However conforming to the C++ convention it; is illegal to ``operator++`` beyond the sentinel and it also must not be; dereferenced. These constraints allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in mem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:69557,Energy Efficiency,allocate,allocate,69557,"nts the forward and backward links that are expected; by the ``ilist<T>`` (and analogous containers) in the default manner. ``ilist_node<T>``\ s are meant to be embedded in the node type ``T``, usually; ``T`` publicly derives from ``ilist_node<T>``. .. _dss_ilist_sentinel:. Sentinels; ^^^^^^^^^. ``ilist``\ s have another specialty that must be considered. To be a good; citizen in the C++ ecosystem, it needs to support the standard container; operations, such as ``begin`` and ``end`` iterators, etc. Also, the; ``operator--`` must work correctly on the ``end`` iterator in the case of; non-empty ``ilist``\ s. The only sensible solution to this problem is to allocate a so-called *sentinel*; along with the intrusive list, which serves as the ``end`` iterator, providing; the back-link to the last element. However conforming to the C++ convention it; is illegal to ``operator++`` beyond the sentinel and it also must not be; dereferenced. These constraints allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:69681,Energy Efficiency,allocate,allocated,69681,"e embedded in the node type ``T``, usually; ``T`` publicly derives from ``ilist_node<T>``. .. _dss_ilist_sentinel:. Sentinels; ^^^^^^^^^. ``ilist``\ s have another specialty that must be considered. To be a good; citizen in the C++ ecosystem, it needs to support the standard container; operations, such as ``begin`` and ``end`` iterators, etc. Also, the; ``operator--`` must work correctly on the ``end`` iterator in the case of; non-empty ``ilist``\ s. The only sensible solution to this problem is to allocate a so-called *sentinel*; along with the intrusive list, which serves as the ``end`` iterator, providing; the back-link to the last element. However conforming to the C++ convention it; is illegal to ``operator++`` beyond the sentinel and it also must not be; dereferenced. These constraints allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70708,Energy Efficiency,adapt,adapter,70708,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71443,Energy Efficiency,efficient,efficiently,71443,"augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72355,Energy Efficiency,efficient,efficient,72355,"0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72511,Energy Efficiency,power,powerful,72511," is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:74830,Energy Efficiency,efficient,efficient,74830,"s, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75771,Energy Efficiency,allocate,allocated,75771,"mp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. ..",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:76545,Energy Efficiency,allocate,allocate,76545,"zed for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several n",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:77711,Energy Efficiency,efficient,efficiently,77711," or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78294,Energy Efficiency,allocate,allocates,78294,", and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78353,Energy Efficiency,efficient,efficient,78353,", and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78582,Energy Efficiency,efficient,efficiently,78582,"y), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallS",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78966,Energy Efficiency,allocate,allocated,78966,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79018,Energy Efficiency,efficient,efficient,79018,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79507,Energy Efficiency,efficient,efficient,79507,"f:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/Spa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81514,Energy Efficiency,efficient,efficient,81514," small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet per",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:83056,Energy Efficiency,allocate,allocated,83056,"OrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:83331,Energy Efficiency,allocate,allocates,83331," have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:84329,Energy Efficiency,adapt,adapter,84329,"ters; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a determi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:84497,Energy Efficiency,efficient,efficient,84497,"ters; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a determi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:85602,Energy Efficiency,adapt,adapter,85602,"r and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a deterministic order. SetVector is also expensive to delete; elements out of (linear time), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implement",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88262,Energy Efficiency,efficient,efficient,88262,"l other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplicates,; but has all the drawbacks of :ref:`std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" poi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88548,Energy Efficiency,efficient,efficiently,88548,"std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88924,Energy Efficiency,allocate,allocated,88924,"e are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ran",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89003,Energy Efficiency,allocate,allocated,89003," pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89377,Energy Efficiency,efficient,efficient,89377,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:91144,Energy Efficiency,allocate,allocates,91144," mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97684,Energy Efficiency,efficient,efficiently,97684,"ions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98154,Energy Efficiency,efficient,efficient,98154,"it at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than B",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:108803,Energy Efficiency,efficient,efficient,108803,"-block:: c++. std::set<Instruction*> worklist;; // or better yet, SmallPtrSet<Instruction*, 64> worklist;. for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I); worklist.insert(&*I);. The STL set ``worklist`` would now contain all instructions in the ``Function``; pointed to by F. .. _iterate_convert:. Turning an iterator into a class pointer (and vice-versa); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes, it'll be useful to grab a reference (or pointer) to a class instance; when all you've got at hand is an iterator. Well, extracting a reference or a; pointer from an iterator is very straight-forward. Assuming that ``i`` is a; ``BasicBlock::iterator`` and ``j`` is a ``BasicBlock::const_iterator``:. .. code-block:: c++. Instruction& inst = *i; // Grab reference to instruction reference; Instruction* pinst = &*i; // Grab pointer to instruction reference; const Instruction& inst = *j;. It's also possible to turn a class pointer into the corresponding iterator, and; this is a constant time operation (very efficient). The following code snippet; illustrates use of the conversion constructors provided by LLVM iterators. By; using these, you can explicitly grab the iterator of something without actually; obtaining it via iteration over some structure:. .. code-block:: c++. void printNextInstruction(Instruction* inst) {; BasicBlock::iterator it(inst);; ++it; // After this line, it refers to the instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:114963,Energy Efficiency,allocate,allocates,114963," will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) parameter of the ``Instruction`` constructor, you associate a; logical name with the result of the instruction's execution at run time. For; example, say that I'm writing a transformation that dynamically allocates space; for an integer on the stack, and that integer is going to be used as some kind; of index by some other code. To accomplish this, I place an ``AllocaInst`` at; the first point in the first ``BasicBlock`` of some ``Function``, and I'm; intending to use it within the same ``Function``. I might do:. .. code-block:: c++. auto *pa = new AllocaInst(Type::Int32Ty, 0, ""indexLoc"");. where ``indexLoc`` is now the logical name of the instruction's execution value,; which is a pointer to an integer on the run time stack. *Inserting instructions*. There are essentially three ways to insert an ``Instruction`` into an existing; sequence of instructions that form a ``BasicBlock``:. * Insertion into the instruction list of the ``BasicBlock``. Given a ``BasicBlock* pb``, an ``Instruction* pi`` within that ``BasicBlock``,; and a newly-created instruction we wish to insert before ``*pi``, we do the; following:. .. code-block:: c++. BasicBlock *pb = ...;; Instruction *pi = ...;; auto *newInst = new Instruction(...);. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:119200,Energy Efficiency,allocate,allocates,119200,"le:. .. code-block:: c++. Instruction *I = .. ;; I->eraseFromParent();. This unlinks the instruction from its containing basic block and deletes it. If; you'd just like to unlink the instruction from its containing basic block but; not delete it, you can use the ``removeFromParent()`` method. .. _schanges_replacing:. Replacing an Instruction with another Value; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Replacing individual instructions; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Including ""`llvm/Transforms/Utils/BasicBlockUtils.h; <https://llvm.org/doxygen/BasicBlockUtils_8h_source.html>`_"" permits use of two; very useful replace functions: ``ReplaceInstWithValue`` and; ``ReplaceInstWithInst``. .. _schanges_deleting_sub:. Deleting Instructions; """""""""""""""""""""""""""""""""""""""""". * ``ReplaceInstWithValue``. This function replaces all uses of a given instruction with a value, and then; removes the original instruction. The following example illustrates the; replacement of the result of a particular ``AllocaInst`` that allocates memory; for a single integer with a null pointer to an integer. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithValue(ii, Constant::getNullValue(PointerType::getUnqual(Type::Int32Ty)));. * ``ReplaceInstWithInst``. This function replaces a particular instruction with another instruction,; inserting the new instruction into the basic block at the location where the; old instruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132703,Energy Efficiency,efficient,efficient,132703,"ll of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:268,Integrability,interface,interfaces,268,"========================; LLVM Programmer's Manual; ========================. .. contents::; :local:. .. warning::; This is always a work in progress. .. _introduction:. Introduction; ============. This document is meant to highlight some of the important classes and interfaces; available in the LLVM source-base. This manual is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:1359,Integrability,rout,routines,1359,"al is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and capabilities of the; library. There are many good pages that discuss the STL, and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:4353,Integrability,depend,depending,4353,"eful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``llvm/Support/Casting.h`` (`doxygen; <https://llvm.org/doxygen/Casting_8h_source.html>`__) file (note that you very; rarely have to include this file directly). ``isa<>``:; The ``isa<>`` operator works exactly like the Java ""``instanceof``"" operator.; It returns true or false depending on whether a reference or pointer points to; an instance of the specified class. This can be very useful for constraint; checking of various sorts (example below). ``cast<>``:; The ``cast<>`` operator is a ""checked cast"" operation. It converts a pointer; or reference from a base class to a derived class, causing an assertion; failure if it is not really an instance of the right type. This should be; used in cases where you have some information that makes you believe that; something is of the right type. An example of the ``isa<>`` and ``cast<>``; template is:. .. code-block:: c++. static bool isLoopInvariant(const Value *V, const Loop *L) {; if (isa<Constant>(V) || isa<Argument>(V) || isa<GlobalValue>(V)); return true;. // Otherwise, it must be an instruction...; return !L->contains(cast<Instruction>(V)->getParent());; }. Note that you should **not** use an ``isa<>`` test followed by a ``cast<>``,; for that use the ``dyn_cast<>`` operator. ``dyn_cast<>``:; The ``dyn_cast<>`` operator is a ""checking cast"" o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11362,Integrability,message,messages,11362,"`). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14194,Integrability,adapter,adapter,14194,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16700,Integrability,contract,contracts,16700,""" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17094,Integrability,message,message,17094,"""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error ha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18364,Integrability,message,message,18364,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18710,Integrability,wrap,wrapper,18710,"ped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26079,Integrability,message,message,26079,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26963,Integrability,message,message,26963," unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stop",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27015,Integrability,interoperab,interoperability,27015," unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stop",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27810,Integrability,interoperab,interoperability,27810,"rovides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28080,Integrability,message,message,28080,"o provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any `",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28428,Integrability,wrap,wraps,28428,"ever need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28959,Integrability,interoperab,interoperability,28959,"cing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30050,Integrability,wrap,wrapped,30050,"td::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30792,Integrability,wrap,wrapped,30792," recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanne",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31208,Integrability,wrap,wrapped,31208,"rors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31451,Integrability,message,message,31451,"lly command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32277,Integrability,wrap,wrapping,32277,"Fail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33150,Integrability,wrap,wrapped,33150," only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParamet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36402,Integrability,rout,routine,36402," = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is succ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36525,Integrability,rout,routine,36525,"); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38325,Integrability,interface,interface,38325," loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_ite",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38344,Integrability,wrap,wrapped,38344," loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_ite",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38493,Integrability,wrap,wrapper,38493," loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_ite",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38546,Integrability,wrap,wrapper,38546," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38922,Integrability,interface,interface,38922,"ve &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_apis:. More information on Error and its related utilities can be found in the; Error.h header file. Passing functions and other callable objects; --------------------------------------------. Sometimes you ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38972,Integrability,wrap,wrapped,38972,"nst ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_apis:. More information on Error and its related utilities can be found in the; Error.h header file. Passing functions and other callable objects; --------------------------------------------. Sometimes you may want a function to be passed a callback object. In order to; support lambda ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57796,Integrability,interface,interface,57796,"ou want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constru",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70708,Integrability,adapter,adapter,70708,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:76297,Integrability,depend,depend,76297,"ld its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::uniqu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79435,Integrability,wrap,wrapper,79435,"f:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/Spa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:82578,Integrability,wrap,wraps,82578,"vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, whi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:84329,Integrability,adapter,adapter,84329,"ters; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a determi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:85602,Integrability,adapter,adapter,85602,"r and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a deterministic order. SetVector is also expensive to delete; elements out of (linear time), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implement",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92159,Integrability,wrap,wrapper,92159,"starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold interv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:94127,Integrability,interface,interface,94127,"lTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar characteristics to :ref:`std::set <dss_set>`: it uses a; single allocation per pair inserted into the map, it offers log(n) lookup with; an extremely large constant factor, imposes a space penalty of 3 pointers per; pair in the map, etc. std::map is most useful when your keys or values are very large, if you need to; iterate over the collection in sorted order, or if you need stable iterators; into the map (i.e. they don't get invalidated if an insertion or deletion of; another element takes place). .. _dss_mapvector:. llvm/ADT/MapVector.h; ^^^^^^^^^^^^^^^^^^^^. ``MapVector<KeyT,ValueT>`` provides a subset of the DenseMap interface. The; main difference is that the iteration order is guaranteed to be the insertion; order, making it an easy (but somewhat expensive) solution for non-deterministic; iteration over maps of pointers. It is implemented by mapping from key to an index in a vector of key,value; pairs. This provides fast lookup and iteration, but has two main drawbacks:; the key is stored twice and removing elements takes linear time. If it is; necessary to remove elements, it's best to remove them in bulk using; ``remove_if()``. .. _dss_inteqclasses:. llvm/ADT/IntEqClasses.h; ^^^^^^^^^^^^^^^^^^^^^^^. IntEqClasses provides a compact representation of equivalence classes of small; integers. Initially, each integer in the range 0..n-1 has its own equivalence; class. Classes can be joined by passing two class representatives to the; join(a, b) method. Two integers are in the same class when findLeader() returns; the same representative. Once all equivalence classes are form",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97489,Integrability,interface,interface,97489,"forward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98603,Integrability,depend,depends,98603," needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM im",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99809,Integrability,wrap,wrap,99809,"cingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two or more ranges; at the same time. For example:. .. code-block:: c++. SmallVector<size_t> Counts = ...;; char Letters[26] = ...;; for (auto [Letter, Count] : zip_equal(Letters, Counts)); errs() << Letter << "": "" << Count << ""\n"";. Note that the elements are provided through a 'reference wrapper' proxy type; (tuple of references), which combined with the structured bindings declaration; makes ``Letter`` and ``Count`` references to range elements. Any modification; to these references will affect the elements of ``Letters`` or ``C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:100596,Integrability,wrap,wrapper,100596,"ctions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two or more ranges; at the same time. For example:. .. code-block:: c++. SmallVector<size_t> Counts = ...;; char Letters[26] = ...;; for (auto [Letter, Count] : zip_equal(Letters, Counts)); errs() << Letter << "": "" << Count << ""\n"";. Note that the elements are provided through a 'reference wrapper' proxy type; (tuple of references), which combined with the structured bindings declaration; makes ``Letter`` and ``Count`` references to range elements. Any modification; to these references will affect the elements of ``Letters`` or ``Counts``. The ``zip``\ * functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:102745,Integrability,wrap,wrapper,102745," functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:106639,Integrability,rout,routine,106639,"uction``\ s it contains:. .. code-block:: c++. Function &Func = ...; for (BasicBlock &BB : Func); // Print out the name of the basic block if it has one, and then the; // number of instructions that it contains; errs() << ""Basic block (name="" << BB.getName() << "") has ""; << BB.size() << "" instructions.\n"";. .. _iterate_basicblock:. Iterating over the ``Instruction`` in a ``BasicBlock``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Just like when dealing with ``BasicBlock``\ s in ``Function``\ s, it's easy to; iterate over the individual instructions that make up ``BasicBlock``\ s. Here's; a code snippet that prints out each instruction in a ``BasicBlock``:. .. code-block:: c++. BasicBlock& BB = ...; for (Instruction &I : BB); // The next statement works since operator<<(ostream&,...); // is overloaded for Instruction&; errs() << I << ""\n"";. However, this isn't really the best way to print out the contents of a; ``BasicBlock``! Since the ostream operators are overloaded for virtually; anything you'll care about, you could have just invoked the print routine on the; basic block itself: ``errs() << BB << ""\n"";``. .. _iterate_insiter:. Iterating over the ``Instruction`` in a ``Function``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If you're finding that you commonly iterate over a ``Function``'s; ``BasicBlock``\ s and then that ``BasicBlock``'s ``Instruction``\ s,; ``InstIterator`` should be used instead. You'll need to include; ``llvm/IR/InstIterator.h`` (`doxygen; <https://llvm.org/doxygen/InstIterator_8h.html>`__) and then instantiate; ``InstIterator``\ s explicitly in your code. Here's a small example that shows; how to dump all instructions in a function to the standard error stream:. .. code-block:: c++. #include ""llvm/IR/InstIterator.h"". // F is a pointer to a Function instance; for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I); errs() << *I << ""\n"";. Easy, isn't it? You can also use ``InstIterator``\ s to fill a work list w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:112876,Integrability,rout,routines,112876,"``User`` is; known as a *use-def* chain. Instances of class ``Instruction`` are common; ``User`` s, so we might want to iterate over all of the values that a particular; instruction uses (that is, the operands of the particular ``Instruction``):. .. code-block:: c++. Instruction *pi = ...;. for (Use &U : pi->operands()) {; Value *v = U.get();; // ...; }. Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; constant flavors as ``Value::const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124029,Integrability,interface,interface,124029,"dent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129481,Integrability,interface,interface,129481," ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129607,Integrability,interface,interface,129607,"rray. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. Whe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129948,Integrability,interface,interface,129948,"-------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130316,Integrability,interface,interface,130316,"ntics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130760,Integrability,interface,interfaces,130760," not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:131924,Integrability,interface,interface,131924," a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:131993,Integrability,interface,interface,131993,"s:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132882,Integrability,interface,interface,132882,"m, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compatible with a; default -Asserts build. Clients that want ABI compatibility; between +Asserts and -Asserts builds should use the CMake build system; to set `LLVM_ENABLE_ABI_BREAKING_CHECKS` i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:136526,Integrability,interface,interface,136526," ``bool isFloatingPointTy()``: Return true if this is one of the five; floating point types. * ``bool isSized()``: Return true if the type has known size. Things; that don't have a size are abstract types, labels and void. .. _derivedtypes:. Important Derived Types; ^^^^^^^^^^^^^^^^^^^^^^^. ``IntegerType``; Subclass of DerivedType that represents integer types of any bit width. Any; bit width between ``IntegerType::MIN_INT_BITS`` (1) and; ``IntegerType::MAX_INT_BITS`` (~8 million) can be represented. * ``static const IntegerType* get(unsigned NumBits)``: get an integer; type of a specific bit width. * ``unsigned getBitWidth() const``: Get the bit width of an integer type. ``SequentialType``; This is subclassed by ArrayType and VectorType. * ``const Type * getElementType() const``: Returns the type of each; of the elements in the sequential type. * ``uint64_t getNumElements() const``: Returns the number of elements; in the sequential type. ``ArrayType``; This is a subclass of SequentialType and defines the interface for array; types. ``PointerType``; Subclass of Type for pointer types. ``VectorType``; Subclass of SequentialType for vector types. A vector type is similar to an; ArrayType but is distinguished because it is a first class type whereas; ArrayType is not. Vector types are used for vector operations and are usually; small vectors of an integer or floating point type. ``StructType``; Subclass of DerivedTypes for struct types. .. _FunctionType:. ``FunctionType``; Subclass of DerivedTypes for function types. * ``bool isVarArg() const``: Returns true if it's a vararg function. * ``const Type * getReturnType() const``: Returns the return type of the; function. * ``const Type * getParamType (unsigned i)``: Returns the type of the ith; parameter. * ``const unsigned getNumParams() const``: Returns the number of formal; parameters. .. _Module:. The ``Module`` class; --------------------. ``#include ""llvm/IR/Module.h""``. header source: `Module.h <https://llvm.org/dox",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143767,Integrability,interface,interface,143767,"s it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145628,Integrability,interface,interface,145628,"ck:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145668,Integrability,interface,interface,145668,"ck:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:146129,Integrability,interface,interface,146129,"itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into. To; represent a specific type of instruction, one of many subclasses of; ``Instruction`` are used. Because the ``Instruction`` class subclasses the User_ class, its operands can; be accessed in the same way as for other ``User``\ s (with the; ``getOperand()``/``getNumOperands()`` and ``op_begin()``/``op_end()`` methods).; A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:163408,Integrability,interface,interface,163408,"are Value_\ s, because they are; referenced by instructions like branches and can go in the switch tables.; ``BasicBlock``\ s have type ``label``. .. _m_BasicBlock:. Important Public Members of the ``BasicBlock`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``BasicBlock(const std::string &Name = """", Function *Parent = 0)``. The ``BasicBlock`` constructor is used to create new basic blocks for; insertion into a function. The constructor optionally takes a name for the; new block, and a :ref:`Function <c_Function>` to insert it into. If the; ``Parent`` parameter is specified, the new ``BasicBlock`` is automatically; inserted at the end of the specified :ref:`Function <c_Function>`, if not; specified, the BasicBlock must be manually inserted into the :ref:`Function; <c_Function>`. * | ``BasicBlock::iterator`` - Typedef for instruction list iterator; | ``BasicBlock::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``front()``, ``back()``,; ``size()``, ``empty()``, ``splice()``; STL-style functions for accessing the instruction list. These methods and typedefs are forwarding functions that have the same; semantics as the standard library methods of the same names. These methods; expose the underlying instruction list of a basic block in a way that is easy; to manipulate. * ``Function *getParent()``. Returns a pointer to :ref:`Function <c_Function>` the block is embedded into,; or a null pointer if it is homeless. * ``Instruction *getTerminator()``. Returns a pointer to the terminator instruction that appears at the end of the; ``BasicBlock``. If there is no terminator instruction, or if the last; instruction in the block is not a terminator, then a null pointer is returned. .. _Argument:. The ``Argument`` class; ----------------------. This subclass of Value defines the interface for incoming formal arguments to a; function. A Function maintains a list of its formal arguments. An argument has; a pointer to the parent Function.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:1243,Modifiability,extend,extended,1243,"al is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and capabilities of the; library. There are many good pages that discuss the STL, and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:3112,Modifiability,maintainab,maintainable,3112,", and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the standard C++ library. #. `cplusplus.com; <https://cplusplus.com/reference/>`_ - another excellent; reference like the one above. #. `C++ In a Nutshell <http://www.tempest-sw.com/cpp/>`_ - This is an O'Reilly; book in the making. It has a decent Standard Library Reference that rivals; Dinkumware's, and is unfortunately no longer free since the book has been; published. #. `C++ Frequently Asked Questions <https://www.parashift.com/c++-faq-lite/>`_. #. `Bjarne Stroustrup's C++ Page; <https://www.stroustrup.com/C++.html>`_. #. `Bruce Eckel's Thinking in C++, 2nd ed. Volume 2.; (even better, get the book); <https://archive.org/details/TICPP2ndEdVolTwo>`_. You are also encouraged to take a look at the :doc:`LLVM Coding Standards; <CodingStandards>` guide which focuses on how to write maintainable code more; than where to put your curly braces. .. _resources:. Other useful references; -----------------------. #. `Using static and shared libraries across platforms; <http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html>`_. .. _apis:. Important and useful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11839,Modifiability,portab,portable,11839," As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12377,Modifiability,variab,variable,12377,"atting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``style`` is an optional string consisting of a type specific that controls the; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14048,Modifiability,extend,extend,14048,"n),; or ``+`` (right align). The default is right aligned. ``style`` is an optional string consisting of a type specific that controls the; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14194,Modifiability,adapt,adapter,14194,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14204,Modifiability,inherit,inheriting,14204,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:19262,Modifiability,inherit,inherits,19262,"nd; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; util",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21949,Modifiability,variab,variable,21949,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:22023,Modifiability,variab,variable,22023,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31096,Modifiability,variab,variable,31096,"// error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """"""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:47441,Modifiability,variab,variable,47441,"tic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're interested to see; how many times it makes a certain transformation. Although you can do this with; hand inspection, or some ad-hoc method, this is a real pain and not very useful; for big programs. Using the ``Statistic`` class makes it very easy to keep; track of this information, and the calculated information is presented in a; uniform manner with the rest of the passes being executed. There are many examples of ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first argument. The pass name is taken from the ``DEBUG_TYPE`` macro, and; the description is taken from the second argument. The variable defined; (""NumXForms"" in this case) acts like an unsigned integer. Whenever you make a transformation, bump the counter:. .. code-block:: c++. ++NumXForms; // I did stuff!. That's all you have to do. To get '``opt``' to print out the statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 321",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:47613,Modifiability,variab,variable,47613,"particular program run; faster. Often you may run your pass on some big program, and you're interested to see; how many times it makes a certain transformation. Although you can do this with; hand inspection, or some ad-hoc method, this is a real pain and not very useful; for big programs. Using the ``Statistic`` class makes it very easy to keep; track of this information, and the calculated information is presented in a; uniform manner with the rest of the passes being executed. There are many examples of ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first argument. The pass name is taken from the ``DEBUG_TYPE`` macro, and; the description is taken from the second argument. The variable defined; (""NumXForms"" in this case) acts like an unsigned integer. Whenever you make a transformation, bump the counter:. .. code-block:: c++. ++NumXForms; // I did stuff!. That's all you have to do. To get '``opt``' to print out the statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtype",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48791,Modifiability,variab,variables,48791,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49633,Modifiability,maintainab,maintainable,49633," load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:50768,Modifiability,variab,variable,50768,"---------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG_COUNTER(DeleteAnInstruction, ""passname-delete-instruction"",; 		""Controls which instructions get delete"");. The ``DEBUG_COUNTER`` macro defines a static variable, whose name; is specified by the first argument. The name of the counter; (which is used on the command line) is specified by the second; argument, and the description used in the help is specified by the; third argument. Whatever code you want that control, use ``DebugCounter::shouldExecute`` to control it. .. code-block:: c++. if (DebugCounter::shouldExecute(DeleteAnInstruction)); I->eraseFromParent();. That's all you have to do. Now, using opt, you can control when this code triggers using; the '``--debug-counter``' option. There are two counters provided, ``skip`` and ``count``.; ``skip`` is the number of times to skip execution of the codepath. ``count`` is the number; of times, once we are done skipping, to execute the codepath. .. code-block:: none. $ opt --debug-counter=passname-delete-instruction-skip=1,passname-delete-instruction-count=2 -passname. This will skip the above code the first time we hit it, then execute it twice, then skip the rest of the executions. So if exe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:52128,Modifiability,variab,variable,52128,"ode-block:: c++. if (DebugCounter::shouldExecute(DeleteAnInstruction)); I->eraseFromParent();. That's all you have to do. Now, using opt, you can control when this code triggers using; the '``--debug-counter``' option. There are two counters provided, ``skip`` and ``count``.; ``skip`` is the number of times to skip execution of the codepath. ``count`` is the number; of times, once we are done skipping, to execute the codepath. .. code-block:: none. $ opt --debug-counter=passname-delete-instruction-skip=1,passname-delete-instruction-count=2 -passname. This will skip the above code the first time we hit it, then execute it twice, then skip the rest of the executions. So if executed on the following code:. .. code-block:: llvm. %1 = add i32 %a, %b; %2 = add i32 %a, %b; %3 = add i32 %a, %b; %4 = add i32 %a, %b. It would delete number ``%2`` and ``%3``. A utility is provided in `utils/bisect-skip-count` to binary search; skip and count arguments. It can be used to automatically minimize the; skip and count for a debug-counter variable. .. _ViewGraph:. Viewing graphs while debugging code; -----------------------------------. Several of the important data structures in LLVM are graphs: for example CFGs; made out of LLVM :ref:`BasicBlocks <BasicBlock>`, CFGs made out of LLVM; :ref:`MachineBasicBlocks <MachineBasicBlock>`, and :ref:`Instruction Selection; DAGs <SelectionDAG>`. In many cases, while debugging various parts of the; compiler, it is nice to instantly visualize these graphs. LLVM provides several callbacks that are available in a debug build to do; exactly that. If you call the ``Function::viewCFG()`` method, for example, the; current LLVM tool will pop up a window containing the CFG for the function where; each basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly(",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53797,Modifiability,config,configuring,53797,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53935,Modifiability,extend,extended,53935,"ion::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL dat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58455,Modifiability,variab,variable,58455,"-. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it suppo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:60796,Modifiability,portab,portable,60796,"or some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice portable and efficient replacement for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:61971,Modifiability,inherit,inherits,61971," std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an API should use the ``SmallVectorImpl<T>``; class, which is the ""vector header"" (and methods) without the elements; allocated after it. Note that ``SmallVector<T, N>`` inherits from; ``SmallVectorImpl<T>`` so the conversion is implicit and costs nothing. E.g. .. code-block:: c++. // DISCOURAGED: Clients cannot pass e.g. raw arrays.; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:67013,Modifiability,polymorphi,polymorphic,67013,":list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. Useful for storing a vector of values using only a few number of bits for each; value. Apart from the standard operations of a vector-like container, it can; also perform an 'or' set operation. For example:. .. code-block:: c++. enum State {; None = 0x0,; FirstCondition = 0x1,; SecondCondition = 0x2,; Both = 0x3; };. State get",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70708,Modifiability,adapt,adapter,70708,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81827,Modifiability,polymorphi,polymorphic,81827,"ul for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81947,Modifiability,inherit,inherit,81947,". .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:82916,Modifiability,polymorphi,polymorphic,82916,"quired to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:84329,Modifiability,adapt,adapter,84329,"ters; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a determi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:85602,Modifiability,adapt,adapter,85602,"r and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a deterministic order. SetVector is also expensive to delete; elements out of (linear time), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implement",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88570,Modifiability,variab,variable,88570,"std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89037,Modifiability,variab,variable,89037," pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92430,Modifiability,config,configure,92430,"ch can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:120538,Modifiability,variab,variable,120538,"inserting the new instruction into the basic block at the location where the; old instruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWith`` to; change more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:120651,Modifiability,variab,variable,120651,"nstruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWith`` to; change more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compili",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124749,Modifiability,config,configured,124749,"ype`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definiti",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:127872,Modifiability,variab,variable,127872,"p of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129469,Modifiability,polymorphi,polymorphic,129469," ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129571,Modifiability,inherit,inheritance,129571,"rray. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. Whe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130165,Modifiability,polymorphi,polymorphism,130165,"ype hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Clas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130609,Modifiability,polymorphi,polymorphism,130609," from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130719,Modifiability,polymorphi,polymorphism,130719," from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:131794,Modifiability,polymorphi,polymorphism,131794," a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132122,Modifiability,polymorphi,polymorphism,132122,"s:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132444,Modifiability,inherit,inheritance,132444,"he C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENAB",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132577,Modifiability,extend,extend,132577,"ll of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:138977,Modifiability,variab,variable,138977,"y, it contains a few helpful member functions that try to make common; operations easy. .. _m_Module:. Important Public Members of the ``Module`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an exte",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139124,Modifiability,variab,variable,139124,"t Public Members of the ``Module`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; mat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139203,Modifiability,variab,variable,139203,"^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139283,Modifiability,variab,variable,139283," You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:142742,Modifiability,variab,variable,142742,"at is using it (the User_ class; is a base class for all nodes in the LLVM graph that can refer to ``Value``\ s).; This use list is how LLVM represents def-use information in the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:149417,Modifiability,variab,variable,149417,"perands). .. _m_Instruction:. Important Public Members of the ``Instruction`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``BasicBlock *getParent()``. Returns the BasicBlock_ that this; ``Instruction`` is embedded into. * ``bool mayWriteToMemory()``. Returns true if the instruction writes to memory, i.e. it is a ``call``,; ``free``, ``invoke``, or ``store``. * ``unsigned getOpcode()``. Returns the opcode for the ``Instruction``. * ``Instruction *clone() const``. Returns another instance of the specified instruction, identical in all ways; to the original except that the instruction has no parent (i.e. it's not; embedded into a BasicBlock_), and it has no name. .. _Constant:. The ``Constant`` class and subclasses; -------------------------------------. Constant represents a base class for different types of constants. It is; subclassed by ConstantInt, ConstantArray, etc. for representing the various; types of Constants. GlobalValue_ is also a subclass, which represents the; address of a global variable or function. .. _s_Constant:. Important Subclasses of Constant; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ConstantInt : This subclass of Constant represents an integer constant of; any width. * ``const APInt& getValue() const``: Returns the underlying; value of this constant, an APInt value. * ``int64_t getSExtValue() const``: Converts the underlying APInt value to an; int64_t via sign extension. If the value (not the bit width) of the APInt; is too large to fit in an int64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``uint64_t getZExtValue() const``: Converts the underlying APInt value; to a uint64_t via zero extension. IF the value (not the bit width) of the; APInt is too large to fit in a uint64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``static ConstantInt* get(const APInt& Val)``: Returns the ConstantInt; object that represents the value provided by ``Val``. The type is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:151153,Modifiability,variab,variable,151153,"oo large to fit in a uint64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``static ConstantInt* get(const APInt& Val)``: Returns the ConstantInt; object that represents the value provided by ``Val``. The type is implied; as the IntegerType that corresponds to the bit width of ``Val``. * ``static ConstantInt* get(const Type *Ty, uint64_t Val)``: Returns the; ConstantInt object that represents the value provided by ``Val`` for integer; type ``Ty``. * ConstantFP : This class represents a floating point constant. * ``double getValue() const``: Returns the underlying value of this constant. * ConstantArray : This represents a constant array. * ``const std::vector<Use> &getValues() const``: Returns a vector of; component constants that makeup this array. * ConstantStruct : This represents a constant struct. * ``const std::vector<Use> &getValues() const``: Returns a vector of; component constants that makeup this array. * GlobalValue : This represents either a global variable or a function. In; either case, the value is a constant fixed address (after linking). .. _GlobalValue:. The ``GlobalValue`` class; -------------------------. ``#include ""llvm/IR/GlobalValue.h""``. header source: `GlobalValue.h; <https://llvm.org/doxygen/GlobalValue_8h_source.html>`_. doxygen info: `GlobalValue Class; <https://llvm.org/doxygen/classllvm_1_1GlobalValue.html>`_. Superclasses: Constant_, User_, Value_. Global values ( GlobalVariable_\ s or :ref:`Function <c_Function>`\ s) are the; only LLVM values that are visible in the bodies of all :ref:`Function; <c_Function>`\ s. Because they are visible at global scope, they are also; subject to linking with other globals defined in different translation units.; To control the linking process, ``GlobalValue``\ s know their linkage rules.; Specifically, ``GlobalValue``\ s know whether they have internal or external; linkage, as defined by the ``LinkageTypes`` enumeration. If a ``GlobalValue`` has internal linkage",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:158668,Modifiability,variab,variables,158668," the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of link",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159008,Modifiability,variab,variables,159008,"d returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to ar",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159526,Modifiability,variab,variable,159526,"iable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159601,Modifiability,variab,variable,159601," Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159766,Modifiability,variab,variable,159766,"rprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBloc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159913,Modifiability,variab,variable,159913," their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxyge",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160045,Modifiability,variab,variable,160045," initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160068,Modifiability,variab,variable,160068," initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160279,Modifiability,variab,variable,160279,"ble`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last el",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160325,Modifiability,variab,variable,160325,"ble`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last el",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160407,Modifiability,variab,variable,160407,"inkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last element of this list of instructions is always; a terminator instruction. In addition to tracking the list of instructions that make up the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8203,Performance,perform,perform,8203,"nter as an argument (which it; then propagates). This can sometimes be useful, allowing you to combine; several null checks into one. These five templates can be used with any classes, whether they have a v-table; or not. If you want to add support for these templates, see the document; :doc:`How to set up LLVM-style RTTI for your class hierarchy; <HowToSetUpLLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; ins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:19162,Performance,perform,performance,19162," where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Er",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:43437,Performance,perform,performance,43437,"hem to always be noisy. A standard compromise is to comment; them out, allowing you to enable them if you need them in the future. The ``llvm/Support/Debug.h`` (`doxygen; <https://llvm.org/doxygen/Debug_8h_source.html>`__) file provides a macro named; ``LLVM_DEBUG()`` that is a much nicer solution to this problem. Basically, you can; put arbitrary code into the argument of the ``LLVM_DEBUG`` macro, and it is only; executed if '``opt``' (or any other tool) is run with the '``-debug``' command; line argument:. .. code-block:: c++. LLVM_DEBUG(dbgs() << ""I am here!\n"");. Then you can run your pass like this:. .. code-block:: none. $ opt < a.bc > /dev/null -mypass; <no output>; $ opt < a.bc > /dev/null -mypass -debug; I am here!. Using the ``LLVM_DEBUG()`` macro instead of a home-brewed solution allows you to not; have to create ""yet another"" command line option for the debug output for your; pass. Note that ``LLVM_DEBUG()`` macros are disabled for non-asserts builds, so they; do not cause a performance impact at all (for the same reason, they should also; not contain side-effects!). One additional nice thing about the ``LLVM_DEBUG()`` macro is that you can enable or; disable it directly in gdb. Just use ""``set DebugFlag=0``"" or ""``set; DebugFlag=1``"" from the gdb if the program is running. If the program hasn't; been started yet, you can always just run it with ``-debug``. .. _DEBUG_TYPE:. Fine grained debug info with ``DEBUG_TYPE`` and the ``-debug-only`` option; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes you may find yourself in a situation where enabling ``-debug`` just; turns on **too much** information (such as when working on the code generator).; If you want to enable debug information with more fine-grained control, you; should define the ``DEBUG_TYPE`` macro and use the ``-debug-only`` option as; follows:. .. code-block:: c++. #define DEBUG_TYPE ""foo""; LLVM_DEBUG(dbgs() << ""'foo' debug type\n"");; #undef DEBUG_TYPE; #def",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45690,Performance,perform,performance,45690," -debug-only=foo; 'foo' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=bar; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45743,Performance,optimiz,optimized,45743," -debug-only=foo; 'foo' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=bar; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:45772,Performance,optimiz,optimized,45772," -debug-only=foo; 'foo' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=bar; 'bar' debug type; $ opt < a.bc > /dev/null -mypass -debug-only=foo,bar; 'foo' debug type; 'bar' debug type. Of course, in practice, you should only set ``DEBUG_TYPE`` at the top of a file,; to specify the debug type for the entire module. Be careful that you only do; this after including Debug.h and not around any #include of headers. Also, you; should use names more meaningful than ""foo"" and ""bar"", because there is no; system in place to ensure that names do not conflict. If two different modules; use the same string, they will all be turned on when the name is specified.; This allows, for example, all debug information for instruction scheduling to be; enabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:46560,Performance,optimiz,optimizations,46560,"nabled with ``-debug-only=InstrSched``, even if the source lives in multiple; files. The name must not include a comma (,) as that is used to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're interested to see; how many times it makes a certain transformation. Although you can do this with; hand inspection, or some ad-hoc method, this is a real pain and not very useful; for big programs. Using the ``Statistic`` class makes it very easy to keep; track of this information, and the calculated information is presented in a; uniform manner with the rest of the passes being executed. There are many examples of ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:46605,Performance,optimiz,optimizations,46605,"to separate the; arguments of the ``-debug-only`` option. For performance reasons, -debug-only is not available in optimized build; (``--enable-optimized``) of LLVM. The ``DEBUG_WITH_TYPE`` macro is also available for situations where you would; like to set ``DEBUG_TYPE``, but only for one specific ``DEBUG`` statement. It; takes an additional first parameter, which is the type to use. For example, the; preceding example could be written as:. .. code-block:: c++. DEBUG_WITH_TYPE(""foo"", dbgs() << ""'foo' debug type\n"");; DEBUG_WITH_TYPE(""bar"", dbgs() << ""'bar' debug type\n"");. .. _Statistic:. The ``Statistic`` class & ``-stats`` option; -------------------------------------------. The ``llvm/ADT/Statistic.h`` (`doxygen; <https://llvm.org/doxygen/Statistic_8h_source.html>`__) file provides a class; named ``Statistic`` that is used as a unified way to keep track of what the LLVM; compiler is doing and how effective various optimizations are. It is useful to; see what optimizations are contributing to making a particular program run; faster. Often you may run your pass on some big program, and you're interested to see; how many times it makes a certain transformation. Although you can do this with; hand inspection, or some ad-hoc method, this is a real pain and not very useful; for big programs. Using the ``Statistic`` class makes it very easy to keep; track of this information, and the calculated information is presented in a; uniform manner with the rest of the passes being executed. There are many examples of ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first argument. The pass name is taken from the ``DEBUG_TYPE`` macro, and; the description is taken from the second argument. The variable defined",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48615,Performance,load,load,48615,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48962,Performance,load,loads,48962,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49226,Performance,load,load,49226,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49501,Performance,optimiz,optimizations,49501," trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56650,Performance,perform,perform,56650," two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56891,Performance,tune,tune,56891," put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56935,Performance,cache,cache,56935," put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57044,Performance,cache,cache,57044,"teration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in me",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59090,Performance,optimiz,optimized,59090,"^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59943,Performance,perform,performed,59943,"t those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice portable and efficient replacement for; ``alloca``. SmallVector has grown a few other minor advantages over std",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65931,Performance,perform,performs,65931,"vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can effici",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:67919,Performance,perform,perform,67919,"ementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. Useful for storing a vector of values using only a few number of bits for each; value. Apart from the standard operations of a vector-like container, it can; also perform an 'or' set operation. For example:. .. code-block:: c++. enum State {; None = 0x0,; FirstCondition = 0x1,; SecondCondition = 0x2,; Both = 0x3; };. State get() {; PackedVector<State, 2> Vec1;; Vec1.push_back(FirstCondition);. PackedVector<State, 2> Vec2;; Vec2.push_back(SecondCondition);. Vec1 |= Vec2;; return Vec1[0]; // returns 'Both'.; }. .. _dss_ilist_traits:. ilist_traits; ^^^^^^^^^^^^. ``ilist_traits<T>`` is ``ilist<T>``'s customization mechanism. ``ilist<T>``; publicly derives from this traits class. .. _dss_ilist_node:. llvm/ADT/ilist_node.h; ^^^^^^^^^^^^^^^^^^^^^. ``ilist_node<T>`` implements the forward and backward links that are expected; by the ``ilist<T>`` (and analogous containers) in the default manner. ``ilist_node<T>``\ s are meant to be embedded in the node type ``T``, usually; ``T`` publicly derives from ``ilist_node<T>``. .. _dss_ilist_sentinel:. Sentinels; ^^^^^^^^^. ``ilist``\ s have another specialty that must be considered. To be ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70739,Performance,queue,queue,70739,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75505,Performance,optimiz,optimized,75505," variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:76269,Performance,perform,performance,76269,"ld its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::uniqu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:76379,Performance,optimiz,optimized,76379,"mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:77579,Performance,cache,cache,77579," or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78911,Performance,perform,performed,78911,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:82530,Performance,perform,perform,82530,"vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, whi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:83559,Performance,perform,performance,83559," for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89370,Performance,cache,cache,89370,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:91985,Performance,perform,performs,91985,"enseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97150,Performance,perform,performed,97150,"). std::multimap is useful if you want to map a key to multiple values, but has all; the drawbacks of std::map. A sorted vector or some other approach is almost; always better. .. _ds_bit:. Bit storage containers; ------------------------------------------------------------------------. There are several bit storage containers, and choosing when to use each is; relatively straightforward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97524,Performance,optimiz,optimized,97524,"forward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98920,Performance,optimiz,optimized,98920,"nable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99350,Performance,perform,performance,99350,"the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101921,Performance,perform,performance,101921,"functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103620,Performance,perform,perform,103620,"alue() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) returns an iterator to the start of the sequence, the ``XXXend()``; function returns an iterator pointing to one past the last valid element of the; sequence, and there ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113355,Performance,perform,performing,113355,"const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122380,Performance,multi-thread,multi-threading,122380," Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122708,Performance,concurren,concurrently,122708," single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very fe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122978,Performance,concurren,concurrently,122978,"ou are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; de",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124284,Performance,concurren,concurrently,124284,"an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ====",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124351,Performance,concurren,concurrently,124351,"an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ====",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:135224,Performance,perform,performed,135224,"ed. The core LLVM classes are defined in header files in; the ``include/llvm/IR`` directory, and implemented in the ``lib/IR``; directory. It's worth noting that, for historical reasons, this library is; called ``libLLVMCore.so``, not ``libLLVMIR.so`` as you might expect. .. _Type:. The Type class and Derived Types; --------------------------------. ``Type`` is a superclass of all type classes. Every ``Value`` has a ``Type``.; ``Type`` cannot be instantiated directly but only through its subclasses.; Certain primitive types (``VoidType``, ``LabelType``, ``FloatType`` and; ``DoubleType``) have hidden subclasses. They are hidden because they offer no; useful functionality beyond what the ``Type`` class offers except to distinguish; themselves from other subclasses of ``Type``. All other types are subclasses of ``DerivedType``. Types can be named, but this; is not a requirement. There exists exactly one instance of a given shape at any; one time. This allows type equality to be performed with address equality of; the Type Instance. That is, given two ``Type*`` values, the types are identical; if the pointers are identical. .. _m_Type:. Important Public Methods; ^^^^^^^^^^^^^^^^^^^^^^^^. * ``bool isIntegerTy() const``: Returns true for any integer type. * ``bool isFloatingPointTy()``: Return true if this is one of the five; floating point types. * ``bool isSized()``: Return true if the type has known size. Things; that don't have a size are abstract types, labels and void. .. _derivedtypes:. Important Derived Types; ^^^^^^^^^^^^^^^^^^^^^^^. ``IntegerType``; Subclass of DerivedType that represents integer types of any bit width. Any; bit width between ``IntegerType::MIN_INT_BITS`` (1) and; ``IntegerType::MAX_INT_BITS`` (~8 million) can be represented. * ``static const IntegerType* get(unsigned NumBits)``: get an integer; type of a specific bit width. * ``unsigned getBitWidth() const``: Get the bit width of an integer type. ``SequentialType``; This is subclassed by ArrayTy",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:138841,Performance,perform,perform,138841,"e; linker. The ``Module`` class keeps track of a list of :ref:`Function; <c_Function>`\ s, a list of GlobalVariable_\ s, and a SymbolTable_.; Additionally, it contains a few helpful member functions that try to make common; operations easy. .. _m_Module:. Important Public Members of the ``Module`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157717,Performance,perform,perform,157717,"r not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surpr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:9524,Safety,safe,safe,9524,"cter array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; instance, which can be used directly or converted to an ``std::string`` using; the ``str`` member function. See ``llvm/ADT/StringRef.h`` (`doxygen; <https://llvm.org/doxygen/StringRef_8h_source.html>`__) for more; information. You should rarely use the ``StringRef`` class directly, because it contains; pointers to external memory it is not generally safe to store an instance of the; class (unless you know that the external storage will not be freed).; ``StringRef`` is small and pervasive enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:10612,Safety,avoid,avoids,10612,"e enough in LLVM that it should always be; passed by value. The ``Twine`` class; ^^^^^^^^^^^^^^^^^^^. The ``Twine`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Twine.html>`__); class is an efficient way for APIs to accept concatenated strings. For example,; a common LLVM paradigm is to name one instruction based on the name of another; instruction with a suffix, for example:. .. code-block:: c++. New = CmpInst::Create(..., SO->getName() + "".cmp"");. The ``Twine`` class is effectively a lightweight `rope; <http://en.wikipedia.org/wiki/Rope_(computer_science)>`_ which points to; temporary (stack allocated) objects. Twines can be implicitly constructed as; the result of the plus operator applied to strings (i.e., a C strings, an; ``std::string``, or a ``StringRef``). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike `",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12109,Safety,safe,safer,12109,":. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14688,Safety,detect,detected,14688,"tever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16525,Safety,recover,recoverable,16525,"t; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unrea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16801,Safety,abort,abort,16801,"atv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17810,Safety,detect,detected,17810,"iding some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18008,Safety,recover,recovery,18008," errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18377,Safety,abort,abort,18377,"t areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21990,Safety,avoid,avoids,21990,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23308,Safety,abort,abort,23308,"uffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, follo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23745,Safety,abort,abort,23745,"ode-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23855,Safety,abort,abort,23855,"ngRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The; ``handleErrors`` function will visit each handler in the sequence and check its; argument type against the dynamic type of the error, running the first handler; that matches. This is the same decision process that is used decide which catch; clause to run for a C++ exception. Since the list of handlers passed to ``handleErrors`` may not cover every error; type that can occur, the ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25736,Safety,avoid,avoided,25736,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:25890,Safety,risk,risking,25890,"o ``handleErrors`` may not cover every error; type that can occur, the ``handleErrors`` function also returns an Error value; that must be checked or propagated. If the error value that is passed to; ``handleErrors`` does not match any of the handlers it will be returned from; handleErrors. Idiomatic use of ``handleErrors`` thus looks like:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26485,Safety,safe,safe,26485,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26657,Safety,recover,recovery,26657,"ction should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:29683,Safety,recover,recovery,29683," and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the sta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30452,Safety,recover,recoverable,30452," that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32055,Safety,safe,safe,32055," a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32195,Safety,safe,safe,32195," to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33409,Safety,safe,safe,33409,"argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38861,Safety,redund,redundant,38861," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:41746,Safety,safe,safe,41746,"_8_08_4.html>`__) class; template represents a reference to a callable object, templated over the type; of the callable. This is a good choice for passing a callback to a function,; if you don't need to hold onto the callback after the function returns. In this; way, ``function_ref`` is to ``std::function`` as ``StringRef`` is to; ``std::string``. ``function_ref<Ret(Param1, Param2, ...)>`` can be implicitly constructed from; any callable object that can be called with arguments of type ``Param1``,; ``Param2``, ..., and returns a value that can be converted to type ``Ret``.; For example:. .. code-block:: c++. void visitBasicBlocks(Function *F, function_ref<bool (BasicBlock*)> Callback) {; for (BasicBlock &BB : *F); if (Callback(&BB)); return;; }. can be called using:. .. code-block:: c++. visitBasicBlocks(F, [&](BasicBlock *BB) {; if (process(BB)); return isEmpty(BB);; return false;; });. Note that a ``function_ref`` object contains pointers to external memory, so it; is not generally safe to store an instance of the class (unless you know that; the external storage will not be freed). If you need this ability, consider; using ``std::function``. ``function_ref`` is small enough that it should always; be passed by value. .. _DEBUG:. The ``LLVM_DEBUG()`` macro and ``-debug`` option; ------------------------------------------------. Often when working on your pass you will put a bunch of debugging printouts and; other code into your pass. After you get it working, you want to remove it, but; you may need it again in the future (to work out new bugs that you run across). Naturally, because of this, you don't want to delete the debug printouts, but; you don't want them to always be noisy. A standard compromise is to comment; them out, allowing you to enable them if you need them in the future. The ``llvm/Support/Debug.h`` (`doxygen; <https://llvm.org/doxygen/Debug_8h_source.html>`__) file provides a macro named; ``LLVM_DEBUG()`` that is a much nicer solution to this proble",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57287,Safety,avoid,avoids,57287,"icates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59103,Safety,avoid,avoid,59103,"^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:61023,Safety,safe,safe,61023," around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omitting the ``N``). This will choose a default number of; inlined elements reasonable for allocation on the stack (for example, trying; to keep ``sizeof(SmallVector<T>)`` around 64 bytes). SmallVector also provides a nice portable and efficient replacement for; ``alloca``. SmallVector has grown a few other minor advantages over std::vector, causing; ``SmallVector<Type, 0>`` to be preferred over ``std::vector<Type>``. #. std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an API should use the ``SmallVectorImpl<T>``; class, which is the ""vector header"" (and methods) without the elements; allocated after it. Note that ``SmallVector<T, N>`` inherits from; ``SmallVectorImpl<T>`` so the conversion is implicit and costs nothing. E.g.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65009,Safety,avoid,avoid,65009,"herwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus h",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71948,Safety,safe,safely,71948,"in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:73965,Safety,safe,safe,73965,"used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallStr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75175,Safety,avoid,avoids,75175,"together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:75366,Safety,safe,safe,75366,"cts on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a hi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:86523,Safety,avoid,avoided,86523,"ime), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implementation based on an AVL; tree. Adding or removing elements is done through a Factory object and results; in the creation of a new ImmutableSet object. If an ImmutableSet already exists; with the given contents, then the existing one is returned; equality is compared; with a FoldingSetNodeID. The time and space complexity of add or remove; operations is logarithmic in the size of the original set. There is no method for returning an element of the set, you can only check for; membership. .. _dss_otherset:. Other Set-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplica",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92889,Safety,avoid,avoid,92889,"ch alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar characteristics to :ref:`std::set <dss_set>`: it uses a; single allocation per pair inserted into the map, it offers log(n) lookup with; an extremely large constant factor, imposes a space penalty of 3 pointers per; pair in the map, etc. std::map is most useful when your keys or values are very large, if you need to; iterate over the collection in sorted",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99338,Safety,predict,predictable,99338,"the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103443,Safety,avoid,avoid,103443,"`index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122458,Safety,safe,safe,122458," Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:123524,Safety,safe,safe,123524,"------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outs",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124140,Safety,safe,safe,124140,"lation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JI",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128049,Safety,redund,redundancy,128049,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132151,Safety,avoid,avoid,132151,"s:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:144423,Safety,detect,detect,144423," if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:20515,Security,access,accessed,20515,"erride {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto Fi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55288,Security,access,access,55288,"lors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:56954,Security,access,access,56954," put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <ds_sequential>` container provides the most efficient way; to add elements and keeps track of the order they are added to the collection.; They permit duplicates and support efficient iteration, but do not support; efficient look-up based on a key. * a :ref:`string <ds_string>` container is a specialized sequential container or; reference structure that is used for character or byte arrays. * a :ref:`bit <ds_bit>` container provides an efficient way to store and; perform set operations on sets of numeric id's, while automatically; eliminating duplicates. Bit containers require a maximum of 1 bit for each; identifier you want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59712,Security,access,access,59712,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63087,Security,access,access,63087,".; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insert",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63196,Security,access,accessed,63196,".; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insert",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63449,Security,access,accessed,63449,"guousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``ma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63732,Security,access,accessing,63732,");. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vec",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64265,Security,access,accessing,64265,"is is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64490,Security,access,access,64490," can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64528,Security,access,accessed,64528," can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65481,Security,access,access,65481,"ements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not inva",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65550,Security,access,access,65550,"ements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not inva",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66147,Security,access,access,66147,"write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, an",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66227,Security,access,access,66227,"at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliase",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66745,Security,access,access,66745,"t factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70522,Security,access,accessed,70522,"ts allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70820,Security,access,access,70820,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78209,Security,access,accesses,78209,"pproach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78363,Security,access,access,78363,", and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78952,Security,hash,hash,78952,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79028,Security,access,access,79028,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79747,Security,access,access,79747,"^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80066,Security,hash,hash,80066," insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet ad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81882,Security,hash,hash,81882,". .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88602,Security,hash,hash,88602,"std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking u",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88865,Security,hash,hash,88865,"e are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ran",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89404,Security,hash,hash,89404,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89583,Security,hash,hash,89583,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89609,Security,hash,hash,89609,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89650,Security,hash,hash,89650,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:90709,Security,hash,hash,90709,"le, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key typ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:91830,Security,hash,hashing,91830,"pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map onl",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:102794,Security,access,accessed,102794," functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:121232,Security,access,access,121232,"nge more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initializat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124414,Security,access,accesses,124414,"`\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner working",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124554,Security,access,accessing,124554,"neously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125162,Security,access,access,125162,". LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125474,Security,access,accessed,125474,"xt`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; publ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125928,Security,access,accessed,125928,"i?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:126433,Security,expose,exposes,126433,"nusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:138594,Security,access,access,138594,"e.html>`_. The ``Module`` class represents the top level structure present in LLVM; programs. An LLVM module is effectively either a translation unit of the; original program or a combination of several translation units merged by the; linker. The ``Module`` class keeps track of a list of :ref:`Function; <c_Function>`\ s, a list of GlobalVariable_\ s, and a SymbolTable_.; Additionally, it contains a few helpful member functions that try to make common; operations easy. .. _m_Module:. Important Public Members of the ``Module`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139452,Security,access,access,139452,"` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, Constant *FunctionPtr}``, rather; than simply the ``Function*`` with potentially an unexpected; signature. * ``std::string getTypeName(const Type *Ty)``. If there is at least one entry in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:141921,Security,access,accessible,141921,"g/doxygen/Value_8h_source.html>`_. doxygen info: `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_. The ``Value`` class is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Constant_\ s, Argument_\ s. Even Instruction_\ s and :ref:`Function; <c_Function>`\ s are ``Value``\ s. A particular ``Value`` may be used many times in the LLVM representation for a; program. For example, an incoming argument to a function (represented with an; instance of the Argument_ class) is ""used"" by every instruction in the function; that references the argument. To keep track of this relationship, the ``Value``; class keeps a list of all of the ``User``\ s that is using it (the User_ class; is a base class for all nodes in the LLVM graph that can refer to ``Value``\ s).; This use list is how LLVM represents def-use information in the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143780,Security,access,access,143780,"s it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:144142,Security,access,access,144142,"he ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145010,Security,expose,exposes,145010,"const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the en",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145565,Security,expose,exposes,145565,"ck:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145620,Security,access,access,145620,"ck:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145769,Security,expose,expose,145769,"source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145838,Security,access,access,145838,"source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:146981,Security,access,accessed,146981,"terator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into. To; represent a specific type of instruction, one of many subclasses of; ``Instruction`` are used. Because the ``Instruction`` class subclasses the User_ class, its operands can; be accessed in the same way as for other ``User``\ s (with the; ``getOperand()``/``getNumOperands()`` and ``op_begin()``/``op_end()`` methods).; An important file for the ``Instruction`` class is the ``llvm/Instruction.def``; file. This file contains some meta-data about the various different types of; instructions in LLVM. It describes the enum values that are used as opcodes; (for example ``Instruction::Add`` and ``Instruction::ICmp``), as well as the; concrete sub-classes of ``Instruction`` that implement the instruction (for; example BinaryOperator_ and CmpInst_). Unfortunately, the use of macros in this; file confuses doxygen, so these enum values don't show up correctly in the; `doxygen output <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. .. _s_Instruction:. Important Subclasses of the ``Instruction`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. _BinaryOperator:. * ``BinaryOperator``. This subclasses represents all two operand instructions whose operands must be; the same type, ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:153218,Security,access,accessing,153218,"inking. If it has external linkage, it is visible to external; code, and does participate in linking. In addition to linkage information,; ``GlobalValue``\ s keep track of which Module_ they are currently part of. Because ``GlobalValue``\ s are memory objects, they are always referred to by; their **address**. As such, the Type_ of a global is always a pointer to its; contents. It is important to remember this when using the ``GetElementPtrInst``; instruction because this pointer must be dereferenced first. For example, if; you have a ``GlobalVariable`` (a subclass of ``GlobalValue)`` that is an array; of 24 ints, type ``[24 x i32]``, then the ``GlobalVariable`` is a pointer to; that array. Although the address of the first element of this array and the; value of the ``GlobalVariable`` are the same, they have different types. The; ``GlobalVariable``'s type is ``[24 x i32]``. The first element's type is; ``i32.`` Because of this, accessing a global value requires you to dereference; the pointer with ``GetElementPtrInst`` first, then its elements can be accessed.; This is explained in the `LLVM Language Reference Manual; <LangRef.html#globalvars>`_. .. _m_GlobalValue:. Important Public Members of the ``GlobalValue`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``bool hasInternalLinkage() const``; | ``bool hasExternalLinkage() const``; | ``void setInternalLinkage(bool HasInternalLinkage)``. These methods manipulate the linkage characteristics of the ``GlobalValue``. * ``Module *getParent()``. This returns the Module_ that the; GlobalValue is currently embedded into. .. _c_Function:. The ``Function`` class; ----------------------. ``#include ""llvm/IR/Function.h""``. header source: `Function.h <https://llvm.org/doxygen/Function_8h_source.html>`_. doxygen info: `Function Class; <https://llvm.org/doxygen/classllvm_1_1Function.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. The ``Function`` class represents a single procedure in LLVM. It i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:153343,Security,access,accessed,153343,"inking. If it has external linkage, it is visible to external; code, and does participate in linking. In addition to linkage information,; ``GlobalValue``\ s keep track of which Module_ they are currently part of. Because ``GlobalValue``\ s are memory objects, they are always referred to by; their **address**. As such, the Type_ of a global is always a pointer to its; contents. It is important to remember this when using the ``GetElementPtrInst``; instruction because this pointer must be dereferenced first. For example, if; you have a ``GlobalVariable`` (a subclass of ``GlobalValue)`` that is an array; of 24 ints, type ``[24 x i32]``, then the ``GlobalVariable`` is a pointer to; that array. Although the address of the first element of this array and the; value of the ``GlobalVariable`` are the same, they have different types. The; ``GlobalVariable``'s type is ``[24 x i32]``. The first element's type is; ``i32.`` Because of this, accessing a global value requires you to dereference; the pointer with ``GetElementPtrInst`` first, then its elements can be accessed.; This is explained in the `LLVM Language Reference Manual; <LangRef.html#globalvars>`_. .. _m_GlobalValue:. Important Public Members of the ``GlobalValue`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``bool hasInternalLinkage() const``; | ``bool hasExternalLinkage() const``; | ``void setInternalLinkage(bool HasInternalLinkage)``. These methods manipulate the linkage characteristics of the ``GlobalValue``. * ``Module *getParent()``. This returns the Module_ that the; GlobalValue is currently embedded into. .. _c_Function:. The ``Function`` class; ----------------------. ``#include ""llvm/IR/Function.h""``. header source: `Function.h <https://llvm.org/doxygen/Function_8h_source.html>`_. doxygen info: `Function Class; <https://llvm.org/doxygen/classllvm_1_1Function.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. The ``Function`` class represents a single procedure in LLVM. It i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157185,Security,access,access,157185,"ram. The constructor must specify the type of the function to create and; what type of linkage the function should have. The FunctionType_ argument; specifies the formal arguments and return value for the function. The same; FunctionType_ value can be used to create multiple functions. The ``Parent``; argument specifies the Module in which the function is defined. If this; argument is provided, the function will automatically be inserted into that; module's list of functions. * ``bool isDeclaration()``. Return whether or not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157507,Security,access,access,157507," the Module in which the function is defined. If this; argument is provided, the function will automatically be inserted into that; module's list of functions. * ``bool isDeclaration()``. Return whether or not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxyge",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:162625,Security,access,accessing,162625,"are Value_\ s, because they are; referenced by instructions like branches and can go in the switch tables.; ``BasicBlock``\ s have type ``label``. .. _m_BasicBlock:. Important Public Members of the ``BasicBlock`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``BasicBlock(const std::string &Name = """", Function *Parent = 0)``. The ``BasicBlock`` constructor is used to create new basic blocks for; insertion into a function. The constructor optionally takes a name for the; new block, and a :ref:`Function <c_Function>` to insert it into. If the; ``Parent`` parameter is specified, the new ``BasicBlock`` is automatically; inserted at the end of the specified :ref:`Function <c_Function>`, if not; specified, the BasicBlock must be manually inserted into the :ref:`Function; <c_Function>`. * | ``BasicBlock::iterator`` - Typedef for instruction list iterator; | ``BasicBlock::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``front()``, ``back()``,; ``size()``, ``empty()``, ``splice()``; STL-style functions for accessing the instruction list. These methods and typedefs are forwarding functions that have the same; semantics as the standard library methods of the same names. These methods; expose the underlying instruction list of a basic block in a way that is easy; to manipulate. * ``Function *getParent()``. Returns a pointer to :ref:`Function <c_Function>` the block is embedded into,; or a null pointer if it is homeless. * ``Instruction *getTerminator()``. Returns a pointer to the terminator instruction that appears at the end of the; ``BasicBlock``. If there is no terminator instruction, or if the last; instruction in the block is not a terminator, then a null pointer is returned. .. _Argument:. The ``Argument`` class; ----------------------. This subclass of Value defines the interface for incoming formal arguments to a; function. A Function maintains a list of its formal arguments. An argument has; a pointer to the parent Function.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:162805,Security,expose,expose,162805,"are Value_\ s, because they are; referenced by instructions like branches and can go in the switch tables.; ``BasicBlock``\ s have type ``label``. .. _m_BasicBlock:. Important Public Members of the ``BasicBlock`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``BasicBlock(const std::string &Name = """", Function *Parent = 0)``. The ``BasicBlock`` constructor is used to create new basic blocks for; insertion into a function. The constructor optionally takes a name for the; new block, and a :ref:`Function <c_Function>` to insert it into. If the; ``Parent`` parameter is specified, the new ``BasicBlock`` is automatically; inserted at the end of the specified :ref:`Function <c_Function>`, if not; specified, the BasicBlock must be manually inserted into the :ref:`Function; <c_Function>`. * | ``BasicBlock::iterator`` - Typedef for instruction list iterator; | ``BasicBlock::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``front()``, ``back()``,; ``size()``, ``empty()``, ``splice()``; STL-style functions for accessing the instruction list. These methods and typedefs are forwarding functions that have the same; semantics as the standard library methods of the same names. These methods; expose the underlying instruction list of a basic block in a way that is easy; to manipulate. * ``Function *getParent()``. Returns a pointer to :ref:`Function <c_Function>` the block is embedded into,; or a null pointer if it is homeless. * ``Instruction *getTerminator()``. Returns a pointer to the terminator instruction that appears at the end of the; ``BasicBlock``. If there is no terminator instruction, or if the last; instruction in the block is not a terminator, then a null pointer is returned. .. _Argument:. The ``Argument`` class; ----------------------. This subclass of Value defines the interface for incoming formal arguments to a; function. A Function maintains a list of its formal arguments. An argument has; a pointer to the parent Function.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:4680,Testability,assert,assertion,4680,"LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``llvm/Support/Casting.h`` (`doxygen; <https://llvm.org/doxygen/Casting_8h_source.html>`__) file (note that you very; rarely have to include this file directly). ``isa<>``:; The ``isa<>`` operator works exactly like the Java ""``instanceof``"" operator.; It returns true or false depending on whether a reference or pointer points to; an instance of the specified class. This can be very useful for constraint; checking of various sorts (example below). ``cast<>``:; The ``cast<>`` operator is a ""checked cast"" operation. It converts a pointer; or reference from a base class to a derived class, causing an assertion; failure if it is not really an instance of the right type. This should be; used in cases where you have some information that makes you believe that; something is of the right type. An example of the ``isa<>`` and ``cast<>``; template is:. .. code-block:: c++. static bool isLoopInvariant(const Value *V, const Loop *L) {; if (isa<Constant>(V) || isa<Argument>(V) || isa<GlobalValue>(V)); return true;. // Otherwise, it must be an instruction...; return !L->contains(cast<Instruction>(V)->getParent());; }. Note that you should **not** use an ``isa<>`` test followed by a ``cast<>``,; for that use the ``dyn_cast<>`` operator. ``dyn_cast<>``:; The ``dyn_cast<>`` operator is a ""checking cast"" operation. It checks to see; if the operand is of the specified type, and if so, returns a pointer to it; (this operator does not work with references). If the operand is not of the; correct type, a null pointer is returned. Thus, this works very much like; the ``dynamic_cast<>`` operato",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:5244,Testability,test,test,5244,"a<>`` operator works exactly like the Java ""``instanceof``"" operator.; It returns true or false depending on whether a reference or pointer points to; an instance of the specified class. This can be very useful for constraint; checking of various sorts (example below). ``cast<>``:; The ``cast<>`` operator is a ""checked cast"" operation. It converts a pointer; or reference from a base class to a derived class, causing an assertion; failure if it is not really an instance of the right type. This should be; used in cases where you have some information that makes you believe that; something is of the right type. An example of the ``isa<>`` and ``cast<>``; template is:. .. code-block:: c++. static bool isLoopInvariant(const Value *V, const Loop *L) {; if (isa<Constant>(V) || isa<Argument>(V) || isa<GlobalValue>(V)); return true;. // Otherwise, it must be an instruction...; return !L->contains(cast<Instruction>(V)->getParent());; }. Note that you should **not** use an ``isa<>`` test followed by a ``cast<>``,; for that use the ``dyn_cast<>`` operator. ``dyn_cast<>``:; The ``dyn_cast<>`` operator is a ""checking cast"" operation. It checks to see; if the operand is of the specified type, and if so, returns a pointer to it; (this operator does not work with references). If the operand is not of the; correct type, a null pointer is returned. Thus, this works very much like; the ``dynamic_cast<>`` operator in C++, and should be used in the same; circumstances. Typically, the ``dyn_cast<>`` operator is used in an ``if``; statement or some other flow control statement like this:. .. code-block:: c++. if (auto *AI = dyn_cast<AllocationInst>(Val)) {; // ...; }. This form of the ``if`` statement effectively combines together a call to; ``isa<>`` and a call to ``cast<>`` into one statement, which is very; convenient. Note that the ``dyn_cast<>`` operator, like C++'s ``dynamic_cast<>`` or Java's; ``instanceof`` operator, can be abused. In particular, you should not use big; chained ``i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11478,Testability,log,logging,11478,"`). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:15189,Testability,test,test,15189," we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:15458,Testability,test,test,15458,"rmat(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; und",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:15484,Testability,test,test,15484,"rmat(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; und",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16972,Testability,assert,assertions,16972,"rmatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17150,Testability,assert,assert,17150,")); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:19487,Testability,log,log,19487,"This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be access",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:23494,Testability,test,tested,23494,", use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).moveInto(LazyName)); // On error, return the Error value.; return Err;; // On success, LazyName has been initialized.; ...; }; };. All ``Error`` instances, whether success or failure, must be either checked or; moved from (via ``std::move`` or a return) before they are destructed.; Accidentally discarding an unchecked error will cause a program abort at the; point where the unchecked value's destructor is run, making it easy to identify; and fix violations of this rule. Success values are considered checked once they have been tested (by invoking; the boolean conversion operator):. .. code-block:: c++. if (auto Err = mayFail(...)); return Err; // Failure value - move error to caller. // Safe to continue: Err was checked. In contrast, the following code will always cause an abort, even if ``mayFail``; returns a success value:. .. code-block:: c++. mayFail();; // Program will always abort here, even if mayFail() returns Success, since; // the value is not checked. Failure values are considered checked once a handler for the error type has; been activated:. .. code-block:: c++. handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; });. The ``handleErrors`` function takes an error as its first argument, followed by; a variadic list of ""handlers"", each of which must be a callable type (a; function, lambda, or class with a call operator) with one argument. The;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30988,Testability,log,logging,30988,"be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31447,Testability,log,log,31447,"lly command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32289,Testability,assert,assertion,32289,"Fail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32857,Testability,assert,asserts,32857,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32933,Testability,assert,assertion,32933,"in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33328,Testability,test,test,33328,"argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33359,Testability,mock,mocked-up,33359,"argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33639,Testability,test,test,33639,"ity, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33758,Testability,test,test,33758,"ity, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParameter EAO(&Err);; if (auto Err2 = R1.acquire()) {; Err = std::move(Err2);; return;; }; Err = R2.acquire();; }; };. Here, the named constructor passes an ``Error`` by reference into the actual; constructor, which the constructor can then use to return errors. The; ``ErrorAsOutParameter`` utility sets the ``Error`` value's checked flag on entry; to the constructor so that the error can be assigned to, then resets it on exit; to force the client (the named constructor) to check the error. By using this idiom, clients attempting to con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:43397,Testability,assert,asserts,43397,"hem to always be noisy. A standard compromise is to comment; them out, allowing you to enable them if you need them in the future. The ``llvm/Support/Debug.h`` (`doxygen; <https://llvm.org/doxygen/Debug_8h_source.html>`__) file provides a macro named; ``LLVM_DEBUG()`` that is a much nicer solution to this problem. Basically, you can; put arbitrary code into the argument of the ``LLVM_DEBUG`` macro, and it is only; executed if '``opt``' (or any other tool) is run with the '``-debug``' command; line argument:. .. code-block:: c++. LLVM_DEBUG(dbgs() << ""I am here!\n"");. Then you can run your pass like this:. .. code-block:: none. $ opt < a.bc > /dev/null -mypass; <no output>; $ opt < a.bc > /dev/null -mypass -debug; I am here!. Using the ``LLVM_DEBUG()`` macro instead of a home-brewed solution allows you to not; have to create ""yet another"" command line option for the debug output for your; pass. Note that ``LLVM_DEBUG()`` macros are disabled for non-asserts builds, so they; do not cause a performance impact at all (for the same reason, they should also; not contain side-effects!). One additional nice thing about the ``LLVM_DEBUG()`` macro is that you can enable or; disable it directly in gdb. Just use ""``set DebugFlag=0``"" or ""``set; DebugFlag=1``"" from the gdb if the program is running. If the program hasn't; been started yet, you can always just run it with ``-debug``. .. _DEBUG_TYPE:. Fine grained debug info with ``DEBUG_TYPE`` and the ``-debug-only`` option; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes you may find yourself in a situation where enabling ``-debug`` just; turns on **too much** information (such as when working on the code generator).; If you want to enable debug information with more fine-grained control, you; should define the ``DEBUG_TYPE`` macro and use the ``-debug-only`` option as; follows:. .. code-block:: c++. #define DEBUG_TYPE ""foo""; LLVM_DEBUG(dbgs() << ""'foo' debug type\n"");; #undef DEBUG_TYPE; #def",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48086,Testability,assert,assertions,48086,"is presented in a; uniform manner with the rest of the passes being executed. There are many examples of ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first argument. The pass name is taken from the ``DEBUG_TYPE`` macro, and; the description is taken from the second argument. The variable defined; (""NumXForms"" in this case) acts like an unsigned integer. Whenever you make a transformation, bump the counter:. .. code-block:: c++. ++NumXForms; // I did stuff!. That's all you have to do. To get '``opt``' to print out the statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48153,Testability,benchmark,benchmark,48153,"f ``Statistic`` uses, but the basics of using it are as; follows:. Define your statistic like this:. .. code-block:: c++. #define DEBUG_TYPE ""mypassname"" // This goes after any #includes.; STATISTIC(NumXForms, ""The # of times I did stuff"");. The ``STATISTIC`` macro defines a static variable, whose name is specified by; the first argument. The pass name is taken from the ``DEBUG_TYPE`` macro, and; the description is taken from the second argument. The variable defined; (""NumXForms"" in this case) acts like an unsigned integer. Whenever you make a transformation, bump the counter:. .. code-block:: c++. ++NumXForms; // I did stuff!. That's all you have to do. To get '``opt``' to print out the statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:50024,Testability,test,testcases,50024,"e - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG_COUNTER(DeleteAnInstruction, ""passname-delete-instruction"",; 		""Controls which instructions get delete"");. The ``DEBUG_COUNTER`` macro defines a static variable, whose name; is specified by the first argument. The name of the counter; (which is used on the command line) is specified by the second; argument, and the description used in the help is specified by the; thi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:83552,Testability,log,log,83552," for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:87013,Testability,log,logarithmic,87013,"ffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implementation based on an AVL; tree. Adding or removing elements is done through a Factory object and results; in the creation of a new ImmutableSet object. If an ImmutableSet already exists; with the given contents, then the existing one is returned; equality is compared; with a FoldingSetNodeID. The time and space complexity of add or remove; operations is logarithmic in the size of the original set. There is no method for returning an element of the set, you can only check for; membership. .. _dss_otherset:. Other Set-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplicates,; but has all the drawbacks of :ref:`std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88272,Testability,log,log,88272,"l other options, such as std::multiset and; std::unordered_set. We never use containers like unordered_set because; they are generally very expensive (each insertion requires a malloc). std::multiset is useful if you're not interested in elimination of duplicates,; but has all the drawbacks of :ref:`std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" poi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:93614,Testability,log,log,93614,"tervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar characteristics to :ref:`std::set <dss_set>`: it uses a; single allocation per pair inserted into the map, it offers log(n) lookup with; an extremely large constant factor, imposes a space penalty of 3 pointers per; pair in the map, etc. std::map is most useful when your keys or values are very large, if you need to; iterate over the collection in sorted order, or if you need stable iterators; into the map (i.e. they don't get invalidated if an insertion or deletion of; another element takes place). .. _dss_mapvector:. llvm/ADT/MapVector.h; ^^^^^^^^^^^^^^^^^^^^. ``MapVector<KeyT,ValueT>`` provides a subset of the DenseMap interface. The; main difference is that the iteration order is guaranteed to be the insertion; order, making it an easy (but somewhat expensive) solution for non-deterministic; iteration over maps of pointers. It is implemented by mapping from key to an index in a vector of key,value; pairs. This provides fast lookup and iteration, but has two main drawbacks:; the key is stored twice and removing elements takes linear time. If it is; necessary to remove elements, it's best ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:95806,Testability,log,logarithmic,95806,"f small; integers. Initially, each integer in the range 0..n-1 has its own equivalence; class. Classes can be joined by passing two class representatives to the; join(a, b) method. Two integers are in the same class when findLeader() returns; the same representative. Once all equivalence classes are formed, the map can be compressed so each; integer 0..n-1 maps to an equivalence class number in the range 0..m-1, where m; is the total number of equivalence classes. The map must be uncompressed before; it can be edited again. .. _dss_immutablemap:. llvm/ADT/ImmutableMap.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableMap is an immutable (functional) map implementation based on an AVL; tree. Adding or removing elements is done through a Factory object and results; in the creation of a new ImmutableMap object. If an ImmutableMap already exists; with the given key set, then the existing one is returned; equality is compared; with a FoldingSetNodeID. The time and space complexity of add or remove; operations is logarithmic in the size of the original map. .. _dss_othermap:. Other Map-Like Container Options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The STL provides several other options, such as std::multimap and; std::unordered_map. We never use containers like unordered_map because; they are generally very expensive (each insertion requires a malloc). std::multimap is useful if you want to map a key to multiple values, but has all; the drawbacks of std::map. A sorted vector or some other approach is almost; always better. .. _ds_bit:. Bit storage containers; ------------------------------------------------------------------------. There are several bit storage containers, and choosing when to use each is; relatively straightforward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97043,Testability,test,testing,97043,"ainers like unordered_map because; they are generally very expensive (each insertion requires a malloc). std::multimap is useful if you want to map a key to multiple values, but has all; the drawbacks of std::map. A sorted vector or some other approach is almost; always better. .. _ds_bit:. Bit storage containers; ------------------------------------------------------------------------. There are several bit storage containers, and choosing when to use each is; relatively straightforward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98348,Testability,test,testing,98348,"e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. Howev",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98482,Testability,test,testing,98482,"itVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98679,Testability,test,testing,98679,"in BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most com",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99115,Testability,log,log,99115,"his makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that ea",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101610,Testability,assert,assert,101610,"e wrapper' proxy type; (tuple of references), which combined with the structured bindings declaration; makes ``Letter`` and ``Count`` references to range elements. Any modification; to these references will affect the elements of ``Letters`` or ``Counts``. The ``zip``\ * functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:102975,Testability,assert,assert,102975,"rmance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hiera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:114649,Testability,log,logical,114649,"ward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) parameter of the ``Instruction`` constructor, you associate a; logical name with the result of the instruction's execution at run time. For; example, say that I'm writing a transformation that dynamically allocates space; for an integer on the stack, and that integer is going to be used as some kind; of index by some other code. To accomplish this, I place an ``AllocaInst`` at; the first point in the first ``BasicBlock`` of some ``Function``, and I'm; intending to use it within the same ``Function``. I might do:. .. code-block:: c++. auto *pa = new AllocaInst(Type::Int32Ty, 0, ""indexLoc"");. where ``indexLoc`` is now the logical name of the instruction's execution value,; which is a pointer to an integer on the run time stack. *Inserting instructions*. There are essentially three ways to insert an ``Instruction`` into an existing; sequence of instructions that form a ``BasicBlock``:. * Insertion into the instruction list of the ``BasicBlock``. Given a ``Basi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:114821,Testability,log,logical,114821,"ward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) parameter of the ``Instruction`` constructor, you associate a; logical name with the result of the instruction's execution at run time. For; example, say that I'm writing a transformation that dynamically allocates space; for an integer on the stack, and that integer is going to be used as some kind; of index by some other code. To accomplish this, I place an ``AllocaInst`` at; the first point in the first ``BasicBlock`` of some ``Function``, and I'm; intending to use it within the same ``Function``. I might do:. .. code-block:: c++. auto *pa = new AllocaInst(Type::Int32Ty, 0, ""indexLoc"");. where ``indexLoc`` is now the logical name of the instruction's execution value,; which is a pointer to an integer on the run time stack. *Inserting instructions*. There are essentially three ways to insert an ``Instruction`` into an existing; sequence of instructions that form a ``BasicBlock``:. * Insertion into the instruction list of the ``BasicBlock``. Given a ``Basi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:115386,Testability,log,logical,115386,"alues*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) parameter of the ``Instruction`` constructor, you associate a; logical name with the result of the instruction's execution at run time. For; example, say that I'm writing a transformation that dynamically allocates space; for an integer on the stack, and that integer is going to be used as some kind; of index by some other code. To accomplish this, I place an ``AllocaInst`` at; the first point in the first ``BasicBlock`` of some ``Function``, and I'm; intending to use it within the same ``Function``. I might do:. .. code-block:: c++. auto *pa = new AllocaInst(Type::Int32Ty, 0, ""indexLoc"");. where ``indexLoc`` is now the logical name of the instruction's execution value,; which is a pointer to an integer on the run time stack. *Inserting instructions*. There are essentially three ways to insert an ``Instruction`` into an existing; sequence of instructions that form a ``BasicBlock``:. * Insertion into the instruction list of the ``BasicBlock``. Given a ``BasicBlock* pb``, an ``Instruction* pi`` within that ``BasicBlock``,; and a newly-created instruction we wish to insert before ``*pi``, we do the; following:. .. code-block:: c++. BasicBlock *pb = ...;; Instruction *pi = ...;; auto *newInst = new Instruction(...);. newInst->insertBefore(pi); // Inserts newInst before pi. Appending to the end of a ``BasicBlock`` is so common that the ``Instruction``; class and ``Instruction``-derived classes provide constructors which take a; pointer to a ``BasicBlock`` to be appended to. For example code that looked; like:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(...);. newInst->insertInto(pb, pb->end()); // Appends newIn",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125121,Testability,stub,stub,125121,". LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:133246,Testability,assert,asserts,133246,"osed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compatible with a; default -Asserts build. Clients that want ABI compatibility; between +Asserts and -Asserts builds should use the CMake build system; to set `LLVM_ENABLE_ABI_BREAKING_CHECKS` independently; of `LLVM_ENABLE_ASSERTIONS`. .. _coreclasses:. The Core LLVM Class Hierarchy Reference; =======================================. ``#include ""llvm/IR/Type.h""``. header source: `Type.h <https://llvm.org/doxygen/Type_8h_source.html>`_. doxygen info: `Type Classes <https://llvm.org/doxygen/classllvm_1_1Type.html>`_. The Core LLVM classes are the primary means of representing the program being; inspected or transformed. The core LLVM classes are defined in header files in; the ``include/llvm/IR`` directory, and implemented in the ``lib/IR``;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:133512,Testability,assert,assertions,133512,"ers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compatible with a; default -Asserts build. Clients that want ABI compatibility; between +Asserts and -Asserts builds should use the CMake build system; to set `LLVM_ENABLE_ABI_BREAKING_CHECKS` independently; of `LLVM_ENABLE_ASSERTIONS`. .. _coreclasses:. The Core LLVM Class Hierarchy Reference; =======================================. ``#include ""llvm/IR/Type.h""``. header source: `Type.h <https://llvm.org/doxygen/Type_8h_source.html>`_. doxygen info: `Type Classes <https://llvm.org/doxygen/classllvm_1_1Type.html>`_. The Core LLVM classes are the primary means of representing the program being; inspected or transformed. The core LLVM classes are defined in header files in; the ``include/llvm/IR`` directory, and implemented in the ``lib/IR``; directory. It's worth noting that, for historical reasons, this library is; called ``libLLVMCore.so``, not ``libLLVMIR.so`` as you might expect. .. _Type:. The Type class and Derived Types; ------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:149905,Testability,assert,assertion,149905,"`. Returns another instance of the specified instruction, identical in all ways; to the original except that the instruction has no parent (i.e. it's not; embedded into a BasicBlock_), and it has no name. .. _Constant:. The ``Constant`` class and subclasses; -------------------------------------. Constant represents a base class for different types of constants. It is; subclassed by ConstantInt, ConstantArray, etc. for representing the various; types of Constants. GlobalValue_ is also a subclass, which represents the; address of a global variable or function. .. _s_Constant:. Important Subclasses of Constant; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ConstantInt : This subclass of Constant represents an integer constant of; any width. * ``const APInt& getValue() const``: Returns the underlying; value of this constant, an APInt value. * ``int64_t getSExtValue() const``: Converts the underlying APInt value to an; int64_t via sign extension. If the value (not the bit width) of the APInt; is too large to fit in an int64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``uint64_t getZExtValue() const``: Converts the underlying APInt value; to a uint64_t via zero extension. IF the value (not the bit width) of the; APInt is too large to fit in a uint64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``static ConstantInt* get(const APInt& Val)``: Returns the ConstantInt; object that represents the value provided by ``Val``. The type is implied; as the IntegerType that corresponds to the bit width of ``Val``. * ``static ConstantInt* get(const Type *Ty, uint64_t Val)``: Returns the; ConstantInt object that represents the value provided by ``Val`` for integer; type ``Ty``. * ConstantFP : This class represents a floating point constant. * ``double getValue() const``: Returns the underlying value of this constant. * ConstantArray : This represents a constant array. * ``const std::vector<Use> &getValues() const``: R",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:150174,Testability,assert,assertion,150174,"---------------------------. Constant represents a base class for different types of constants. It is; subclassed by ConstantInt, ConstantArray, etc. for representing the various; types of Constants. GlobalValue_ is also a subclass, which represents the; address of a global variable or function. .. _s_Constant:. Important Subclasses of Constant; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ConstantInt : This subclass of Constant represents an integer constant of; any width. * ``const APInt& getValue() const``: Returns the underlying; value of this constant, an APInt value. * ``int64_t getSExtValue() const``: Converts the underlying APInt value to an; int64_t via sign extension. If the value (not the bit width) of the APInt; is too large to fit in an int64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``uint64_t getZExtValue() const``: Converts the underlying APInt value; to a uint64_t via zero extension. IF the value (not the bit width) of the; APInt is too large to fit in a uint64_t, an assertion will result. For this; reason, use of this method is discouraged. * ``static ConstantInt* get(const APInt& Val)``: Returns the ConstantInt; object that represents the value provided by ``Val``. The type is implied; as the IntegerType that corresponds to the bit width of ``Val``. * ``static ConstantInt* get(const Type *Ty, uint64_t Val)``: Returns the; ConstantInt object that represents the value provided by ``Val`` for integer; type ``Ty``. * ConstantFP : This class represents a floating point constant. * ``double getValue() const``: Returns the underlying value of this constant. * ConstantArray : This represents a constant array. * ``const std::vector<Use> &getValues() const``: Returns a vector of; component constants that makeup this array. * ConstantStruct : This represents a constant struct. * ``const std::vector<Use> &getValues() const``: Returns a vector of; component constants that makeup this array. * GlobalValue : This represents eithe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:3076,Usability,guid,guide,3076,", and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the standard C++ library. #. `cplusplus.com; <https://cplusplus.com/reference/>`_ - another excellent; reference like the one above. #. `C++ In a Nutshell <http://www.tempest-sw.com/cpp/>`_ - This is an O'Reilly; book in the making. It has a decent Standard Library Reference that rivals; Dinkumware's, and is unfortunately no longer free since the book has been; published. #. `C++ Frequently Asked Questions <https://www.parashift.com/c++-faq-lite/>`_. #. `Bjarne Stroustrup's C++ Page; <https://www.stroustrup.com/C++.html>`_. #. `Bruce Eckel's Thinking in C++, 2nd ed. Volume 2.; (even better, get the book); <https://archive.org/details/TICPP2ndEdVolTwo>`_. You are also encouraged to take a look at the :doc:`LLVM Coding Standards; <CodingStandards>` guide which focuses on how to write maintainable code more; than where to put your curly braces. .. _resources:. Other useful references; -----------------------. #. `Using static and shared libraries across platforms; <http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html>`_. .. _apis:. Important and useful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:8114,Usability,simpl,simply,8114,"nter as an argument (which it; then propagates). This can sometimes be useful, allowing you to combine; several null checks into one. These five templates can be used with any classes, whether they have a v-table; or not. If you want to add support for these templates, see the document; :doc:`How to set up LLVM-style RTTI for your class hierarchy; <HowToSetUpLLVMStyleRTTI>`. .. _string_apis:. Passing strings (the ``StringRef`` and ``Twine`` classes); ---------------------------------------------------------. Although LLVM generally does not do much string manipulation, we do have several; important APIs which take strings. Two important examples are the Value class; -- which has names for instructions, functions, etc. -- and the ``StringMap``; class which is used extensively in LLVM and Clang. These are generic classes, and they need to be able to accept strings which may; have embedded null characters. Therefore, they cannot simply take a ``const; char *``, and taking a ``const std::string&`` requires clients to perform a heap; allocation which is usually unnecessary. Instead, many LLVM APIs use a; ``StringRef`` or a ``const Twine&`` for passing strings efficiently. .. _StringRef:. The ``StringRef`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``StringRef`` data type represents a reference to a constant string (a; character array and a length) and supports the common operations available on; ``std::string``, but does not require heap allocation. It can be implicitly constructed using a C style null-terminated string, an; ``std::string``, or explicitly with a character pointer and length. For; example, the ``StringMap`` find function is declared as:. .. code-block:: c++. iterator find(StringRef Key);. and clients can call it using any one of:. .. code-block:: c++. Map.find(""foo""); // Lookup ""foo""; Map.find(std::string(""bar"")); // Lookup ""bar""; Map.find(StringRef(""\0baz"", 4)); // Lookup ""\0baz"". Similarly, APIs which need to return a string may return a ``StringRef``; ins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12119,Usability,simpl,simpler,12119,":. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17934,Usability,simpl,simple,17934," errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26217,Usability,simpl,simplifies,26217,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26576,Usability,simpl,simplifying,26576,"know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27086,Usability,simpl,simplify,27086," message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatte",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30345,Usability,simpl,simplify,30345,"te <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30618,Usability,simpl,simplifies,30618,"andlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` val",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32046,Usability,simpl,simplify,32046," a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32680,Usability,simpl,simplifies,32680,"eMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32850,Usability,simpl,simply,32850,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:35808,Usability,simpl,simply,35808," errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and retur",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49465,Usability,simpl,simplified,49465,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53844,Usability,simpl,simply,53844,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54482,Usability,clear,clear,54482,"e; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:54547,Usability,clear,clearGraphAttrs,54547,"g on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58138,Usability,simpl,simple,58138,"elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case whe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58403,Usability,simpl,simple,58403,"nts to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59450,Usability,simpl,simple,59450,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65214,Usability,clear,clear,65214," is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports eff",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70809,Usability,simpl,simplified,70809,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71717,Usability,simpl,simple,71717,"These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:72192,Usability,simpl,simple,72192,"to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it can easily lead to dangling pointers, and is not suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:73806,Usability,simpl,simple,73806,"t suitable for; embedding in datastructures in most cases (instead, use an std::string or; something like that). #. For the same reason, StringRef cannot be used as the return value of a; method if the method ""computes"" the result string. Instead, use std::string. #. StringRef's do not allow you to mutate the pointed-to string bytes and it; doesn't allow you to insert or remove bytes from the range. For editing; operations like this, it interoperates with the :ref:`Twine <dss_twine>`; class. Because of its strengths and limitations, it is very common for a function to; take a StringRef and for a method on an object to return a StringRef that points; into some string that it owns. .. _dss_twine:. llvm/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient tha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:74526,Usability,simpl,simple,74526,"m/ADT/Twine.h; ^^^^^^^^^^^^^^^^. The Twine class is used as an intermediary datatype for APIs that want to take a; string that can be constructed inline with a series of concatenations. Twine; works by forming recursive instances of the Twine datatype (a simple value; object) on the stack as temporary objects, linking them together into a tree; which is then linearized when the Twine is consumed. Twine is only safe to use; as the argument to a function, and should always be a const reference, e.g.:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; foo(X + ""."" + Twine(i));. This example forms a string like ""blarg.42"" by concatenating the values; together, and does not form intermediate strings containing ""blarg"" or ""blarg."". Because Twine is constructed with temporary objects on the stack, and because; these instances are destroyed at the end of the current statement, it is an; inherently dangerous API. For example, this simple variant contains undefined; behavior and will probably crash:. .. code-block:: c++. void foo(const Twine &T);; ...; StringRef X = ...; unsigned i = ...; const Twine &Tmp = X + ""."" + Twine(i);; foo(Tmp);. ... because the temporaries are destroyed before the call. That said, Twine's; are much more efficient than intermediate std::string temporaries, and they work; really well with StringRef. Just be aware of their limitations. .. _dss_smallstring:. llvm/ADT/SmallString.h; ^^^^^^^^^^^^^^^^^^^^^^. SmallString is a subclass of :ref:`SmallVector <dss_smallvector>` that adds some; convenience APIs like += that takes StringRef's. SmallString avoids allocating; memory in the case when the preallocated space is enough to hold its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78230,Usability,simpl,simple,78230,"pproach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80038,Usability,simpl,simple,80038," insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet ad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80272,Usability,simpl,simple,80272,"the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80830,Usability,clear,clear,80830,"range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polym",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81393,Usability,clear,clear,81393,"at; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which po",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:90681,Usability,simpl,simple,90681,"le, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key typ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:101831,Usability,clear,clearly,101831,"functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefer to use ``zip_equal`` when you expect all; ranges to have the same lengths, and consider alternative ``zip`` functions only; when this is not the case. This is because ``zip_equal`` clearly communicates; this same-length assumption and has the best (release-mode) runtime performance. .. _uf_enumerate:. ``enumerate``; ^^^^^^^^^^^^^. The ``enumerate`` functions allows to iterate over one or more ranges while; keeping track of the index of the current loop iteration. For example:. .. code-block:: c++. for (auto [Idx, BB, Value] : enumerate(Phi->blocks(),; Phi->incoming_values())); errs() << ""#"" << Idx << "" "" << BB->getName() << "": "" << *Value << ""\n"";. The current element index is provided as the first structured bindings element.; Alternatively, the index and the element value can be obtained with the; ``index()`` and ``value()`` member functions:. .. code-block:: c++. char Letters[26] = ...;; for (auto En : enumerate(Letters)); errs() << ""#"" << En.index() << "" "" << En.value() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103638,Usability,simpl,simple,103638,"alue() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) returns an iterator to the start of the sequence, the ``XXXend()``; function returns an iterator pointing to one past the last valid element of the; sequence, and there ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:109637,Usability,learn,learn,109637,"esponding iterator, and; this is a constant time operation (very efficient). The following code snippet; illustrates use of the conversion constructors provided by LLVM iterators. By; using these, you can explicitly grab the iterator of something without actually; obtaining it via iteration over some structure:. .. code-block:: c++. void printNextInstruction(Instruction* inst) {; BasicBlock::iterator it(inst);; ++it; // After this line, it refers to the instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:110223,Usability,simpl,simply,110223,"e instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:111375,Usability,simpl,simple,111375,"{; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` is called a *def-use* chain. For example, let's say we have a; ``Function*`` named ``F`` to a particular function ``foo``. Finding all of the; instructions that *use* ``foo`` is as simple as iterating over the *def-use*; chain of ``F``:. .. code-block:: c++. Function *F = ...;. for (User *U : F->users()) {; if (Instruction *Inst = dyn_cast<Instruction>(U)) {; errs() << ""F is used in instruction:\n"";; errs() << *Inst << ""\n"";; }. Alternatively, it's common to have an instance of the ``User`` Class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1User.html>`__) and need to know what; ``Value``\ s are used by it. The list of all ``Value``\ s used by a ``User`` is; known as a *use-def* chain. Instances of class ``Instruction`` are common; ``User`` s, so we might want to iterate over all of the values that a particular; instruction uses (that is, the operands of the particular ``Instruction``):. .. code-block:: c++. Instruction *pi = ...;. for (Use &U : pi->operands()) {; Value *v = U.get();; // ...; }. Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; consta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113194,Usability,simpl,simple,113194,"Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; constant flavors as ``Value::const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113735,Usability,simpl,simply,113735,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) param",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:117052,Usability,simpl,simple,117052,"ock`` is so common that the ``Instruction``; class and ``Instruction``-derived classes provide constructors which take a; pointer to a ``BasicBlock`` to be appended to. For example code that looked; like:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(...);. newInst->insertInto(pb, pb->end()); // Appends newInst to pb. becomes:. .. code-block:: c++. BasicBlock *pb = ...;; auto *newInst = new Instruction(..., pb);. which is much cleaner, especially if you are creating long instruction; streams. * Insertion using an instance of ``IRBuilder``. Inserting several ``Instruction``\ s can be quite laborious using the previous; methods. The ``IRBuilder`` is a convenience class that can be used to add; several instructions to the end of a ``BasicBlock`` or before a particular; ``Instruction``. It also supports constant folding and renaming named; registers (see ``IRBuilder``'s template arguments). The example below demonstrates a very simple use of the ``IRBuilder`` where; three instructions are inserted before the instruction ``pi``. The first two; instructions are Call instructions and third instruction multiplies the return; value of the two calls. .. code-block:: c++. Instruction *pi = ...;; IRBuilder<> Builder(pi);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. The example below is similar to the above example except that the created; ``IRBuilder`` inserts instructions at the end of the ``BasicBlock`` ``pb``. .. code-block:: c++. BasicBlock *pb = ...;; IRBuilder<> Builder(pb);; CallInst* callOne = Builder.CreateCall(...);; CallInst* callTwo = Builder.CreateCall(...);; Value* result = Builder.CreateMul(callOne, callTwo);. See :doc:`tutorial/LangImpl03` for a practical use of the ``IRBuilder``. .. _schanges_deleting:. Deleting Instructions; ^^^^^^^^^^^^^^^^^^^^^. Deleting an instruction from an existing sequence of instructions that form a; Basi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:121320,Usability,guid,guidelines,121320,"ue.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initial",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:122305,Usability,simpl,simple,122305,"ts *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initialization of static resources, such as the global type tables. In a; single-threaded environment, it implements a simple lazy initialization scheme.; When LLVM is compiled with support for multi-threading, however, it uses; double-checked locking to implement thread-safe lazy initialization. .. _llvmcontext:. Achieving Isolation with ``LLVMContext``; ----------------------------------------. ``LLVMContext`` is an opaque class in the LLVM API which clients can use to; operate multiple, isolated instances of LLVM concurrently within the same; address space. For instance, in a hypothetical compile-server, the compilation; of an individual translation unit is conceptually independent from all the; others, and it would be desirable to be able to compile incoming translation; units concurrently on independent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:126478,Usability,simpl,simply,126478,"nusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:128076,Usability,simpl,simplicity,128076,"the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the; ``Use`` objects belonging to the same ``User`` form a contiguous array. We have 2 different layouts in the ``User`` (sub)classes:. * Layout a). The ``Use`` object(s) are inside (resp. at fixed offset) of the ``User``; object and there are a fixed number of them. * Layout b). The ``Use`` object(s) are referenced by a pointer to an array from the; ``User`` object and there may be a variable number of them. As of v2.4 each layout still possesses a direct pointer to the start of the; array of ``Use``\ s. Though not mandatory for layout a), we stick to this; redundancy for the sake of simplicity. The ``User`` object also stores the; number of ``Use`` objects it has. (Theoretically this information can also be; calculated given the scheme presented below.). Special forms of allocation operators (``operator new``) enforce the following; memory layouts:. * Layout a) is modelled by prepending the ``User`` object by the ``Use[]``; array. .. code-block:: none. ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:140312,Usability,simpl,simply,140312,"ble()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, Constant *FunctionPtr}``, rather; than simply the ``Function*`` with potentially an unexpected; signature. * ``std::string getTypeName(const Type *Ty)``. If there is at least one entry in the SymbolTable_ for the specified Type_,; return it. Otherwise return the empty string. * ``bool addTypeName(const std::string &Name, const Type *Ty)``. Insert an entry in the SymbolTable_ mapping ``Name`` to ``Ty``. If there is; already an entry for this name, true is returned and the SymbolTable_ is not; modified. .. _Value:. The ``Value`` class; -------------------. ``#include ""llvm/IR/Value.h""``. header source: `Value.h <https://llvm.org/doxygen/Value_8h_source.html>`_. doxygen info: `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_. The ``Value`` class is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Con",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143064,Usability,simpl,simplifies,143064,"able through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:5154,Availability,error,error,5154,"===========================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of librari",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:809,Deployability,install,installation,809,"========================; Creating an LLVM Project; ========================. .. contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8562,Integrability,depend,depend,8562,"MPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have any questions or need any help creating an LLVM project, the LLVM; team would be more than happy to help. You can always post your questions to; the `Discourse forums; <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:369,Modifiability,variab,variables,369,"========================; Creating an LLVM Project; ========================. .. contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:398,Modifiability,variab,variables,398,"========================; Creating an LLVM Project; ========================. .. contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:959,Modifiability,config,config,959,"========================; Creating an LLVM Project; ========================. .. contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:1100,Modifiability,variab,variables,1100," contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will hav",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:1276,Modifiability,config,configure,1276," the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:1313,Modifiability,config,configure,1313," the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:4301,Modifiability,variab,variables,4301,"n ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:4335,Modifiability,variab,variables,4335,"t>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:4437,Modifiability,variab,variable,4437,"de` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:5336,Modifiability,variab,variable,5336,"they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLI",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:5685,Modifiability,variab,variable,5685,"uld set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``li",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:5897,Modifiability,variab,variable,5897," is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. No",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:6076,Modifiability,variab,variable,6076," they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:6466,Modifiability,variab,variable,6466,"UILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7162,Modifiability,config,config,7162," into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7295,Modifiability,variab,variable,7295,"` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefile",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7395,Modifiability,config,config,7395,"` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefile",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7612,Modifiability,variab,variable,7612,"be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon wheth",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8043,Modifiability,variab,variable,8043,"ay be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have an",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3773,Performance,perform,performance,3773,"e files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; ------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:6702,Performance,perform,performs,6702,"Y`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8802,Performance,optimiz,optimized,8802,"MPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have any questions or need any help creating an LLVM project, the LLVM; team would be more than happy to help. You can always post your questions to; the `Discourse forums; <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8992,Performance,optimiz,optimized,8992,"MPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have any questions or need any help creating an LLVM project, the LLVM; team would be more than happy to help. You can always post your questions to; the `Discourse forums; <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3000,Testability,test,test,3000,"all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3041,Testability,test,tests,3041,"ary that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3102,Testability,test,tests,3102,"at will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3191,Testability,test,tests,3191,"s can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM bu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3267,Testability,test,tests,3267,"ace for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3283,Testability,test,test,3283,"ace for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3297,Testability,test,tests,3297,"hich they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a lis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3349,Testability,test,testing,3349,"hich they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a lis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3368,Testability,test,test,3368,"er files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3417,Testability,test,test,3417,"er files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3455,Testability,test,test,3455,"er files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3558,Testability,test,test,3558,"*include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3582,Testability,benchmark,benchmarks,3582,"*include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3689,Testability,test,test,3689,"e files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; ------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3837,Testability,test,tests,3837,"ur source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. The",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3868,Testability,test,test,3868,"ur source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. The",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3876,Testability,test,testing,3876,"ur source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. The",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:2750,Usability,simpl,simply,2750," benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and comp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3902,Usability,simpl,simply,3902,"**tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of dir",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Projects.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1498,Availability,failure,failures,1498,"; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3205,Availability,error,error,3205,"========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very fr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3533,Availability,fault,faulting,3533,"iles. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3908,Availability,avail,available,3908,"Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5110,Deployability,patch,patched,5110,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1379,Energy Efficiency,reduce,reducer,1379,"ementPtr; GlobalISel/index; GwpAsan; HowToSetUpLLVMStyleRTTI; HowToUseAttributes; InAlloca; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAllo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1830,Integrability,interface,interfaces,1830,"Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:4633,Integrability,depend,dependence,4633,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:979,Modifiability,inherit,inherits,979,"Reference; =========. LLVM and API reference documentation. .. contents::; :local:. .. toctree::; :hidden:. Atomics; BitCodeFormat; BlockFrequencyTerminology; BranchWeightMetadata; Bugpoint; CommandGuide/index; ConvergenceAndUniformity; ConvergentOperations; Coroutines; DependenceGraphs/index; ExceptionHandling; Extensions; FaultMaps; FuzzingLLVM; GarbageCollection; GetElementPtr; GlobalISel/index; GwpAsan; HowToSetUpLLVMStyleRTTI; HowToUseAttributes; InAlloca; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1477,Performance,optimiz,optimization-induced,1477,"; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3605,Performance,concurren,concurrency,3605,"nce manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3211,Safety,detect,detection,3211,"========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very fr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:4345,Security,secur,security-hardened,4345,"Ray in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for usin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5212,Security,authenticat,authentication,5212,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1369,Testability,test,test-case,1369,"ementPtr; GlobalISel/index; GwpAsan; HowToSetUpLLVMStyleRTTI; HowToUseAttributes; InAlloca; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAllo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1559,Testability,log,log,1559," PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Referen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:2655,Testability,test,test,2655,"izer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3060,Testability,test,testing,3060,"Fuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about termino",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3144,Testability,test,test-suite,3144,"VM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides informa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:3155,Testability,benchmark,benchmarks,3155,"VM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrastructure. :doc:`TestSuiteGuide`; Describes how to compile and run the test-suite benchmarks. :doc:`GwpAsan`; A sampled heap memory error detection toolkit designed for production use. ====; XRay; ====. :doc:`XRay`; High-level documentation of how to use XRay in LLVM. :doc:`XRayExample`; An example of how to debug an application with XRay. =================; Additional Topics; =================. :doc:`FaultMaps`; LLVM support for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides informa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:2093,Usability,guid,guided,2093,"nfrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` operation semantics and related intrinsics. =====================; Testing and Debugging; =====================. :doc:`LLVM Testing Infrastructure Guide <TestingGuide>`; A reference manual for using the LLVM testing infrast",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5316,Usability,guid,guide,5316,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Reference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:319,Availability,down,download,319,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:672,Availability,down,downloaded,672,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2680,Availability,error,error,2680,"ding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15736,Availability,failure,failure,15736,"upports the ``--line-numbers`` (``-l``) option to use; debugging information to print symbols' filenames and line numbers. * ``llvm-rc`` and ``llvm-windres`` now accept file path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:17196,Availability,avail,available,17196,"re files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:19298,Availability,avail,available,19298,"Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://llvm.org/>`_, in particular in the `documentation; <https://llvm.org/docs/>`_ section. The web page also contains versions of the; API documentation which is up-to-date with the Git version of the source; code. You can access versions of these documents specific to this release by; going into the ``llvm/docs/`` directory in the LLVM tree. If you have any questions or comments about LLVM, please feel free to contact; us via the `Discourse forums <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:36,Deployability,release,release,36,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:210,Deployability,release,release,210,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:247,Deployability,release,releases,247,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:301,Deployability,release,releases,301,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:392,Deployability,release,release,392,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:445,Deployability,release,release,445,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:454,Deployability,release,release,454,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:549,Deployability,release,release,549,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:656,Deployability,release,releases,656,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:699,Deployability,release,releases,699,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:735,Deployability,release,releases,735,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:822,Deployability,release,release,822,"============================; LLVM |release| Release Notes; ============================. .. contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1138,Deployability,release,release,1138,". contents::; :local:. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming LLVM |version| release.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ash",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1180,Deployability,release,release,1180,"se.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1209,Deployability,release,release,1209,"se.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1234,Deployability,release,releases,1234,"se.; Release notes for previous releases can be found on; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1267,Deployability,release,releases,1267,"; `the Download Page <https://releases.llvm.org/download.html>`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1323,Deployability,release,release,1323,">`_. Introduction; ============. This document contains the release notes for the LLVM Compiler Infrastructure,; release |release|. Here we describe the status of LLVM, including major improvements; from the previous release, improvements in various subprojects of LLVM, and; some of the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2442,Deployability,configurat,configuration,2442,"n entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2465,Deployability,update,updated,2465,"n entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6850,Deployability,upgrade,upgraded,6850,"te`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Zvknhb, Zvks,; Zvksc, Zvksed, Zvksg, Zvksh, and Zvkt extension version was upgraded to 1.0; and is no longer experimental. However, the C intrinsics for these extensions; are still experimental. To use the C intrinsics for these extensions,; ``-menable-experimental-extensions`` needs to be passed to Clang.; * XSfcie extension and SiFive CSRs and instructions that were associated with; it have been removed. None of these CSRs and instructions were part of; ""SiFive Custom Instruction Extension"" as SiFive defines it. The LLVM pro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6932,Deployability,upgrade,upgraded,6932,"y to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Zvknhb, Zvks,; Zvksc, Zvksed, Zvksg, Zvksh, and Zvkt extension version was upgraded to 1.0; and is no longer experimental. However, the C intrinsics for these extensions; are still experimental. To use the C intrinsics for these extensions,; ``-menable-experimental-extensions`` needs to be passed to Clang.; * XSfcie extension and SiFive CSRs and instructions that were associated with; it have been removed. None of these CSRs and instructions were part of; ""SiFive Custom Instruction Extension"" as SiFive defines it. The LLVM project; needs to work with SiFive to define and document real extension names for;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:7384,Deployability,upgrade,upgraded,7384,"-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Zvknhb, Zvks,; Zvksc, Zvksed, Zvksg, Zvksh, and Zvkt extension version was upgraded to 1.0; and is no longer experimental. However, the C intrinsics for these extensions; are still experimental. To use the C intrinsics for these extensions,; ``-menable-experimental-extensions`` needs to be passed to Clang.; * XSfcie extension and SiFive CSRs and instructions that were associated with; it have been removed. None of these CSRs and instructions were part of; ""SiFive Custom Instruction Extension"" as SiFive defines it. The LLVM project; needs to work with SiFive to define and document real extension names for; individual CSRs and instructions.; * ``-mcpu=sifive-p450`` was added.; * CodeGen of RV32E/RV64E was supported experimentally.; * CodeGen of ilp32e/lp64e was supported experimentally.; * Support was added for the Ziccif, Ziccrse, Ziccamoa, Zicclsm, Za64rs, Za128rs; and Zic64b extensions which were introduced as a part of the RISC-V Profiles; specification.; * The Smepmp 1.0 extension is now suppo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15254,Deployability,update,updated,15254,"LF input and binary output files only.; * ``llvm-objcopy`` now supports ``-O elf64-s390`` for SystemZ. * Supported parsing XCOFF auxiliary symbols in ``obj2yaml``. * ``llvm-ranlib`` now supports ``-X`` on AIX to specify the type of object file; ranlib should examine. * ``llvm-cxxfilt`` now supports ``--no-params``/``-p`` to skip function; parameters. * ``llvm-nm`` now supports ``--export-symbol`` to ignore the import symbol file.; * ``llvm-nm`` now supports the ``--line-numbers`` (``-l``) option to use; debugging information to print symbols' filenames and line numbers. * ``llvm-rc`` and ``llvm-windres`` now accept file path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16037,Deployability,install,installation,16037,"gument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16074,Deployability,update,updated,16074,"gument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:19611,Deployability,release,release,19611,"Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://llvm.org/>`_, in particular in the `documentation; <https://llvm.org/docs/>`_ section. The web page also contains versions of the; API documentation which is up-to-date with the Git version of the source; code. You can access versions of these documents specific to this release by; going into the ``llvm/docs/`` directory in the LLVM tree. If you have any questions or comments about LLVM, please feel free to contact; us via the `Discourse forums <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:5648,Energy Efficiency,schedul,scheduling,5648,"finition and intrinsics support for new instructions that were; introduced in LoongArch Reference Manual V1.10.; * Emitted adjacent ``pcaddu18i+jirl`` instrunction sequence with one relocation; ``R_LARCH_CALL36`` instead of ``pcalau12i+jirl`` with two relocations; ``R_LARCH_PCALA_{HI20,LO12}`` for function call in medium code model.; * The code model of global variables can now be overridden by means of the newly; added LLVM IR attribute, ``code_model``.; * Added support for the ``llvm.is.fpclass`` intrinsic.; * ``mulodi4`` and ``muloti4`` libcalls were disabled due to absence in libgcc.; * Added initial support for auto vectorization.; * Added initial support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:5926,Energy Efficiency,reduce,reduce,5926,"; ``R_LARCH_PCALA_{HI20,LO12}`` for function call in medium code model.; * The code model of global variables can now be overridden by means of the newly; added LLVM IR attribute, ``code_model``.; * Added support for the ``llvm.is.fpclass`` intrinsic.; * ``mulodi4`` and ``muloti4`` libcalls were disabled due to absence in libgcc.; * Added initial support for auto vectorization.; * Added initial support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2659,Integrability,message,messages,2659,"ding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:13375,Integrability,depend,depend,13375," fast-math flags of an instruction, as well as ``LLVMCanValueUseFastMathFlags``; for checking if an instruction can use such flags. Changes to the CodeGen infrastructure; -------------------------------------. * A new debug type ``isel-dump`` is added to show only the SelectionDAG dumps; after each ISel phase (i.e. ``-debug-only=isel-dump``). This new debug type; can be filtered by function names using ``-filter-print-funcs=<function names>``,; the same flag used to filter IR dumps after each Pass. Note that the existing; ``-debug-only=isel`` will take precedence over the new behavior and; print SelectionDAG dumps of every single function regardless of; ``-filter-print-funcs``'s values. * ``PrologEpilogInserter`` no longer supports register scavenging; during forwards frame index elimination. Targets should use; backwards frame index elimination instead. * ``RegScavenger`` no longer supports forwards register; scavenging. Clients should use backwards register scavenging; instead, which is preferred because it does not depend on accurate; kill flags. Changes to the Metadata Info; ---------------------------------; * Added a new loop metadata `!{!""llvm.loop.align"", i32 64}`. Changes to the Debug Info; ---------------------------------. Changes to the LLVM tools; ---------------------------------. * ``llvm-symbolizer`` now treats invalid input as an address for which source; information is not found.; * Fixed big-endian support in ``llvm-symbolizer``'s DWARF location parser.; * ``llvm-readelf`` now supports ``--extra-sym-info`` (``-X``) to display extra; information (section name) when showing symbols.; * ``llvm-readobj``/``llvm-readelf`` now supports ``--decompress``/``-z`` with; string and hex dump for ELF object files. * ``llvm-symbolizer`` and ``llvm-addr2line`` now support addresses specified as symbol names. * ``llvm-objcopy`` now supports ``--gap-fill`` and ``--pad-to`` options, for; ELF input and binary output files only.; * ``llvm-objcopy`` now supports ``-O e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16581,Integrability,protocol,protocol,16581,"precated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2287,Modifiability,variab,variable,2287,"eases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2317,Modifiability,variab,variables,2317," this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2442,Modifiability,config,configuration,2442,"n entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:5012,Modifiability,variab,variables,5012,"rounding>`. * The default :ref:`AMDHSA code object version <amdgpu-amdhsa-code-object-metadata-v5>` is now 5. Changes to the ARM Backend; --------------------------. * Added support for Cortex-M52 CPUs.; * Added execute-only support for Armv6-M. Changes to the AVR Backend; --------------------------. Changes to the DirectX Backend; ------------------------------. Changes to the Hexagon Backend; ------------------------------. Changes to the LoongArch Backend; --------------------------------. * Added intrinsics support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; * Added definition and intrinsics support for new instructions that were; introduced in LoongArch Reference Manual V1.10.; * Emitted adjacent ``pcaddu18i+jirl`` instrunction sequence with one relocation; ``R_LARCH_CALL36`` instead of ``pcalau12i+jirl`` with two relocations; ``R_LARCH_PCALA_{HI20,LO12}`` for function call in medium code model.; * The code model of global variables can now be overridden by means of the newly; added LLVM IR attribute, ``code_model``.; * Added support for the ``llvm.is.fpclass`` intrinsic.; * ``mulodi4`` and ``muloti4`` libcalls were disabled due to absence in libgcc.; * Added initial support for auto vectorization.; * Added initial support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV ins",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6005,Modifiability,extend,extended,6005," model of global variables can now be overridden by means of the newly; added LLVM IR attribute, ``code_model``.; * Added support for the ``llvm.is.fpclass`` intrinsic.; * ``mulodi4`` and ``muloti4`` libcalls were disabled due to absence in libgcc.; * Added initial support for auto vectorization.; * Added initial support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics wer",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:9931,Modifiability,variab,variables,9931,"etermine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZEx",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:10099,Modifiability,variab,variable,10099,"etermine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZEx",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15073,Modifiability,variab,variable,15073,"t files. * ``llvm-symbolizer`` and ``llvm-addr2line`` now support addresses specified as symbol names. * ``llvm-objcopy`` now supports ``--gap-fill`` and ``--pad-to`` options, for; ELF input and binary output files only.; * ``llvm-objcopy`` now supports ``-O elf64-s390`` for SystemZ. * Supported parsing XCOFF auxiliary symbols in ``obj2yaml``. * ``llvm-ranlib`` now supports ``-X`` on AIX to specify the type of object file; ranlib should examine. * ``llvm-cxxfilt`` now supports ``--no-params``/``-p`` to skip function; parameters. * ``llvm-nm`` now supports ``--export-symbol`` to ignore the import symbol file.; * ``llvm-nm`` now supports the ``--line-numbers`` (``-l``) option to use; debugging information to print symbols' filenames and line numbers. * ``llvm-rc`` and ``llvm-windres`` now accept file path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16686,Modifiability,variab,variable,16686,"ve had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialC",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16805,Modifiability,plugin,plugin,16805,"irectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource direct",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16892,Modifiability,variab,variable,16892," it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is tran",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18758,Modifiability,variab,variable,18758,"ad of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://llvm.org/>`_, in particular in the `documentation; <https://llvm.org/docs/>`_ section. The web page also contains versions of the; API documentation which is up-to-date with the Git version of the source; code. You can access versions of these documents specific to this release by; going into the ``llvm/docs/`` directory in the LLVM tree. If you have any questions or comments about LLVM, please feel free to contact; us via the `Discourse forums <https:/",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6389,Performance,optimiz,optimization,6389,"e MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Zvknhb, Zvks,; Zvksc, Zvksed, Zvksg, Zvksh, and Zvkt extension version was upgra",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18173,Performance,tune,tune,18173," SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; =============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:15906,Safety,avoid,avoiding,15906,"le path references in ``.rc`` files; concatenated from multiple string literals. * The ``llvm-windres`` option ``--preprocessor`` now resolves its argument; in the ``PATH`` environment variable as expected, and options passed with; ``--preprocessor-arg`` are placed before the input file as they should; be. * The ``llvm-windres`` option ``--preprocessor`` has been updated with the; breaking behaviour change from GNU windres from binutils 2.36, where; the whole argument is considered as one path, not considered as a; sequence of tool name and parameters. Changes to LLDB; ---------------------------------. * ``SBWatchpoint::GetHardwareIndex`` is deprecated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:17555,Safety,detect,detecting,17555,"cquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:3669,Security,access,accesses,3669," standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; accesses at reguilar intervals so that a guard area at the top of the stack; can't be skipped over. Changes to the AMDGPU Backend; -----------------------------. * `llvm.sqrt.f32` is now lowered correctly. Use `llvm.amdgcn.sqrt.f32`; for raw instruction access. * Implemented `llvm.stacksave` and `llvm.stackrestore` intrinsics. * Implemented :ref:`llvm.get.rounding <int_get_rounding>`. * The default :ref:`AMDHSA code object version <amdgpu-amdhsa-code-object-metadata-v5>` is now 5. Changes to the ARM Backend; --------------------------. * Added support for Cortex-M52 CPUs.; * Added execute-only support for Armv6-M. Changes to the AVR Backend; --------------------------. Changes to the DirectX Backend; ------------------------------. Changes to the Hexagon Backend; ------------------------------. Changes to the LoongArch Backend; --------------------------------. * Added intrinsics support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; * Added definition and intrinsic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:3923,Security,access,access,3923,"-----------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; accesses at reguilar intervals so that a guard area at the top of the stack; can't be skipped over. Changes to the AMDGPU Backend; -----------------------------. * `llvm.sqrt.f32` is now lowered correctly. Use `llvm.amdgcn.sqrt.f32`; for raw instruction access. * Implemented `llvm.stacksave` and `llvm.stackrestore` intrinsics. * Implemented :ref:`llvm.get.rounding <int_get_rounding>`. * The default :ref:`AMDHSA code object version <amdgpu-amdhsa-code-object-metadata-v5>` is now 5. Changes to the ARM Backend; --------------------------. * Added support for Cortex-M52 CPUs.; * Added execute-only support for Armv6-M. Changes to the AVR Backend; --------------------------. Changes to the DirectX Backend; ------------------------------. Changes to the Hexagon Backend; ------------------------------. Changes to the LoongArch Backend; --------------------------------. * Added intrinsics support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; * Added definition and intrinsics support for new instructions that were; introduced in LoongArch Reference Manual V1.10.; * Emitted adjacent ``pcaddu18i+jirl`` instrunction sequence with one relocation; ``R_LARCH_CALL36`` instead of ``pcalau12i+jirl`` with two relocations; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6290,Security,access,access,6290,"support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Z",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:10156,Security,audit,audited,10156," used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZExt``; * ``LLVMConstSExt``; * ``LLVMConstZExtOrBitCast``; * ``LLVMConstSExtOrBitCast``; * ``LLVMConstIntCast``; * ``LLVMConstFPTrunc``; * ``LLVMConstFPExt``; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:11462,Security,expose,exposes,11462,"and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZExt``; * ``LLVMConstSExt``; * ``LLVMConstZExtOrBitCast``; * ``LLVMConstSExtOrBitCast``; * ``LLVMConstIntCast``; * ``LLVMConstFPTrunc``; * ``LLVMConstFPExt``; * ``LLVMConstFPToUI``; * ``LLVMConstFPToSI``; * ``LLVMConstUIToFP``; * ``LLVMConstSIToFP``; * ``LLVMConstFPCast``. * Added ``LLVMCreateTargetMachineWithOptions``, along with helper functions for; an opaque option structure, as an alternative to ``LLVMCreateTargetMachine``.; The option structure exposes an additional setting (i.e., the target ABI) and; provides default values for unspecified settings. * Added ``LLVMGetNNeg`` and ``LLVMSetNNeg`` for getting/setting the new nneg flag; on zext instructions, and ``LLVMGetIsDisjoint`` and ``LLVMSetIsDisjoint``; for getting/setting the new disjoint flag on or instructions. * Added the following functions for manipulating operand bundles, as well as; building ``call`` and ``invoke`` instructions that use operand bundles:. * ``LLVMBuildCallWithOperandBundles``; * ``LLVMBuildInvokeWithOperandBundles``; * ``LLVMCreateOperandBundle``; * ``LLVMDisposeOperandBundle``; * ``LLVMGetNumOperandBundles``; * ``LLVMGetOperandBundleAtIndex``; * ``LLVMGetNumOperandBundleArgs``; * ``LLVMGetOperandBundleArgAtIndex``; * ``LLVMGetOperandBundleTag``. * Added ``LLVMGetFastMathFlags`` and ``LLVMSetFastMathFlags`` for getting/setting; the fast-math flags of an instruction, as well as ``LLVMCanValueUseFastMathFlags``; for checking if an instruction can use such f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:17684,Security,sanitiz,sanitizer,17684," variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D15715",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:19559,Security,access,access,19559,"Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://llvm.org/>`_, in particular in the `documentation; <https://llvm.org/docs/>`_ section. The web page also contains versions of the; API documentation which is up-to-date with the Git version of the source; code. You can access versions of these documents specific to this release by; going into the ``llvm/docs/`` directory in the LLVM tree. If you have any questions or comments about LLVM, please feel free to contact; us via the `Discourse forums <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:1608,Usability,simpl,simply,1608,"the current users of the code. All LLVM releases may be downloaded; from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about LLVM, including information about the latest; release, please check out the `main LLVM web site <https://llvm.org/>`_. If you; have questions or comments, the `Discourse forums; <https://discourse.llvm.org>`_ is a good place to ask; them. Note that if you are reading this file from a Git checkout or the main; LLVM web page, this document applies to the *next* release, not the current; one. To see the release notes for a specific release, please see the `releases; page <https://llvm.org/releases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:9847,Usability,clear,clearwaterforest,9847,"-----------------. Changes to the Windows Target; -----------------------------. * The LLVM filesystem class ``UniqueID`` and function ``equivalent()``; no longer determine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18328,Usability,simpl,simplify,18328,"this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4415,Availability,failure,failures,4415,"=======. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4501,Availability,error,errors,4501,"o use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4702,Availability,failure,failures,4702,"cation and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5110,Availability,down,download,5110,"ns, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5611,Availability,error,error,5611,"rs are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or lin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5781,Availability,down,download,5781,"; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6207,Availability,error,errors,6207,"es are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in betwe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6660,Availability,avail,available,6660,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6697,Availability,down,download,6697,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6825,Availability,failure,failures,6825,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:209,Deployability,release,release,209,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:267,Deployability,release,release,267,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:326,Deployability,release,release,326,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:451,Deployability,release,release,451,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:600,Deployability,release,release,600,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:635,Deployability,release,release,635,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:680,Deployability,release,release,680,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:850,Deployability,release,release,850,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1027,Deployability,release,release,1027,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1278,Deployability,release,release,1278,"se. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1584,Deployability,release,release,1584,"enchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1610,Deployability,release,release,1610,"Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1851,Deployability,install,installed,1851,"'s a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2037,Deployability,release,release,2037,"se. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before ru",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2069,Deployability,release,release,2069,"f the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2084,Deployability,release,release,2084,"many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2366,Deployability,release,release,2366,"end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2470,Deployability,release,release,2470,"cripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The bin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2669,Deployability,release,release,2669,"libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2788,Deployability,release,release,2788,"libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3662,Deployability,install,install,3662,"r release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3822,Deployability,install,install,3822,"and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; =============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3858,Deployability,install,install,3858,"and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; =============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4016,Deployability,install,install,4016,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4056,Deployability,install,install,4056,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4137,Deployability,release,release,4137,"; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.htm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4148,Deployability,release,release,4148,"; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.htm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4656,Deployability,release,release,4656,"o use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4753,Deployability,release,release-process,4753,"run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4846,Deployability,release,release,4846,"; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4979,Deployability,release,release,4979,"; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5016,Deployability,release,release,5016,"; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5062,Deployability,release,release,5062,"/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5101,Deployability,release,releases,5101,"ns, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5140,Deployability,release,release,5140," release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5333,Deployability,install,install,5333,", which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candid",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5762,Deployability,release,release,5762,"; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5908,Deployability,release,release,5908,"; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6000,Deployability,release,release,6000," candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6054,Deployability,release,releases,6054,"evious release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests sho",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6265,Deployability,release,release,6265,"es are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in betwe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6303,Deployability,release,release,6303,"``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbeha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6419,Deployability,install,install,6419,"``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbeha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6545,Deployability,install,install,6545,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6678,Deployability,release,release,6678,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6851,Deployability,release,release,6851,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6888,Deployability,release,release,6888,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7085,Deployability,release,release,7085,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7237,Deployability,release,release,7237,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7313,Deployability,release,release,7313,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:717,Energy Efficiency,reduce,reduce,717,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1042,Integrability,depend,depend,1042,"te a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1667,Modifiability,config,configure,1667,"ry regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3873,Modifiability,sandbox,sandbox,3873,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3892,Modifiability,sandbox,sandbox,3892,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3934,Modifiability,sandbox,sandbox,3934,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3942,Modifiability,sandbox,sandbox,3942,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1424,Performance,perform,performance,1424,"--------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3167,Safety,avoid,avoid,3167,"ts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:197,Testability,test,testing,197,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:577,Testability,benchmark,benchmark,577,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:620,Testability,benchmark,benchmark,620,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:765,Testability,test,tests,765,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:775,Testability,benchmark,benchmarks,775,"=============================; How To Validate a New Release; =============================. .. contents::; :local:; :depth: 1. Introduction; ============. This document contains information about testing the release candidates that; will ultimately be the next LLVM release. For more information on how to; manage the actual release, please refer to :doc:`HowToReleaseLLVM`. Overview of the Release Process; -------------------------------. Once the release process starts, the Release Manager will ask for volunteers,; and it'll be the role of each volunteer to:. * Test and benchmark the previous release. * Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tes",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1605,Testability,test,test-release,1605,"Test and benchmark each release candidate, comparing to the previous release; and candidates. * Identify, reduce and report every regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1817,Testability,test,test,1817,"ry regression found during tests and benchmarks. * Make sure the critical bugs get fixed and merged to the next release candidate. Not all bugs or regressions are show-stoppers and it's a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1967,Testability,test,test-suite,1967,"'s a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1998,Testability,test,tests,1998,"'s a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2064,Testability,test,test-release,2064,"f the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2122,Testability,test,test-asserts,2122,"ression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2478,Testability,test,testing,2478,"cripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The bin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2701,Testability,test,test-asserts,2701,"libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2796,Testability,test,testing,2796,"libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:2809,Testability,benchmark,benchmarking,2809,"libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3539,Testability,test,test-suite,3539,"ith; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3594,Testability,test,testing,3594,"; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bug",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3728,Testability,test,test-suite,3728,"-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's the binary; directory you'll have to pack. * On macOS, you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known fail",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3873,Testability,sandbox,sandbox,3873,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3892,Testability,sandbox,sandbox,3892,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3934,Testability,sandbox,sandbox,3934,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3942,Testability,sandbox,sandbox,3942,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3955,Testability,test,test-suite,3955,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3979,Testability,test,test,3979,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3984,Testability,test,test-suite,3984,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4210,Testability,test,test-suite,4210,"option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4924,Testability,test,testing,4924,"; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:4954,Testability,test,testing,4954,"; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5135,Testability,test,test-release,5135," release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5251,Testability,test,test,5251,"necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5358,Testability,test,test-suite,5358,", which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candid",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5443,Testability,test,test,5443,"rs are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or lin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5916,Testability,test,test,5916,"; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:6148,Testability,test,test-suite,6148,"l. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7047,Testability,test,tests,7047,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7128,Testability,test,test-suite,7128,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7170,Testability,test,test,7170,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:7206,Testability,test,tests,7206,"oing on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes and run the; test-suite the same way. * Compare the results, report all errors on Bugzilla and publish the binary blob; where the release manager can grab it. Once the release manages announces that the latest candidate is the good one,; you have to pack the ``Release`` (no Asserts) install directory on ``Phase3``; and that will be the official binary. * Rename (or link) ``clang+llvm-REL-ARCH-ENV`` to the .install directory. * Tar that into the same name with ``.tar.gz`` extension from outside the; directory. * Make it available for the release manager to download. .. _bug-reporting:. Bug Reporting Process; =====================. .. contents::; :local:. If you found regressions or failures when comparing a release candidate with the; previous release, follow the rules below:. * Critical bugs on compilation should be fixed as soon as possible, possibly; before releasing the binary blobs. * Check-all tests should be fixed before the next release candidate, but can; wait until the test-suite run is finished. * Bugs in the test suite or unimportant check-all tests can be fixed in between; release candidates. * New features or recent big changes, when close to the release, should have; done in a way that it's easy to disable. If they misbehave, prefer disabling; them than releasing an unstable (but untested) binary package.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:3908,Availability,avail,available,3908,":`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In this mode, the remarks and the metadata are serialized separately. The; client is responsible for parsing the metadata first, then use the metadata; to correctly parse the remarks. ``Standalone``. In this mode, the remarks and the metadata are serialized to the same; stream. The metadata will always come before the remarks. The compiler does not support emitting standalone remarks. This mode is; more suited for post-processing tools like linkers, that can merge the; remarks for one whole project. .. _yamlremarks:. YAML remarks; ============. A typical remark serialized to YAML looks like this:. .. code-block:: yaml. --- !<TYPE>; Pass: <pass>; Name: <name>; DebugLoc: { File: <file>, Line: <line>, Column: <column> }; Function: <function>; Hotness: <hotness>; Args:; - <key>: <value>; DebugLoc: { File: <arg-file>, Line: <arg-line>, Column: <arg-column> }. The following entries are mandatory:. * ``<TYPE>``: can be ``Passed``, ``Missed``, ``Analy",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:7369,Availability,error,error,7369,"table (the size itself excluded):; little-endian uint64_t; * a list of null-terminated strings. Optional:. * the absolute file path to the serialized remark diagnostics: a; null-terminated string. When the metadata is serialized separately from the remarks, the file path; should be present and point to the file where the remarks are serialized to. In case the metadata only acts as a header to the remarks, the file path can be; omitted. .. _bitstreamremarks:. LLVM bitstream remarks; ======================. This format is using :doc:`LLVM bitstream <BitCodeFormat>` to serialize remarks; and their associated metadata. A bitstream remark stream can be identified by the magic number ``""RMRK""`` that; is placed at the very beginning. The format for serializing remarks is composed of two different block types:. .. _bitstreamremarksmetablock:. META_BLOCK; ----------. The block providing information about the rest of the content in the stream. Exactly one block is expected. Having multiple metadata blocks is an error. This block can contain the following records:. .. _bitstreamremarksrecordmetacontainerinfo:. ``RECORD_META_CONTAINER_INFO``. The container version and type. Version: u32. Type: u2. .. _bitstreamremarksrecordmetaremarkversion:. ``RECORD_META_REMARK_VERSION``. The version of the remark entries. This can change independently from the; container version. Version: u32. .. _bitstreamremarksrecordmetastrtab:. ``RECORD_META_STRTAB``. The string table used by the remark entries. The format of the string table; is a sequence of strings separated by ``\0``. .. _bitstreamremarksrecordmetaexternalfile:. ``RECORD_META_EXTERNAL_FILE``. The external remark file path that contains the remark blocks associated; with this metadata. This is an absolute path. .. _bitstreamremarksremarkblock:. REMARK_BLOCK; ------------. The block describing a remark entry. 0 or more blocks per file are allowed. Each block will depend on the; :ref:`META_BLOCK <bitstreamremarksmetablock>` in order to b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:368,Deployability,pipeline,pipeline,368,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:2958,Deployability,configurat,configuration,2958," are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:18002,Deployability,pipeline,pipeline,18002,"gh the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple components can set up; their specialized remark streamers that all emit remarks through the same; main streamer.; * Re-using the remark infrastructure in ``lib/Remarks``.; * Using the same file and format for the remark emitters created throughout the; compilation. at the cost of an extra layer of abstraction. .. FIXME: add documentation for llvm-opt-report.; .. FIXME: add documentation for Passes supporting optimization remarks; .. FIXME: add documentation for IR Passes; .. FIXME: add documentation for CodeGen Passes; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:12080,Energy Efficiency,consumption,consumption,12080," emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_STRTAB <bitstreamremarksrecordmetastrtab>`; * :ref:`RECORD_META_EXTERNAL_FILE <bitstreamremarksrecordmetaexternalfile>`. Typically, this is emitted in a section in the object files, allowing; clients to retrieve remarks and their associated metadata directly from; intermediate products. ``SeparateRemarksFile: the remark entries emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`. This container type expects 0 or more :ref:`REMARK_BLOCK <bitstreamremarksremarkblock>`. Typically, this is emitted in a side-file alongside an object file, and is; made to be able to stream to without increasing the memory consumption of; the compiler. This is referenced by the :ref:`RECORD_META_EXTERNAL_FILE; <bitstreamremarksrecordmetaexternalfile>` entry in the; :ref:`SeparateRemarksMeta <bitstreamremarksseparateremarksmeta>` container. When the parser tries to parse a container that contains the metadata for the; separate remarks, it should parse the version and type, then keep the string; table in memory while opening the external file, validating its metadata and; parsing the remark entries. The container versions from the separate container should match in order to; have a well-formed file. ``Standalone: the metadata and the remark entries emitted together``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`; * :ref:`RECORD_META_STRTAB <bitstr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:8279,Integrability,depend,depend,8279, is expected. Having multiple metadata blocks is an error. This block can contain the following records:. .. _bitstreamremarksrecordmetacontainerinfo:. ``RECORD_META_CONTAINER_INFO``. The container version and type. Version: u32. Type: u2. .. _bitstreamremarksrecordmetaremarkversion:. ``RECORD_META_REMARK_VERSION``. The version of the remark entries. This can change independently from the; container version. Version: u32. .. _bitstreamremarksrecordmetastrtab:. ``RECORD_META_STRTAB``. The string table used by the remark entries. The format of the string table; is a sequence of strings separated by ``\0``. .. _bitstreamremarksrecordmetaexternalfile:. ``RECORD_META_EXTERNAL_FILE``. The external remark file path that contains the remark blocks associated; with this metadata. This is an absolute path. .. _bitstreamremarksremarkblock:. REMARK_BLOCK; ------------. The block describing a remark entry. 0 or more blocks per file are allowed. Each block will depend on the; :ref:`META_BLOCK <bitstreamremarksmetablock>` in order to be parsed correctly. This block can contain the following records:. ``RECORD_REMARK_HEADER``. The header of the remark. This contains all the mandatory information about; a remark. +---------------+---------------------------+; | Type | u3 |; +---------------+---------------------------+; | Remark name | VBR6 (string table index) |; +---------------+---------------------------+; | Pass name | VBR6 (string table index) |; +---------------+---------------------------+; | Function name | VBR6 (string table index) |; +---------------+---------------------------+. ``RECORD_REMARK_DEBUG_LOC``. The source location for the corresponding remark. This record is optional. +--------+---------------------------+; | File | VBR7 (string table index) |; +--------+---------------------------+; | Line | u32 |; +--------+---------------------------+; | Column | u32 |; +--------+---------------------------+. ``RECORD_REMARK_HOTNESS``. The hotness of the remark. This reco,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:10826,Integrability,depend,dependencies,10826,"+--------+---------------------------+; | Line | u32 |; +--------+---------------------------+; | Column | u32 |; +--------+---------------------------+. ``RECORD_REMARK_ARG_WITHOUT_DEBUGLOC``. A remark argument with an associated debug location. +--------+---------------------------+; | Key | VBR7 (string table index) |; +--------+---------------------------+; | Value | VBR7 (string table index) |; +--------+---------------------------+. The remark container; --------------------. Bitstream remarks are designed to be used in two different modes:. ``The separate mode``. The separate mode is the mode that is typically used during compilation. It; provides a way to serialize the remark entries to a stream while some; metadata is kept in memory to be emitted in the product of the compilation; (typically, an object file). ``The standalone mode``. The standalone mode is typically stored and used after the distribution of; a program. It contains all the information that allows the parsing of all; the remarks without having any external dependencies. In order to support multiple modes, the format introduces the concept of a; bitstream remark container type. .. _bitstreamremarksseparateremarksmeta:. ``SeparateRemarksMeta: the metadata emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_STRTAB <bitstreamremarksrecordmetastrtab>`; * :ref:`RECORD_META_EXTERNAL_FILE <bitstreamremarksrecordmetaexternalfile>`. Typically, this is emitted in a section in the object files, allowing; clients to retrieve remarks and their associated metadata directly from; intermediate products. ``SeparateRemarksFile: the remark entries emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:16974,Integrability,interface,interface,16974,"aml. .. _remarkssection:. Emitting remark diagnostics in the object file; ==============================================. A section containing metadata on remark diagnostics will be emitted for the; following formats:. * ``yaml-strtab``; * ``bitstream``. This can be overridden by using the flag ``-remarks-section=<bool>``. The section is named:. * ``__LLVM,__remarks`` (MachO). C API; =====. LLVM provides a library that can be used to parse remarks through a shared; library named ``libRemarks``. The typical usage through the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:17240,Integrability,interface,interface,17240,"marks-section=<bool>``. The section is named:. * ``__LLVM,__remarks`` (MachO). C API; =====. LLVM provides a library that can be used to parse remarks through a shared; library named ``libRemarks``. The typical usage through the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple components can set up; their specialized remark streamers that all emit remarks through the same; main streamer.; * Re-using the remark infrastructure in ``lib/Remarks``.; * Using the same file and format for the remark emitters created throughout the; compilation. at the cost of an extra layer of abstr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:2958,Modifiability,config,configuration,2958," are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:3650,Modifiability,plugin,plugin,3650,"the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In this mode, the remarks and the metadata are serialized separately. The; client is responsible for parsing the metadata first, then use the metadata; to correctly parse the remarks. ``Standalone``. In this mode, the remarks and the metadata are serialized to the same; stream. The metadata will always come before the remarks. The compiler does not support emitting standalone remarks. This mode is; more suited for post-processing tools like linkers, that can merge the; remarks for one whole project. .. _yamlremarks:. YAML remarks; ============. A typical remark serialized to YAML looks like this:. .. code-block:: yaml. --- !<TYPE>; Pass: <pass>; Name: <name>; DebugLoc: { File: <file>, Line",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:208,Performance,optimiz,optimization,208,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:231,Performance,perform,performed,231,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:461,Performance,optimiz,optimization,461,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:474,Performance,perform,performed,474,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:633,Performance,optimiz,optimization,633,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:681,Performance,perform,performed,681,"=======; Remarks; =======. .. contents::; :local:. Introduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is oft",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:1034,Performance,optimiz,optimization,1034,"oduction to the LLVM remark diagnostics; ===========================================. LLVM is able to emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:1139,Performance,optimiz,optimization,1139,"emit diagnostics from passes describing whether an optimization; has been performed or missed for a particular reason, which should give more; insight to users about what the compiler did during the compilation pipeline. There are three main remark types:. ``Passed``. Remarks that describe a successful optimization performed by the compiler. :Example:. ::. foo inlined into bar with (cost=always): always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:1518,Performance,optimiz,optimization,1518,"always inline attribute. ``Missed``. Remarks that describe an attempt to an optimization by the compiler that; could not be performed. :Example:. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:1664,Performance,optimiz,optimization,1664,":. ::. foo not inlined into bar because it should never be inlined; (cost=never): noinline function attribute. ``Analysis``. Remarks that describe the result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:1805,Performance,optimiz,optimization,1805,"e result of an analysis, that can bring more; information to the user regarding the generated code. :Example:. ::. 16 stack bytes in function. ::. 10 instructions in function. Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlrem",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:2029,Performance,optimiz,optimization,2029," Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only pas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:2085,Performance,perform,performance,2085," Enabling optimization remarks; =============================. There are two modes that are supported for enabling optimization remarks in; LLVM: through remark diagnostics, or through serialized remarks. Remark diagnostics; ------------------. Optimization remarks can be emitted as diagnostics. These diagnostics will be; propagated to front-ends if desired, or emitted by tools like :doc:`llc; <CommandGuide/llc>` or :doc:`opt <CommandGuide/opt>`. .. option:: -pass-remarks=<regex>. Enables optimization remarks from passes whose name match the given (POSIX); regular expression. .. option:: -pass-remarks-missed=<regex>. Enables missed optimization remarks from passes whose name match the given; (POSIX) regular expression. .. option:: -pass-remarks-analysis=<regex>. Enables optimization analysis remarks from passes whose name match the given; (POSIX) regular expression. Serialized remarks; ------------------. While diagnostics are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only pas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:3199,Performance,optimiz,optimization,3199,"ile that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In this mode, the remarks and the metadata are serialized separately. The; client is responsible for parsing the metadata first, then use the metadata; to correctly parse the remarks. ``Standalone``. In this mode, the remarks and the ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:3308,Performance,optimiz,optimization,3308,"nd it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In this mode, the remarks and the metadata are serialized separately. The; client is responsible for parsing the metadata first, then use the metadata; to correctly parse the remarks. ``Standalone``. In this mode, the remarks and the metadata are serialized to the same; stream. The metadata will always come before the remarks. The compiler does",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:15215,Performance,optimiz,optimization,15215,"=1 abbrevid=4 op0=5 op1=2/>; <Remark version codeid=2 abbrevid=5 op0=30/>; <String table codeid=3 abbrevid=6/> blob data = 'pass\\x00remark\\x00function\\x00path\\x00key\\x00value\\x00argpath\\x00'; </Meta>; <Remark BlockID=9 NumWords=8 BlockCodeSize=4>; <Remark header codeid=5 abbrevid=4 op0=2 op1=1 op2=0 op3=2/>; <Remark debug location codeid=6 abbrevid=5 op0=3 op1=99 op2=55/>; <Remark hotness codeid=7 abbrevid=6 op0=999999999/>; <Argument with debug location codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. opt-viewer; ==========. The ``opt-viewer`` directory contains a collection of tools that visualize and; summarize serialized remarks. The tools only support the ``yaml`` format. .. _optviewerpy:. opt-viewer.py; -------------. Output a HTML page which gives visual feedback on compiler interactions with; your program. :Examples:. ::. $ opt-viewer.py my_yaml_file.opt.yaml. ::. $ opt-viewer.py my_build_dir/. opt-stats.py; ------------. Output statistics about the optimization remarks in the input set. :Example:. ::. $ opt-stats.py my_yaml_file.opt.yaml. Total number of remarks 3. Top 10 remarks by pass:; inline 33%; asm-printer 33%; prologepilog 33%. Top 10 remarks:; asm-printer/InstructionCount 33%; inline/NoDefinition 33%; prologepilog/StackSize 33%. opt-diff.py; -----------. Produce a new YAML file which contains all of the changes in optimizations; between two YAML files. Typically, this tool should be used to do diffs between:. * new compiler + fixed source vs old compiler + fixed source; * fixed compiler + new source vs fixed compiler + old source. This diff file can be displayed using :ref:`opt-viewer.py <optviewerpy>`. :Example:. ::. $ opt-diff.py my_opt_yaml1.opt.yaml my_opt_yaml2.opt.yaml -o my_opt_diff.opt.yaml; $ opt-viewer.py my_opt_diff.opt.yaml. .. _remarkssection:. Emitting remark diagnostics in the object file; ==============================================. A section containing metadata on remark diagnostics will be emitted for the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:15597,Performance,optimiz,optimizations,15597,"op1=99 op2=55/>; <Remark hotness codeid=7 abbrevid=6 op0=999999999/>; <Argument with debug location codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. opt-viewer; ==========. The ``opt-viewer`` directory contains a collection of tools that visualize and; summarize serialized remarks. The tools only support the ``yaml`` format. .. _optviewerpy:. opt-viewer.py; -------------. Output a HTML page which gives visual feedback on compiler interactions with; your program. :Examples:. ::. $ opt-viewer.py my_yaml_file.opt.yaml. ::. $ opt-viewer.py my_build_dir/. opt-stats.py; ------------. Output statistics about the optimization remarks in the input set. :Example:. ::. $ opt-stats.py my_yaml_file.opt.yaml. Total number of remarks 3. Top 10 remarks by pass:; inline 33%; asm-printer 33%; prologepilog 33%. Top 10 remarks:; asm-printer/InstructionCount 33%; inline/NoDefinition 33%; prologepilog/StackSize 33%. opt-diff.py; -----------. Produce a new YAML file which contains all of the changes in optimizations; between two YAML files. Typically, this tool should be used to do diffs between:. * new compiler + fixed source vs old compiler + fixed source; * fixed compiler + new source vs fixed compiler + old source. This diff file can be displayed using :ref:`opt-viewer.py <optviewerpy>`. :Example:. ::. $ opt-diff.py my_opt_yaml1.opt.yaml my_opt_yaml2.opt.yaml -o my_opt_diff.opt.yaml; $ opt-viewer.py my_opt_diff.opt.yaml. .. _remarkssection:. Emitting remark diagnostics in the object file; ==============================================. A section containing metadata on remark diagnostics will be emitted for the; following formats:. * ``yaml-strtab``; * ``bitstream``. This can be overridden by using the flag ``-remarks-section=<bool>``. The section is named:. * ``__LLVM,__remarks`` (MachO). C API; =====. LLVM provides a library that can be used to parse remarks through a shared; library named ``libRemarks``. The typical usage through the C API is like the following:. ..",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:18433,Performance,optimiz,optimization,18433,"gh the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple components can set up; their specialized remark streamers that all emit remarks through the same; main streamer.; * Re-using the remark infrastructure in ``lib/Remarks``.; * Using the same file and format for the remark emitters created throughout the; compilation. at the cost of an extra layer of abstraction. .. FIXME: add documentation for llvm-opt-report.; .. FIXME: add documentation for Passes supporting optimization remarks; .. FIXME: add documentation for IR Passes; .. FIXME: add documentation for CodeGen Passes; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:12507,Security,validat,validating,12507,"lowing; clients to retrieve remarks and their associated metadata directly from; intermediate products. ``SeparateRemarksFile: the remark entries emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`. This container type expects 0 or more :ref:`REMARK_BLOCK <bitstreamremarksremarkblock>`. Typically, this is emitted in a side-file alongside an object file, and is; made to be able to stream to without increasing the memory consumption of; the compiler. This is referenced by the :ref:`RECORD_META_EXTERNAL_FILE; <bitstreamremarksrecordmetaexternalfile>` entry in the; :ref:`SeparateRemarksMeta <bitstreamremarksseparateremarksmeta>` container. When the parser tries to parse a container that contains the metadata for the; separate remarks, it should parse the version and type, then keep the string; table in memory while opening the external file, validating its metadata and; parsing the remark entries. The container versions from the separate container should match in order to; have a well-formed file. ``Standalone: the metadata and the remark entries emitted together``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`; * :ref:`RECORD_META_STRTAB <bitstreamremarksrecordmetastrtab>`. This container type expects 0 or more :ref:`REMARK_BLOCK <bitstreamremarksremarkblock>`. A complete output of :program:`llvm-bcanalyzer` on the different container types:. ``SeparateRemarksMeta``. .. code-block:: none. <BLOCKINFO_BLOCK/>; <Meta BlockID=8 NumWords=13 BlockCodeSize=3>; <Container info codeid=1 abbrevid=4 op0=5 op1=0/>; <String table codeid=3 abbrevid=5/> blo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:15015,Usability,feedback,feedback,15015,"tion codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. ``Standalone``. .. code-block:: none. <BLOCKINFO_BLOCK/>; <Meta BlockID=8 NumWords=15 BlockCodeSize=3>; <Container info codeid=1 abbrevid=4 op0=5 op1=2/>; <Remark version codeid=2 abbrevid=5 op0=30/>; <String table codeid=3 abbrevid=6/> blob data = 'pass\\x00remark\\x00function\\x00path\\x00key\\x00value\\x00argpath\\x00'; </Meta>; <Remark BlockID=9 NumWords=8 BlockCodeSize=4>; <Remark header codeid=5 abbrevid=4 op0=2 op1=1 op2=0 op3=2/>; <Remark debug location codeid=6 abbrevid=5 op0=3 op1=99 op2=55/>; <Remark hotness codeid=7 abbrevid=6 op0=999999999/>; <Argument with debug location codeid=8 abbrevid=7 op0=4 op1=5 op2=6 op3=11 op4=66/>; </Remark>. opt-viewer; ==========. The ``opt-viewer`` directory contains a collection of tools that visualize and; summarize serialized remarks. The tools only support the ``yaml`` format. .. _optviewerpy:. opt-viewer.py; -------------. Output a HTML page which gives visual feedback on compiler interactions with; your program. :Examples:. ::. $ opt-viewer.py my_yaml_file.opt.yaml. ::. $ opt-viewer.py my_build_dir/. opt-stats.py; ------------. Output statistics about the optimization remarks in the input set. :Example:. ::. $ opt-stats.py my_yaml_file.opt.yaml. Total number of remarks 3. Top 10 remarks by pass:; inline 33%; asm-printer 33%; prologepilog 33%. Top 10 remarks:; asm-printer/InstructionCount 33%; inline/NoDefinition 33%; prologepilog/StackSize 33%. opt-diff.py; -----------. Produce a new YAML file which contains all of the changes in optimizations; between two YAML files. Typically, this tool should be used to do diffs between:. * new compiler + fixed source vs old compiler + fixed source; * fixed compiler + new source vs fixed compiler + old source. This diff file can be displayed using :ref:`opt-viewer.py <optviewerpy>`. :Example:. ::. $ opt-diff.py my_opt_yaml1.opt.yaml my_opt_yaml2.opt.yaml -o my_opt_diff.opt.yaml; $ opt-viewer.py my_opt_diff.opt.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Remarks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3079,Availability,avail,available,3079,"t well handled by the local organizers, please include this information in; your email to conduct@llvm.org. All meetup organizers who receive an ; in-person report are also asked to email conduct@llvm.org with the; incident information. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. Guidelines for Reporting Incidents; ==================================. Please email conduct@llvm.org with the following details (if possible):. * Your contact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one intera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:434,Energy Efficiency,reduce,reduce,434,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. =================================; LLVM CoC Incident Reporting Guide; =================================. First of all, please do not feel like you may be a burden to us by reporting; incidents. We consider reports an opportunity for us to act: by knowing about; an incident, we can act on it if appropriate, and reduce continuation of; problematic behavior. If we don't know, we can't learn or take any appropriate; actions. If you are not sure the situation being reported was a :doc:`Code of; Conduct<CodeOfConduct>` violation, we encourage you to still report it. We; would much rather have reports where we decide to take no action, rather than; miss a report of an actual violation. There is no harm in reporting an incident; which is later determined not to be a violation, and knowing about incidents; that are not violations can also help us to improve the Code of Conduct or the; processes surrounding it. Reporting and Contact Information; =================================. * For any incident involving an online platform (e.g., mailing lists, forums, ; irc/discord/slack, etc) we ask that you make any reports by emailing ; conduct@llvm.org. This is received by all members of the CoC Committee. * For LLVM Developers' Meetings, please file a report with the on-site Code ; of Conduct team. Their names and contact details are listed on the event ; webpage. You can also approach any other staff member, who can be ; identified by special badges and often found at the registration desk, ; to help you locate a member of the Code of Conduct team. All incidents ; reported in-person at a LLVM Developers' Meeting will be emailed to the ; Code of Conduct Committee. . * For meetups, please report the incident to the local meetup organizers first; and then email conduct@llvm.org with your report. Each meetup will have a ; contact listed on the associated meetup page.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3025,Integrability,message,messages,3025,"t well handled by the local organizers, please include this information in; your email to conduct@llvm.org. All meetup organizers who receive an ; in-person report are also asked to email conduct@llvm.org with the; incident information. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. Guidelines for Reporting Incidents; ==================================. Please email conduct@llvm.org with the following details (if possible):. * Your contact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one intera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3257,Safety,safe,safety,3257,"cident information. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. Guidelines for Reporting Incidents; ==================================. Please email conduct@llvm.org with the following details (if possible):. * Your contact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4198,Safety,safe,safety,4198,"ng.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4362,Safety,safe,safe,4362,"; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-gui",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3627,Security,confidential,confidential,3627,"ontact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Report",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3874,Security,access,access,3874,"itnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4545,Security,confidential,confidentiality,4545,"our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/lice",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:507,Usability,learn,learn,507,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. =================================; LLVM CoC Incident Reporting Guide; =================================. First of all, please do not feel like you may be a burden to us by reporting; incidents. We consider reports an opportunity for us to act: by knowing about; an incident, we can act on it if appropriate, and reduce continuation of; problematic behavior. If we don't know, we can't learn or take any appropriate; actions. If you are not sure the situation being reported was a :doc:`Code of; Conduct<CodeOfConduct>` violation, we encourage you to still report it. We; would much rather have reports where we decide to take no action, rather than; miss a report of an actual violation. There is no harm in reporting an incident; which is later determined not to be a violation, and knowing about incidents; that are not violations can also help us to improve the Code of Conduct or the; processes surrounding it. Reporting and Contact Information; =================================. * For any incident involving an online platform (e.g., mailing lists, forums, ; irc/discord/slack, etc) we ask that you make any reports by emailing ; conduct@llvm.org. This is received by all members of the CoC Committee. * For LLVM Developers' Meetings, please file a report with the on-site Code ; of Conduct team. Their names and contact details are listed on the event ; webpage. You can also approach any other staff member, who can be ; identified by special badges and often found at the registration desk, ; to help you locate a member of the Code of Conduct team. All incidents ; reported in-person at a LLVM Developers' Meeting will be emailed to the ; Code of Conduct Committee. . * For meetups, please report the incident to the local meetup organizers first; and then email conduct@llvm.org with your report. Each meetup will have a ; contact listed on the associated meetup page.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4885,Usability,guid,guide,4885,"onse Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:5305,Usability,guid,guidelines,5305,"onse Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:5403,Usability,guid,guidelines-for-reporting-incidents,5403,"onse Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2047,Availability,avail,available,2047,"ponse; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5410,Availability,avail,available,5410," the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up With the Reportee:. Following Up With the Reportee; ==============================. When following up with the reportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5979,Deployability,update,updated,5979,"ine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up With the Reportee:. Following Up With the Reportee; ==============================. When following up with the reportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week to respond with the option to request; additional time if needed and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:9738,Deployability,update,updated,9738,"tion. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and projected timeline. . Conflicts of Interest; =====================. Committee members should declare any conflicts of interest as soon as possible; and before any official committee meetings. This can mean being friends with; one of the involved parties, or anything else that may make it harder to remain; neutral. A conflict of interest does not inherently mean the committee member can no; longer participate in the process, as that would make it very hard for the team; to act on reports involving well-known people in the community. However, if a; report concerns a team member or someone they work directly with, they probably; should not take part in the process. The team will decide together on where to; draw this line in individual cases. Where possible, any conversations with; offenders should not be done by people who know them, as it can be very; unpleasant for everyone involved. If a report is received concerning a committee member, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:7194,Energy Efficiency,reduce,reduce,7194,"eportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week to respond with the option to request; additional time if needed and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM Foundation Board of; Directors will help resolve the situation and determine if the resolution can; proceed without a unanimous vote. When deciding on a resolution, the goal is to address the report in an; appropriate way, while also looking to prevent or reduce the risk of continuing; harm in the future. Any action deemed necessary by the committee will be; taken, but below is a list of possible resolutions:. * Taking no further action as the incident was determined not to be a; violation.; * A private verbal warning and/or reprimand from the committee to the; individual(s) involved and request to stop this behavior. This conversation; may happen in person, email, by phone, video chat, or IRC.; * Request that the reportee avoid any interaction with, and physical proximity; to, another person for the remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2394,Safety,safe,safe,2394,". The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:7205,Safety,risk,risk,7205,"eportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week to respond with the option to request; additional time if needed and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM Foundation Board of; Directors will help resolve the situation and determine if the resolution can; proceed without a unanimous vote. When deciding on a resolution, the goal is to address the report in an; appropriate way, while also looking to prevent or reduce the risk of continuing; harm in the future. Any action deemed necessary by the committee will be; taken, but below is a list of possible resolutions:. * Taking no further action as the incident was determined not to be a; violation.; * A private verbal warning and/or reprimand from the committee to the; individual(s) involved and request to stop this behavior. This conversation; may happen in person, email, by phone, video chat, or IRC.; * Request that the reportee avoid any interaction with, and physical proximity; to, another person for the remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:7671,Safety,avoid,avoid,7671,"eeded and subject to approval of the CoC Committee. .. _Resolutions:. Resolutions; ===========. The committee should agree unanimously on a resolution. In the event that the; committee cannot reach a unanimous resolution, the LLVM Foundation Board of; Directors will help resolve the situation and determine if the resolution can; proceed without a unanimous vote. When deciding on a resolution, the goal is to address the report in an; appropriate way, while also looking to prevent or reduce the risk of continuing; harm in the future. Any action deemed necessary by the committee will be; taken, but below is a list of possible resolutions:. * Taking no further action as the incident was determined not to be a; violation.; * A private verbal warning and/or reprimand from the committee to the; individual(s) involved and request to stop this behavior. This conversation; may happen in person, email, by phone, video chat, or IRC.; * Request that the reportee avoid any interaction with, and physical proximity; to, another person for the remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2346,Security,secur,security,2346,"am. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2503,Security,threat,threats,2503,"s is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2787,Security,threat,threats,2787,"n 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:4624,Security,confidential,confidentiality,4624,"on<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11139,Security,confidential,confidential,11139,"e process, as that would make it very hard for the team; to act on reports involving well-known people in the community. However, if a; report concerns a team member or someone they work directly with, they probably; should not take part in the process. The team will decide together on where to; draw this line in individual cases. Where possible, any conversations with; offenders should not be done by people who know them, as it can be very; unpleasant for everyone involved. If a report is received concerning a committee member, that member must not be; involved in the response process. The rest of the committee will meet and; decide on the report without the reported committee member being present, and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11481,Security,access,access,11481,"will decide together on where to; draw this line in individual cases. Where possible, any conversations with; offenders should not be done by people who know them, as it can be very; unpleasant for everyone involved. If a report is received concerning a committee member, that member must not be; involved in the response process. The rest of the committee will meet and; decide on the report without the reported committee member being present, and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11668,Security,access,access,11668,"or everyone involved. If a report is received concerning a committee member, that member must not be; involved in the response process. The rest of the committee will meet and; decide on the report without the reported committee member being present, and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11818,Security,confidential,confidentiality,11818," and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All conten",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:12608,Security,confidential,confidentiality,12608,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3944,Testability,log,logged,3944," be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:244,Usability,guid,guide,244,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ===============; Response Guide; ===============. This is a :doc:`Code of Conduct<CodeOfConduct>` (CoC) incident response guide; used by the Code of Conduct Committee and LLVM event organizers. Code of Conduct Committee; =========================. All responses to Code of Conduct reports will be managed by a Code of Conduct; Committee. . Additional Code of Conduct Response Teams; =========================================. In-person events will have an additional response team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:1578,Usability,guid,guidance,1578,"esponse team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3637,Usability,feedback,feedback,3637,"g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for respondin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3666,Usability,feedback,feedback,3666,"ude talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5040,Usability,guid,guidelines,5040,"blic statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up W",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5671,Usability,feedback,feedback,5671,"egarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up With the Reportee:. Following Up With the Reportee; ==============================. When following up with the reportee, the committee will:. * Explain that an incident was reported that involves the reportee.; * In this explanation, the focus will be on the impact of their behavior, not; their intent.; * Reiterate the Code of Conduct and that their behavior may be deemed; inappropriate.; * Give them the opportunity to state their view of the incident.; * Explain the possible resolutions that may be enforced should the CoC; committee determine there is a breach. The reportee will be given a week t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:8769,Usability,feedback,feedback,8769," remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:8849,Usability,feedback,feedback,8849,"eportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and projected timeline. . Conflicts of Interest; =====================. Committe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:12701,Usability,guid,guide,12701,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:13121,Usability,guid,guidelines,13121,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:13219,Usability,guid,guidelines-for-reporting-incidents,13219,"er is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. These reports will be published on the LLVM website. Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/licenses/by/3.0/. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:11025,Availability,down,download,11025,"st large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/releases/download/draft-20220723-10eea63/riscv-spec.pdf>`__ (see Chapter 25). The mapping from the C/C++ memory model to Ztso has not yet been ratified in any standards document. There are multiple possible mappings, and they are *not* mutually ABI compatible. The mapping LLVM implements is ABI compatible with the default WMO mapping. This mapping may change and there is *explicitly* no ABI stability offered while the extension remains in experimental status. User beware. ``experimental-zimop``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. ``experimental-zcmop``; LLVM implements the `v0.2 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. To use an experimental extension from `clang`, you must add `-menable-experimental-extensions` to the command line, and specify the exact version of the experimental extension you are using. To use an experimental extension with LLVM's internal",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:13494,Availability,down,download,13494,"ly parallels the definition of a `non-standard` extension from Section 1.3 of the Volume I: RISC-V Unprivileged ISA specification. In particular, we expect to eventually accept both `custom` extensions and `non-conforming` extensions. Inclusion of a vendor extension will be considered on a case by case basis. All proposals should be brought to the bi-weekly RISCV sync calls for discussion. For a general idea of the factors likely to be considered, please see the `Clang documentation <https://clang.llvm.org/get_involved.html>`_. It is our intention to follow the naming conventions described in `riscv-non-isa/riscv-toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:13805,Availability,down,download,13805,"All proposals should be brought to the bi-weekly RISCV sync calls for discussion. For a general idea of the factors likely to be considered, please see the `Clang documentation <https://clang.llvm.org/get_involved.html>`_. It is our intention to follow the naming conventions described in `riscv-non-isa/riscv-toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14115,Availability,down,download,14115,toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/downloa,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14430,Availability,down,download,14430,ctions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/release,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14748,Availability,down,download,14748,specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/rel,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15091,Availability,down,download,15091,T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15415,Availability,down,download,15415,mi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/downl,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15737,Availability,down,download,15737,head-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16061,Availability,down,download,16061,"b.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16393,Availability,down,download,16393,"head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16697,Availability,down,download,16697,"ps://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchai",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:17071,Availability,down,download,17071,"/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XCVbitmanip``; LLVM implements `version 1.0.0 of the CORE-V Bit Manipulation custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specificati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:17315,Availability,avail,available,17315,"specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XCVbitmanip``; LLVM implements `version 1.0.0 of the CORE-V Bit Manipulation custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVelw``; LLVM implements `version 1.0.0 of the CORE-V Event load custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:18377,Availability,avail,available,18377,"version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XCVbitmanip``; LLVM implements `version 1.0.0 of the CORE-V Bit Manipulation custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVelw``; LLVM implements `version 1.0.0 of the CORE-V Event load custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmac``; LLVM implements `version 1.0.0 of the CORE-V Multiply-Accumulate (MAC) custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620d",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:18787,Availability,avail,available,18787,tion custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVelw``; LLVM implements `version 1.0.0 of the CORE-V Event load custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmac``; LLVM implements `version 1.0.0 of the CORE-V Multiply-Accumulate (MAC) custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by Core-V. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVsimd``; LLVM implements `version 1.0.0 of the CORE-V SIMD custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by Op,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:19165,Availability,avail,available,19165,thub.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmac``; LLVM implements `version 1.0.0 of the CORE-V Multiply-Accumulate (MAC) custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by Core-V. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVsimd``; LLVM implements `version 1.0.0 of the CORE-V SIMD custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVbi``; LLVM implements `version 1.0.0 of the CORE-V immediate branching custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described i,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:19544,Availability,avail,available,19544,"om/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by Core-V. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVsimd``; LLVM implements `version 1.0.0 of the CORE-V SIMD custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVbi``; LLVM implements `version 1.0.0 of the CORE-V immediate branching custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. Experimental C Intrinsics; =========================. In some cases an extension is non-experimental but the C intrinsics for that; extension are still experimental. To use C intrinsics for such an extension; from `clang`, you must add `-menable-experimental-extensions` to the command; line. T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:20217,Availability,avail,available,20217,"cv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by Core-V. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVsimd``; LLVM implements `version 1.0.0 of the CORE-V SIMD custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVbi``; LLVM implements `version 1.0.0 of the CORE-V immediate branching custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. Experimental C Intrinsics; =========================. In some cases an extension is non-experimental but the C intrinsics for that; extension are still experimental. To use C intrinsics for such an extension; from `clang`, you must add `-menable-experimental-extensions` to the command; line. This currently applies to the following extensions:. * ``Zvbb``; * ``Zvbc``; * ``Zvkb``; * ``Zvkg``; * ``Zvkn``; * ``Zvknc``; * ``Zvkned``; * ``Zvkng``; * ``Zvknha``; * ``Zvknhb``; * ``Zvks``; * ``Zvksc``; * ``Zvksed``; * ``Zvksg``; * ``Zvksh``; * ``Zvkt``; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:664,Deployability,release,releases,664,"=============================; User Guide for RISC-V Target; =============================. .. contents::; :local:. Introduction; ============. The RISC-V target provides code generation for processors implementing; supported variations of the RISC-V specification. It lives in the; ``llvm/lib/Target/RISCV`` directory. Specification Documents; =======================. There have been a number of revisions to the RISC-V specifications. LLVM aims; to implement the most recent ratified version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-sp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:910,Deployability,integrat,integrated,910,"=============================; User Guide for RISC-V Target; =============================. .. contents::; :local:. Introduction; ============. The RISC-V target provides code generation for processors implementing; supported variations of the RISC-V specification. It lives in the; ``llvm/lib/Target/RISCV`` directory. Specification Documents; =======================. There have been a number of revisions to the RISC-V specifications. LLVM aims; to implement the most recent ratified version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-sp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:9309,Deployability,release,releases,9309,"e:. ``zicntr``, ``zicsr``, ``zifencei``, ``zihpm``; Between versions 2.0 and 2.1 of the base I specification, a backwards incompatible change was made to remove selected instructions and CSRs from the base ISA. These instructions were grouped into a set of new extensions, but were no longer required by the base ISA. This change is partially described in ""Preface to Document Version 20190608-Base-Ratified"" from the specification document (the ``zicntr`` and ``zihpm`` bits are not mentioned). LLVM currently implements version 2.1 of the base specification. To maintain compatibility, instructions from these extensions are accepted without being in the ``-march`` string. LLVM also allows the explicit specification of the extensions in an ``-march`` string. .. _riscv-profiles-extensions-note:. ``Za128rs``, ``Za64rs``, ``Zic64b``, ``Ziccamoa``, ``Ziccif``, ``Zicclsm``, ``Ziccrse``; These extensions are defined as part of the `RISC-V Profiles specification <https://github.com/riscv/riscv-profiles/releases/tag/v1.0>`_. They do not introduce any new features themselves, but instead describe existing hardware features. Experimental Extensions; =======================. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:10470,Deployability,release,releases,10470,"============. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/releases/download/draft-20220723-10eea63/riscv-spec.pdf>`__ (see Chapter 25). The mapping from the C/C++ memory model to Ztso has not yet been ratified in any standards document. There are multiple possible mappings, and they are *not* mutually ABI compatible. The mapping LLVM implements is ABI compatible with the default WMO mapping. This mapping may change and there is *explicitly* no ABI stability offered while the extension remains in experime",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:10684,Deployability,release,releases,10684,"d regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/releases/download/draft-20220723-10eea63/riscv-spec.pdf>`__ (see Chapter 25). The mapping from the C/C++ memory model to Ztso has not yet been ratified in any standards document. There are multiple possible mappings, and they are *not* mutually ABI compatible. The mapping LLVM implements is ABI compatible with the default WMO mapping. This mapping may change and there is *explicitly* no ABI stability offered while the extension remains in experimental status. User beware. ``experimental-zimop``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. ``experimental-zcmop``; LLVM implements the `v0.2 proposed spe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:10876,Deployability,release,releases,10876," process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/releases/download/draft-20220723-10eea63/riscv-spec.pdf>`__ (see Chapter 25). The mapping from the C/C++ memory model to Ztso has not yet been ratified in any standards document. There are multiple possible mappings, and they are *not* mutually ABI compatible. The mapping LLVM implements is ABI compatible with the default WMO mapping. This mapping may change and there is *explicitly* no ABI stability offered while the extension remains in experimental status. User beware. ``experimental-zimop``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. ``experimental-zcmop``; LLVM implements the `v0.2 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. To use an experimental extension from `clang`, you must add `-menable-experimental-extens",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:11016,Deployability,release,releases,11016,"st large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/releases/download/draft-20220723-10eea63/riscv-spec.pdf>`__ (see Chapter 25). The mapping from the C/C++ memory model to Ztso has not yet been ratified in any standards document. There are multiple possible mappings, and they are *not* mutually ABI compatible. The mapping LLVM implements is ABI compatible with the default WMO mapping. This mapping may change and there is *explicitly* no ABI stability offered while the extension remains in experimental status. User beware. ``experimental-zimop``; LLVM implements the `v0.1 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. ``experimental-zcmop``; LLVM implements the `v0.2 proposed specification <https://github.com/riscv/riscv-isa-manual/blob/main/src/zimop.adoc>`__. To use an experimental extension from `clang`, you must add `-menable-experimental-extensions` to the command line, and specify the exact version of the experimental extension you are using. To use an experimental extension with LLVM's internal",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:13485,Deployability,release,releases,13485,"ly parallels the definition of a `non-standard` extension from Section 1.3 of the Volume I: RISC-V Unprivileged ISA specification. In particular, we expect to eventually accept both `custom` extensions and `non-conforming` extensions. Inclusion of a vendor extension will be considered on a case by case basis. All proposals should be brought to the bi-weekly RISCV sync calls for discussion. For a general idea of the factors likely to be considered, please see the `Clang documentation <https://clang.llvm.org/get_involved.html>`_. It is our intention to follow the naming conventions described in `riscv-non-isa/riscv-toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:13796,Deployability,release,releases,13796,"All proposals should be brought to the bi-weekly RISCV sync calls for discussion. For a general idea of the factors likely to be considered, please see the `Clang documentation <https://clang.llvm.org/get_involved.html>`_. It is our intention to follow the naming conventions described in `riscv-non-isa/riscv-toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14106,Deployability,release,releases,14106,toolchain-conventions <https://github.com/riscv-non-isa/riscv-toolchain-conventions#conventions-for-vendor-extensions>`_. Exceptions to this naming will need to be strongly motivated. The current vendor extensions supported are:. ``XTHeadBa``; LLVM implements `the THeadBa (address-generation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/downloa,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14421,Deployability,release,releases,14421,ctions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/release,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14739,Deployability,release,releases,14739,specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/rel,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15082,Deployability,release,releases,15082,T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15406,Deployability,release,releases,15406,mi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/downl,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:15728,Deployability,release,releases,15728,head-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16052,Deployability,release,releases,16052,"b.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16384,Deployability,release,releases,16384,"head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implemen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16688,Deployability,release,releases,16688,"ps://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchai",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:17062,Deployability,release,releases,17062,"/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XCVbitmanip``; LLVM implements `version 1.0.0 of the CORE-V Bit Manipulation custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specificati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:910,Integrability,integrat,integrated,910,"=============================; User Guide for RISC-V Target; =============================. .. contents::; :local:. Introduction; ============. The RISC-V target provides code generation for processors implementing; supported variations of the RISC-V specification. It lives in the; ``llvm/lib/Target/RISCV`` directory. Specification Documents; =======================. There have been a number of revisions to the RISC-V specifications. LLVM aims; to implement the most recent ratified version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-sp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16260,Integrability,synchroniz,synchronization,16260,"Mac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:14616,Performance,cache,cache,14616,`XTHeadBb``; LLVM implements `the THeadBb (basic bit-manipulation) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadBs``; LLVM implements `the THeadBs (single-bit operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCondMov``; LLVM implements `the THeadCondMov (conditional move) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadCmo``; LLVM implements `the THeadCmo (cache management operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadFMemIdx``; LLVM implements `the THeadFMemIdx (indexed memory operations for floating point) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTheadMac``; LLVM implements `the XTheadMac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) ve,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:18118,Performance,load,load,18118,"ana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document linked above. These instructions are only available for riscv64 at this time. ``XSfvcp``; LLVM implements `version 1.0.0 of the SiFive Vector Coprocessor Interface (VCIX) Software Specification <https://sifive.cdn.prismic.io/sifive/c3829e36-8552-41f0-a841-79945784241b_vcix-spec-software.pdf>`_ by SiFive. All instructions are prefixed with `sf.vc.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XCVbitmanip``; LLVM implements `version 1.0.0 of the CORE-V Bit Manipulation custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/62bec66b36182215e18c9cf10f723567e23878e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVelw``; LLVM implements `version 1.0.0 of the CORE-V Event load custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmac``; LLVM implements `version 1.0.0 of the CORE-V Multiply-Accumulate (MAC) custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:18895,Performance,load,load,18895,8e9/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVelw``; LLVM implements `version 1.0.0 of the CORE-V Event load custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmac``; LLVM implements `version 1.0.0 of the CORE-V Multiply-Accumulate (MAC) custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.mac` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVmem``; LLVM implements `version 1.0.0 of the CORE-V Post-Increment load and stores custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/master/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCValu``; LLVM implements `version 1.0.0 of the Core-V ALU custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/4f024fe4b15a68b76615b0630c07a6745c620da7/docs/source/instruction_set_extensions.rst>`_ by Core-V. All instructions are prefixed with `cv.` as described in the specification. These instructions are only available for riscv32 at this time. ``XCVsimd``; LLVM implements `version 1.0.0 of the CORE-V SIMD custom instructions specification <https://github.com/openhwgroup/cv32e40p/blob/cv32e40p_v1.3.2/docs/source/instruction_set_extensions.rst>`_ by OpenHW Group. All instructions are prefixed with `cv.` as described in the specification. ``XCVbi``; LLVM implements `version,MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:1528,Safety,avoid,avoid,1528,"fied version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-specified ISA naming strings (e.g. ``-march``). We are actively deciding not to support multiple specification revisions; at this time. We acknowledge a likely future need, but actively defer the; decisions making around handling this until we have a concrete example of; real hardware having shipped and an incompatible change to the; specification made afterwards. Base ISAs; =========. The specification defines five base instruction sets: RV32I, RV32E, RV64I,; RV64E, and RV128I.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:9980,Security,validat,validate,9980," accepted without being in the ``-march`` string. LLVM also allows the explicit specification of the extensions in an ``-march`` string. .. _riscv-profiles-extensions-note:. ``Za128rs``, ``Za64rs``, ``Zic64b``, ``Ziccamoa``, ``Ziccif``, ``Zicclsm``, ``Ziccrse``; These extensions are defined as part of the `RISC-V Profiles specification <https://github.com/riscv/riscv-profiles/releases/tag/v1.0>`_. They do not introduce any new features themselves, but instead describe existing hardware features. Experimental Extensions; =======================. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM im",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:9957,Usability,simpl,simplifying,9957," accepted without being in the ``-march`` string. LLVM also allows the explicit specification of the extensions in an ``-march`` string. .. _riscv-profiles-extensions-note:. ``Za128rs``, ``Za64rs``, ``Zic64b``, ``Ziccamoa``, ``Ziccif``, ``Zicclsm``, ``Ziccrse``; These extensions are defined as part of the `RISC-V Profiles specification <https://github.com/riscv/riscv-profiles/releases/tag/v1.0>`_. They do not introduce any new features themselves, but instead describe existing hardware features. Experimental Extensions; =======================. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM im",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2149,Availability,avail,available,2149,"ll work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3265,Availability,avail,available,3265,"freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:8389,Availability,avail,available,8389,"sed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quaranti",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:9861,Availability,error,errors,9861,"t decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quarantine_size_kb | 0 | The size (in Kb) of per-thread cache use to |; | | | offload the global quarantine. Lower value may |; | | | reduce memory usage but might increase |; | | | contention on the global quarantine. Setting |; | | | *both* this and quarantine_size_kb to zero will |; | | | disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Whether or not we report errors on |; | | | malloc/delete, new/free, new/delete[], etc. |; +---------------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +-----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:10088,Availability,error,errors,10088,"irely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quarantine_size_kb | 0 | The size (in Kb) of per-thread cache use to |; | | | offload the global quarantine. Lower value may |; | | | reduce memory usage but might increase |; | | | contention on the global quarantine. Setting |; | | | *both* this and quarantine_size_kb to zero will |; | | | disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Whether or not we report errors on |; | | | malloc/delete, new/free, new/delete[], etc. |; +---------------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:10728,Availability,failure,failure,10728,"ne entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Whether or not we report errors on |; | | | malloc/delete, new/free, new/delete[], etc. |; +---------------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value disables |; | | | reclaiming). |; +---------------------------------+----------------+-------------------------------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, tr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:11448,Availability,fault,fault,11448,"-------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value disables |; | | | reclaiming). |; +---------------------------------+----------------+-------------------------------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:11586,Availability,fault,fault,11586,"; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value disables |; | | | reclaiming). |; +---------------------------------+----------------+-------------------------------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:11624,Availability,fault,faults,11624,"---------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value disables |; | | | reclaiming). |; +---------------------------------+----------------+-------------------------------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+----",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:12134,Availability,avail,available,12134,"-------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:13457,Availability,error,errors,13457,"-----------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TS",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14580,Availability,error,error,14580,"---------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15080,Availability,error,error,15080,"----------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15845,Availability,error,error,15845,"Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when; deallocating a chunk is not congruent with the one requested when allocating; it. This is likely to be a `compiler issue <https://software.intel.com/en-us/forums/intel-c-compiler/topic/783942>`_,; as was the case with Intel C++ Compiler, or some type confusion on the object; being deall",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:16943,Availability,error,error,16943,"st of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when; deallocating a chunk is not congruent with the one requested when allocating; it. This is likely to be a `compiler issue <https://software.intel.com/en-us/forums/intel-c-compiler/topic/783942>`_,; as was the case with Intel C++ Compiler, or some type confusion on the object; being deallocated;. - ``""RSS limit exhausted""``: the maximum RSS optionally specified has been; exceeded;. Several other error messages relate to parameter checking on the libc allocation; APIs and are fairly straightforward to understand. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1027,Deployability,configurat,configurations,1027,"ned Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4311,Deployability,update,update,4311,"ion type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; release",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5311,Deployability,release,released,5311,"es to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5692,Deployability,configurat,configurations,5692," well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" versi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:10984,Deployability,release,release,10984,"-----------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |; | | | byte pattern on allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | may_return_null | true | Whether or not a non-fatal failure can return a |; | | | NULL pointer (as opposed to terminating). |; +---------------------------------+----------------+-------------------------------------------------+; | release_to_os_interval_ms | 5000 | The minimum interval (in ms) at which a release |; | | | can be attempted (a negative value disables |; | | | reclaiming). |; +---------------------------------+----------------+-------------------------------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:12428,Deployability,release,release,12428,"| | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:13145,Deployability,release,release,13145,"ng ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+----------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1247,Energy Efficiency,efficient,efficient,1247,"oject/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3276,Energy Efficiency,allocate,allocated,3276,"freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4762,Energy Efficiency,reduce,reduced,4762," - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemallo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4812,Energy Efficiency,allocate,allocated,4812,"; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scud",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:8786,Energy Efficiency,reduce,reduce,8786,"tml>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quarantine_size_kb | 0 | The size (in Kb) of per-thread cache use to |; | | | offload the global quarantine. Lower value may |; | | | reduce memory usage but might increase |; | | | contention on the global quarantine. Setting |; | | | *both* this and quarantine_size_kb to zero will |; | | | disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Wheth",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:9503,Energy Efficiency,reduce,reduce,9503,"ption |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quarantine_size_kb | 0 | The size (in Kb) of per-thread cache use to |; | | | offload the global quarantine. Lower value may |; | | | reduce memory usage but might increase |; | | | contention on the global quarantine. Setting |; | | | *both* this and quarantine_size_kb to zero will |; | | | disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Whether or not we report errors on |; | | | malloc/delete, new/free, new/delete[], etc. |; +---------------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +---------------------------------+----------------+-------------------------------------------------+; | pattern_fill_contents | false | Whether or not we fill chunk contents with a |;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15712,Energy Efficiency,allocate,allocated,15712,"ith; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when; deallocating a chunk is not congruent with the one requested when allocating; it. This is likely to be a `compiler issue <https://software.intel.com/en-us/for",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:16286,Energy Efficiency,allocate,allocate,16286,"st of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when; deallocating a chunk is not congruent with the one requested when allocating; it. This is likely to be a `compiler issue <https://software.intel.com/en-us/forums/intel-c-compiler/topic/783942>`_,; as was the case with Intel C++ Compiler, or some type confusion on the object; being deallocated;. - ``""RSS limit exhausted""``: the maximum RSS optionally specified has been; exceeded;. Several other error messages relate to parameter checking on the libc allocation; APIs and are fairly straightforward to understand. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:6066,Integrability,depend,depending,6066,"Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo versio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:12185,Integrability,interface,interface,12185,"-------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force r",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14586,Integrability,message,message,14586,"---------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15086,Integrability,message,messages,15086,"----------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely w",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:16949,Integrability,message,messages,16949,"st of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when; deallocating a chunk is not congruent with the one requested when allocating; it. This is likely to be a `compiler issue <https://software.intel.com/en-us/forums/intel-c-compiler/topic/783942>`_,; as was the case with Intel C++ Compiler, or some type confusion on the object; being deallocated;. - ``""RSS limit exhausted""``: the maximum RSS optionally specified has been; exceeded;. Several other error messages relate to parameter checking on the libc allocation; APIs and are fairly straightforward to understand. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:979,Modifiability,config,configurable,979,"ned Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1027,Modifiability,config,configurations,1027,"ned Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1467,Modifiability,config,configurable,1467,"nce. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1720,Modifiability,config,configurable,1720,"y/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5692,Modifiability,config,configurations,5692," well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" versi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:7094,Modifiability,config,configured,7094,"itional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:7588,Modifiability,variab,variable,7588,"317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+----------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:8082,Modifiability,variab,variable,8082," of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +-----------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:474,Performance,perform,performance,474,"========================; Scudo Hardened Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:924,Performance,perform,performance,924,"========================; Scudo Hardened Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1815,Performance,cache,caches,1815,"llocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potentia",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1945,Performance,cache,caches,1945,"designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2035,Performance,cache,caches,2035,"designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2379,Performance,perform,performance,2379,"plemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4131,Performance,load,loaded,4131,"region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4856,Performance,cache,caches,4856,"; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scud",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5502,Performance,tune,tune,5502,"vided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:9425,Performance,cache,cache,9425,"lowing ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_max_chunk_size | 0 | Size (in bytes) up to which chunks can be |; | | | quarantined. |; +---------------------------------+----------------+-------------------------------------------------+; | thread_local_quarantine_size_kb | 0 | The size (in Kb) of per-thread cache use to |; | | | offload the global quarantine. Lower value may |; | | | reduce memory usage but might increase |; | | | contention on the global quarantine. Setting |; | | | *both* this and quarantine_size_kb to zero will |; | | | disable the quarantine entirely. |; +---------------------------------+----------------+-------------------------------------------------+; | dealloc_type_mismatch | false | Whether or not we report errors on |; | | | malloc/delete, new/free, new/delete[], etc. |; +---------------------------------+----------------+-------------------------------------------------+; | delete_size_mismatch | true | Whether or not we report errors on mismatch |; | | | between sizes of new and delete. |; +---------------------------------+----------------+-------------------------------------------------+; | zero_contents | false | Whether or not we zero chunk contents on |; | | | allocation. |; +--------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:13988,Performance,cache,cached,13988,"mall amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14019,Performance,cache,cache,14019,"mall amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14182,Performance,cache,cached,14182,"M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14213,Performance,cache,cache,14213,"M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15567,Performance,perform,performing,15567,"====. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismatch; check is enabled, a deallocation function called on a chunk has to match the; type of function that was called to allocate it. Security implications of such; a mismatch are not necessarily obvious but situational at best;. - ``""invalid sized delete""``: when the C++14 sized delete operator is used, and; the optional check enabled, this indicates that the size passed when;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2788,Safety,detect,detect,2788,"ry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platfo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2899,Safety,detect,detected,2899," thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3363,Safety,detect,detect,3363,"stly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4355,Safety,avoid,avoid,4355,"ion type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; release",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4596,Safety,predict,predictable,4596,"nk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android ver",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:13479,Safety,detect,detected,13479,"-----------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force release all possible |; | | memory regardless of how long it takes. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_MEMTAG_TUNING | Tunes the allocator's choice of memory tags to make |; | | it more likely that a certain class of memory errors |; | | will be detected. The value argument should be one of |; | | the enumerators of ``scudo_memtag_tuning``. |; +---------------------------+-------------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TS",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14666,Safety,detect,detected,14666,"---------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""in",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:848,Security,secur,security,848,"========================; Scudo Hardened Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:911,Security,secur,security,911,"========================; Scudo Hardened Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2850,Security,checksum,checksummed,2850," thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2929,Security,access,accessed,2929," thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:2980,Security,access,accessed,2980," thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. Allocations Header; ------------------; Every chunk of heap memory returned to an application by the allocator will be; preceded by a header. This has two purposes:. - being to store various information about the chunk, that can be leveraged to; ensure consistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3738,Security,checksum,checksum,3738,"onsistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3871,Security,checksum,checksum,3871,"rupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4027,Security,checksum,checksum,4027,"rupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4464,Security,secur,security,4464,"r unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4737,Security,secur,security,4737," - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemallo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5422,Security,access,accesses,5422,"es to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:6815,Security,sanitiz,sanitizer,6815,"` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.htm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14995,Security,sanitiz,sanitizers,14995,"ry cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15159,Security,checksum,checksum,15159,"es that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5871,Testability,test,tests,5871,"iming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Com",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:2296,Availability,avail,available,2296,"that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing com",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5540,Availability,avail,available,5540,"scussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus; failing this, the nomination will succeed only by a two-thirds supermajority vote of the LLVM Security Group. Accepting membership; -----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:16622,Availability,avail,available,16622,"rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-advisories; .. _Discourse forums: https://discourse.llvm.org; .. _MITRE: https://cve.mitre.org; .. _example nomination is available here: https://reviews.llvm.org/D99232; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:300,Deployability,release,release,300,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:383,Deployability,deploy,deploy,383,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:504,Deployability,release,release,504,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:10429,Deployability,patch,patches,10429,"on-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect the issue’s embargo date, and to not share the information. Disclosure; ----------. Following the process below, the LLVM Security Group decides on embargo date for public disclosure for each Security issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it do",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:12940,Deployability,patch,patches,12940,"nal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13161,Deployability,release,releases,13161,"contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13202,Deployability,release,releases,13202,"contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13228,Deployability,patch,patch,13228,"contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13433,Deployability,patch,patch,13433,"Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15413,Deployability,update,update,15413,"roject considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium iss",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:12280,Energy Efficiency,charge,charge,12280,"orkflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo da",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5996,Modifiability,evolve,evolves,5996,"usted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus; failing this, the nomination will succeed only by a two-thirds supermajority vote of the LLVM Security Group. Accepting membership; --------------------. Before new LLVM Security Group membership is finalized, the successful nominee should accept membership and agree to abide by this security policy, particularly `Privileges and Responsibilities of LLVM Security Group Members`_ below. Keeping Membership Current; --------------------------. * At least every six months, the LLVM Security Group applies the above criteria. The membership list is pruned accordingly.; * A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:16235,Performance,perform,perform,16235,"rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-advisories; .. _Discourse forums: https://discourse.llvm.org; .. _MITRE: https://cve.mitre.org; .. _example nomination is available here: https://reviews.llvm.org/D99232; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1893,Safety,avoid,avoid,1893,"osure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:13698,Safety,avoid,avoid,13698,"mmend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:144,Security,secur,security,144,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:177,Security,secur,security-related,177,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:674,Security,secur,security-sensitive,674,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:744,Security,secur,security,744,"===================; LLVM Security Group; ===================. The LLVM Security Group has the following goals:. 1. Allow LLVM contributors and security researchers to disclose security-related issues affecting the LLVM project to members of the LLVM community.; 2. Organize fixes, code reviews, and release management for said issues.; 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1333,Security,secur,security-issue,1333," 3. Allow distributors time to investigate and deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1366,Security,secur,security,1366," deploy fixes before wide dissemination of vulnerabilities or mitigation shortcomings.; 4. Ensure timely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * An",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1428,Security,secur,security,1428,"imely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3304,Security,secur,security,3304,"be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Gro",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3420,Security,secur,security,3420,"stems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last ye",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3600,Security,secur,security,3600,"* Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3757,Security,secur,security,3757,"driley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3937,Security,secur,security,3937,"ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:4172,Security,secur,security,4172,"------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nomi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:4413,Security,secur,security,4413," + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last year.; - If already in the LLVM Security Group, has actively participated in most membership discussions in the last year.; - If already in the LLVM Security Group, has actively participated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly descr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5645,Security,access,accessible,5645,"icipated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus; failing this, the nomination will succeed only by a two-thirds supermajority vote of the LLVM Security Group. Accepting membership; --------------------. Before new LLVM Security Group membership is finalized, the successful nomine",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:6677,Security,secur,security,6677,"M developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus; failing this, the nomination will succeed only by a two-thirds supermajority vote of the LLVM Security Group. Accepting membership; --------------------. Before new LLVM Security Group membership is finalized, the successful nominee should accept membership and agree to abide by this security policy, particularly `Privileges and Responsibilities of LLVM Security Group Members`_ below. Keeping Membership Current; --------------------------. * At least every six months, the LLVM Security Group applies the above criteria. The membership list is pruned accordingly.; * Any Security Group member can ask that the criteria be applied within the next five business days.; * If a member of the LLVM Security Group does not act in accordance with the letter and spirit of this policy, then their LLVM Security Group membership can be revoked by a majority vote of the members, not including the person under consideration for revocation. After a member calls for a revocation vote, voting will be open for five business days.; * Emergency suspension: an LLVM Security Group member who blatantly disregards the LLVM Security Policy may have their membership temporarily suspended on the request of any two members. In such a case, the requesting members should notify the Se",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:8677,Security,secur,security,8677,"At this point, membership will be temporarily suspended for five business days, pending outcome of the vote for permanent revocation.; * The LLVM Board may remove any member from the LLVM Security Group. Transparency Report; -------------------. Every year, the LLVM Security Group must publish a transparency report. The intent of this report is to keep the community informed by summarizing the disclosures that have been made public in the last year. It shall contain a list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key ex",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:8803,Security,access,access,8803,"e vote for permanent revocation.; * The LLVM Board may remove any member from the LLVM Security Group. Transparency Report; -------------------. Every year, the LLVM Security Group must publish a transparency report. The intent of this report is to keep the community informed by summarizing the disclosures that have been made public in the last year. It shall contain a list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:8817,Security,secur,security,8817,"e vote for permanent revocation.; * The LLVM Board may remove any member from the LLVM Security Group. Transparency Report; -------------------. Every year, the LLVM Security Group must publish a transparency report. The intent of this report is to keep the community informed by summarizing the disclosures that have been made public in the last year. It shall contain a list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:8934,Security,secur,security,8934,"--------. Every year, the LLVM Security Group must publish a transparency report. The intent of this report is to keep the community informed by summarizing the disclosures that have been made public in the last year. It shall contain a list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect the issue’s embargo date, and to not share the information. Disclosure; ----------. Following the process below, the LLVM Security Grou",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:8986,Security,confidential,confidential,8986,"--------. Every year, the LLVM Security Group must publish a transparency report. The intent of this report is to keep the community informed by summarizing the disclosures that have been made public in the last year. It shall contain a list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect the issue’s embargo date, and to not share the information. Disclosure; ----------. Following the process below, the LLVM Security Grou",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/Security.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst
