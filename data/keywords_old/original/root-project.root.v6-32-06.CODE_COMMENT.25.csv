id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block; /// with the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:495,Availability,Avail,AvailableVals,495,"/// Construct SSA form, materializing a value that is live in the; /// middle of the specified block.; ///; /// \c GetValueInMiddleOfBlock is the same as \c GetValueAtEndOfBlock except; /// in one important case: if there is a definition of the rewritten value; /// after the 'use' in BB. Consider code like this:; ///; /// \code; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; /// \endcode; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:539,Modifiability,rewrite,rewriter,539,"/// Construct SSA form, materializing a value that is live in the; /// middle of the specified block.; ///; /// \c GetValueInMiddleOfBlock is the same as \c GetValueAtEndOfBlock except; /// in one important case: if there is a definition of the rewritten value; /// after the 'use' in BB. Consider code like this:; ///; /// \code; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; /// \endcode; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a use of the symbolic value.; ///; /// This handles PHI nodes, which use their value in the corresponding; /// predecessor. Note that this will not work if the use is supposed to be; /// rewritten to a value defined in the same block as the use, but above it.; /// Any 'AddAvailableValue's added for the use's block will be considered to; /// be below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:248,Availability,avail,available,248,"/// Rewrite debug value intrinsics to conform to a new SSA form.; ///; /// This will scout out all the debug value instrinsics associated with; /// the instruction. Anything outside of its block will have its; /// value set to the new SSA value if available, and undef if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite debug value intrinsics to conform to a new SSA form.; ///; /// This will scout out all the debug value instrinsics associated with; /// the instruction. Anything outside of its block will have its; /// value set to the new SSA value if available, and undef if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:26,Modifiability,Rewrite,RewriteUse,26,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:113,Modifiability,rewrite,rewrite,113,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:47,Performance,load,loads,47,"/// Helper class for promoting a collection of loads and stores into SSA; /// Form using the SSAUpdater.; ///; /// This handles complexities that SSAUpdater doesn't, such as multiple loads; /// and stores in one block.; ///; /// Clients of this class are expected to subclass this and implement the; /// virtual methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:183,Performance,load,loads,183,"/// Helper class for promoting a collection of loads and stores into SSA; /// Form using the SSAUpdater.; ///; /// This handles complexities that SSAUpdater doesn't, such as multiple loads; /// and stores in one block.; ///; /// Clients of this class are expected to subclass this and implement the; /// virtual methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:58,Performance,load,loads,58,"/// This does the promotion.; ///; /// Insts is a list of loads and stores to promote, and Name is the basename; /// for the PHIs to insert. After this is complete, the loads and stores are; /// removed from the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:169,Performance,load,loads,169,"/// This does the promotion.; ///; /// Insts is a list of loads and stores to promote, and Name is the basename; /// for the PHIs to insert. After this is complete, the loads and stores are; /// removed from the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:178,Energy Efficiency,efficient,efficient,178,/// Return true if the specified instruction is in the Inst list.; ///; /// The Insts list is the one passed into the constructor. Clients should; /// implement this with a more efficient version if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,Availability,avail,available,77,/// This hook is invoked after all the stores are found and inserted as; /// available values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,Performance,load,load,77,/// Clients can choose to implement this to get notified right before; /// a load is RAUW'd another value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:14,Deployability,update,update,14,/// Called to update debug info associated with the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:57,Performance,load,loads,57,/// Return false if a sub-class wants to keep one of the loads/stores; /// after the SSA construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:43,Deployability,Update,Update,43,"//===- SSAUpdaterBulk.h - Unstructured SSA Update Tool ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the SSAUpdaterBulk class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:259,Deployability,update,update,259,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:418,Deployability,update,updates,418,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:185,Modifiability,rewrite,rewrite,185,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:284,Modifiability,Rewrite,RewriteAllUses,284,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:14,Modifiability,variab,variable,14,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:34,Modifiability,rewrite,rewriter,34,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:139,Modifiability,variab,variable,139,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block with; /// the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:57,Deployability,update,updated,57,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:98,Modifiability,Rewrite,RewriteAllUses,98,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:30,Deployability,update,updates,30,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:101,Deployability,update,update,101,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:4,Performance,Perform,Perform,4,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:30,Deployability,Update,Updater,30,"//===- SSAUpdaterImpl.h - SSA Updater Implementation ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a template that implements the core algorithm for the; // SSAUpdater and MachineSSAUpdater.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:116,Performance,cache,cached,116,/// BBInfo - Per-basic block information used internally by SSAUpdaterImpl.; /// The predecessors of each block are cached here since pred_iterator is; /// slow and we need to iterate over the blocks at least a few times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:26,Availability,avail,available,26,// Block that defines the available value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:31,Availability,Avail,AvailableVals,31,"/// GetValue - Check to see if AvailableVals has an entry for the specified; /// BB and if so, return it. If not, construct SSA form by first; /// calculating the required placement of PHIs and then inserting new PHIs; /// where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:171,Usability,Simpl,Simple,171,"/// FindDominators - Calculate the dominator tree for the subset of the CFG; /// corresponding to the basic blocks on the BlockList. This uses the; /// algorithm from: ""A Simple, Fast Dominance Algorithm"" by Cooper, Harvey; /// and Kennedy, published in Software--Practice and Experience, 2001,; /// 4:1-10. Because the CFG subset does not include any edges leading into; /// blocks that define the value, the results are not the usual dominator; /// tree. The CFG subset has a single pseudo-entry node with edges to a set; /// of root nodes for blocks that define the value. The dominators for this; /// subset CFG are not the standard dominators but they are adequate for; /// placing PHIs within the subset CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:60,Availability,Avail,AvailableVal,60,/// Check all predecessors and if all of them have the same AvailableVal use; /// it as value for block represented by Info. Return true if singluar value; /// is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:250,Availability,avail,available,250,"/// FindAvailableVal - If this block requires a PHI, first check if an; /// existing PHI matches the PHI placement and reaching definitions computed; /// earlier, and if not, create a new PHI. Visit all the block's; /// predecessors to calculate the available value for each one and fill in; /// the incoming values for a new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:14,Availability,avail,available,14,// Record the available value to speed up subsequent uses of this; // SSAUpdater for the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:17,Usability,clear,clear,17,// Match failed: clear all the PHITag values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:98,Availability,Avail,AvailableVals,98,"/// RecordMatchingPHIs - For each PHI node that matches, record it in both; /// the BBMap and the AvailableVals mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:459,Modifiability,Rewrite,Rewriter,459,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:493,Modifiability,Rewrite,Rewriter,493,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:522,Modifiability,rewrite,rewrite,522,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:776,Modifiability,Rewrite,Rewriter,776,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:1075,Performance,perform,performing,1075,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:799,Security,expose,exposed,799,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:1403,Security,sanitiz,sanitizers,1403,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:36,Modifiability,rewrite,rewrite,36,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:96,Modifiability,rewrite,rewrite,96,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:189,Modifiability,rewrite,rewrite,189,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:212,Modifiability,Rewrite,RewriteMapParser,212,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:377,Modifiability,rewrite,rewrite,377,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:404,Modifiability,variab,variable,404,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:628,Modifiability,rewrite,rewrite,628,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:26,Modifiability,rewrite,rewrites,26,/// function - descriptor rewrites a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:11,Modifiability,variab,variable,11,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:33,Modifiability,rewrite,rewrites,33,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:51,Modifiability,variab,variable,51,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:29,Modifiability,rewrite,rewrites,29,/// named alias - descriptor rewrites a global alias,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:516,Performance,perform,perform,516,"//===- llvm/Transforms/Utils/UnrollLoop.h - Unrolling utilities -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:77,Deployability,configurat,configuration,77,"/// Returns loop size estimation for unrolled loop, given the unrolling; /// configuration specified by UP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:77,Modifiability,config,configuration,77,"/// Returns loop size estimation for unrolled loop, given the unrolling; /// configuration specified by UP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:414,Integrability,interface,interface,414,"//===- ValueMapper.h - Remapping for constants and metadata -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MapValue interface which is used by various parts of; // the Transforms/Utils library to implement cloning and linking facilities.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:173,Safety,abort,aborts,173,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:287,Testability,assert,assertions,287,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:396,Testability,assert,assertion,396,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:1732,Deployability,Update,Update,1732,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:683,Energy Efficiency,schedul,schedule,683,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:751,Energy Efficiency,schedul,scheduleMapGlobalInitializer,751,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:792,Energy Efficiency,schedul,scheduleMapAppendingVariable,792,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:833,Energy Efficiency,schedul,scheduleMapGlobalAlias,833,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:868,Energy Efficiency,schedul,scheduleMapGlobalIFunc,868,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:903,Energy Efficiency,schedul,scheduleRemapFunction,903,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:1190,Energy Efficiency,schedul,schedule,1190,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:114,Energy Efficiency,schedul,schedule,114,/// Register an alternate mapping context.; ///; /// Returns a MappingContextID that can be used with the various schedule*(); /// API to switch in a different value map on-the-fly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:490,Integrability,depend,depending,490,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:587,Integrability,wrap,wrapping,587,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:705,Integrability,depend,depending,705,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:323,Integrability,wrap,wrap,323,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:510,Integrability,depend,depending,510,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:717,Integrability,wrap,wrapping,717,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:37,Safety,safe,safety,37,/// Version of MapMetadata with type safety for MDNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:235,Testability,assert,assert,235,"/// Convert the instruction operands from referencing the current values into; /// those specified by VM.; ///; /// If \a RF_IgnoreMissingLocals is set and an operand can't be found via \a; /// MapValue(), use the old value. Otherwise assert that this doesn't happen.; ///; /// Note that \a MapValue() only returns \c nullptr for SSA values missing from; /// \c VM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:34,Safety,safe,safety,34,/// Version of MapValue with type safety for Constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:407,Integrability,rout,routines,407,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:768,Integrability,rout,routines,768,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:838,Integrability,rout,routines,838,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:910,Integrability,rout,routines,910,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:462,Performance,perform,perform,462,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:654,Performance,load,load,654,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:722,Performance,load,load,722,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:55,Performance,load,load,55,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:152,Performance,load,loaded,152,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:170,Performance,Load,LoadedTy,170,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:198,Performance,load,load,198,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:208,Availability,failure,failure,208,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:207,Availability,failure,failure,207,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:100,Performance,load,load,100,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:219,Availability,failure,failure,219,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:38,Performance,Load,Load,38,"/// If analyzeLoadFromClobberingStore/Load returned an offset, this function; /// can be used to actually perform the extraction of the bits from the store.; /// It inserts instructions to do so at InsertPt, and returns the extracted; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:106,Performance,perform,perform,106,"/// If analyzeLoadFromClobberingStore/Load returned an offset, this function; /// can be used to actually perform the extraction of the bits from the store.; /// It inserts instructions to do so at InsertPt, and returns the extracted; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:50,Performance,perform,performs,50,"// This is the same as getValueForLoad, except it performs no insertion.; // It only allows constant inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:103,Performance,perform,perform,103,"/// If analyzeLoadFromClobberingMemInst returned an offset, this function can be; /// used to actually perform the extraction of the bits from the memory; /// intrinsic. It inserts instructions to do so at InsertPt, and returns the; /// extracted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:55,Performance,perform,performs,55,"// This is the same as getStoreValueForLoad, except it performs no insertion.; // It returns nullptr if it cannot produce a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:7,Performance,Load,LoadStoreVectorizer,7,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:37,Performance,Load,Load,37,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:49,Performance,Load,LoadStoreVectorizer,49,/// Create a legacy pass manager instance of the LoadStoreVectorizer pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:996,Availability,failure,failure,996,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:1017,Integrability,message,message,1017,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:624,Modifiability,Extend,Extending,624,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:318,Deployability,update,update,318,"/// Utility class for getting and setting loop vectorizer hints in the form; /// of loop metadata.; /// This class keeps a number of loop annotations locally (as member variables); /// and can, upon request, write them back as metadata on the loop. It will; /// initially scan the loop for existing metadata, and will update the local; /// values based on information in the loop.; /// We cannot write all values to metadata, as the mere presence of some info,; /// for example 'force', means a decision has been made. So, we need to be; /// careful NOT to add them if the user hasn't specifically asked so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:169,Modifiability,variab,variables,169,"/// Utility class for getting and setting loop vectorizer hints in the form; /// of loop metadata.; /// This class keeps a number of loop annotations locally (as member variables); /// and can, upon request, write them back as metadata on the loop. It will; /// initially scan the loop for existing metadata, and will update the local; /// values based on information in the loop.; /// We cannot write all values to metadata, as the mere presence of some info,; /// for example 'force', means a decision has been made. So, we need to be; /// careful NOT to add them if the user hasn't specifically asked so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:31,Security,validat,validation,31,/// Hint - associates name and validation with the hint value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:46,Performance,scalab,scalable,46,/// Says whether we should use fixed width or scalable vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:25,Safety,unsafe,unsafe,25,/// True if there is any unsafe math in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:32,Performance,scalab,scalable,32,/// Disables vectorization with scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Performance,scalab,scalable,26,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:82,Performance,scalab,scalable,82,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:170,Performance,scalab,scalable,170,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:20,Performance,scalab,scalable,20,/// \return true if scalable vectorization has been explicitly disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:303,Availability,error,error,303,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:190,Safety,unsafe,unsafe,190,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:3,Safety,Avoid,Avoid,3,"// Avoid FP vectorization if the target is unsure about proper support.; // This may be related to the SIMD unit in the target not handling; // IEEE 754 FP ops properly, or bad single-to-double promotions.; // Otherwise, a sequence of vectorized loops, even without reduction,; // could lead to different end results on the destination vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:50,Deployability,update,update,50,/// Find hints specified in the loop metadata and update local values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:573,Availability,avail,availability,573,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:613,Modifiability,variab,variable,613,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:825,Modifiability,variab,variable,825,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:862,Modifiability,variab,variables,862,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:361,Security,access,accesses,361,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:34,Modifiability,variab,variables,34,/// InductionList saves induction variables and maps them to the; /// induction descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:77,Availability,mask,masking,77,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:127,Availability,mask,masking,127,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:110,Performance,load,loads,110,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:34,Modifiability,variab,variable,34,/// Returns the primary induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Modifiability,variab,variables,26,/// Returns the reduction variables found in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Modifiability,variab,variables,26,/// Returns the induction variables found in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:52,Modifiability,variab,variable,52,/// Returns True if V is a Phi node of an induction variable in this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Availability,redundant,redundant,107,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Safety,redund,redundant,107,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,Availability,redundant,redundant,120,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:56,Modifiability,variab,variable,56,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,Safety,redund,redundant,120,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:38,Modifiability,variab,variable,38,/// Returns True if PN is a reduction variable in this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:125,Modifiability,variab,variable,125,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:183,Modifiability,variab,variable,183,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:251,Performance,load,load,251,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:29,Performance,load,load,29,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:49,Security,access,accesses,49,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:80,Availability,mask,mask,80,/// Returns true if vector representation of the instruction \p I; /// requires mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:104,Availability,avail,available,104,/// Returns true if there is at least one function call in the loop which; /// has a vectorized variant available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,Performance,perform,performs,64,/// Return true if we can vectorize this outer loop. The method performs; /// specific checks for outer loop vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:133,Availability,mask,masking,133,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:279,Availability,Mask,MaskedOp,279,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:377,Availability,mask,masked,377,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Performance,load,loads,107,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:150,Safety,Safe,SafePtrs,150,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Deployability,Update,Updates,4,/// Updates the vectorization state by adding \p Phi to the inductions list.; /// This can set \p Phi as the main induction of the loop if \p Phi is a; /// better choice for the main induction than the existing one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:6,Integrability,wrap,wrapper,6,/// A wrapper around ScalarEvolution used to add runtime SCEV checks.; /// Applies dynamic knowledge to simplify SCEV expressions in the context; /// of existing SCEV assumptions. The analysis will also add a minimal set; /// of new predicates if this is required to enable vectorization and; /// unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:104,Usability,simpl,simplify,104,/// A wrapper around ScalarEvolution used to add runtime SCEV checks.; /// Applies dynamic knowledge to simplify SCEV expressions in the context; /// of existing SCEV assumptions. The analysis will also add a minimal set; /// of new predicates if this is required to enable vectorization and; /// unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:67,Modifiability,variab,variable,67,// --- vectorization state --- //; /// Holds the primary induction variable. This is the counter of the; /// loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:24,Modifiability,variab,variables,24,/// Holds the reduction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:31,Modifiability,variab,variables,31,/// Holds all of the induction variables that we found in the loop.; /// Notice that inductions don't need to start at zero and that induction; /// variables can be pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:148,Modifiability,variab,variables,148,/// Holds all of the induction variables that we found in the loop.; /// Notice that inductions don't need to start at zero and that induction; /// variables can be pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,Availability,redundant,redundant,126,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:48,Deployability,update,update,48,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:83,Modifiability,variab,variables,83,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,Safety,redund,redundant,126,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:42,Modifiability,variab,variables,42,/// Allowed outside users. This holds the variables that can be accessed from; /// outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,Security,access,accessed,64,/// Allowed outside users. This holds the variables that can be accessed from; /// outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:19,Performance,cache,cache,19,/// The assumption cache analysis is used to compute the minimum type size in; /// which a reduction can be computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:92,Availability,mask,masked,92,/// While vectorizing these instructions we have to generate a; /// call to the appropriate masked intrinsic or drop them in case of; /// conditional assumes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:58,Performance,optimiz,optimizations,58,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:46,Usability,guid,guided,46,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:1944,Modifiability,variab,variable,1944,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:2065,Modifiability,Variab,Variable,2065,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:1088,Performance,perform,performs,1088,"f the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:2195,Security,access,access,2195,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:126,Performance,cache,caches,126,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:50,Usability,simpl,simplification,50,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:195,Usability,simpl,simplifications,195,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:28,Availability,failure,failure,28,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:112,Performance,optimiz,optimization,112,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:27,Integrability,message,message,27,"/// Reports an informative message: print \p Msg for debugging purposes as well; /// as an optimization remark. Uses either \p I as location of the remark, or; /// otherwise \p TheLoop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:91,Performance,optimiz,optimization,91,"/// Reports an informative message: print \p Msg for debugging purposes as well; /// as an optimization remark. Uses either \p I as location of the remark, or; /// otherwise \p TheLoop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:643,Performance,perform,performs,643,"//===- SLPVectorizer.h ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:433,Safety,detect,detects,433,"//===- SLPVectorizer.h ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:195,Energy Efficiency,reduce,reduce,195,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:278,Energy Efficiency,reduce,reduce,278,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:231,Security,access,access,231,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:337,Energy Efficiency,reduce,reduced,337,"/// Try to find horizontal reduction or otherwise, collect instructions; /// for postponed vectorization attempts.; /// \a P if not null designates phi node the reduction is fed into; /// (with reduction operators \a Root or one of its operands, in a basic block; /// \a BB).; /// \returns true if a horizontal reduction was matched and reduced.; /// \returns false if \a V is null or not an instruction,; /// or a horizontal reduction was not matched or not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:32,Performance,Optimiz,Optimize,32,"//===-------- VectorCombine.h - Optimize partial vector operations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:393,Performance,optimiz,optimizes,393,"//===-------- VectorCombine.h - Optimize partial vector operations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:4,Performance,Optimiz,Optimize,4,/// Optimize scalar/vector interactions in IR using target cost models.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:18,Performance,perform,perform,18,"/// If true, only perform beneficial early IR transforms. Do not introduce new; /// vector operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:20,Deployability,install,installation,20,/// Get Windows SDK installation directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:29,Modifiability,variab,variables,29,// Check various environment variables to try and find a toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:37,Deployability,install,installs,37,"// Query the Setup Config server for installs, then pick the newest version; // and find its default VC toolchain. If `VCToolsVersion` is specified, that; // version is preferred over the latest version.; //; // This is the preferred way to discover new Visual Studios, as they're no; // longer listed in the registry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:19,Modifiability,Config,Config,19,"// Query the Setup Config server for installs, then pick the newest version; // and find its default VC toolchain. If `VCToolsVersion` is specified, that; // version is preferred over the latest version.; //; // This is the preferred way to discover new Visual Studios, as they're no; // longer listed in the registry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:42,Deployability,install,installs,42,"// Look in the registry for Visual Studio installs, and use that to get; // a toolchain path. VS2017 and newer don't get added to the registry.; // So if we find something here, we know that it's an older version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:333,Energy Efficiency,charge,charge,333,"// <copyright file=""Program.cpp"" company=""Microsoft Corporation"">; // Copyright (C) Microsoft Corporation. All rights reserved.; // Licensed under the MIT license.; // </copyright>; // <license>; // The MIT License (MIT); //; // Copyright (C) Microsoft Corporation. All rights reserved.; //; // Permission is hereby granted, free of charge, to any person obtaining; // a copy of this software and associated documentation files (the ""Software""),; // to deal in the Software without restriction, including without limitation the; // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; // sell copies of the Software, and to permit persons to whom the Software is; // furnished to do so, subject to the following conditions:; //; // The above copyright notice and this permission notice shall be included in; // all copies or substantial portions of the Software.; //; // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; // SOFTWARE.; // </license>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:1241,Integrability,CONTRACT,CONTRACT,1241,"// <copyright file=""Program.cpp"" company=""Microsoft Corporation"">; // Copyright (C) Microsoft Corporation. All rights reserved.; // Licensed under the MIT license.; // </copyright>; // <license>; // The MIT License (MIT); //; // Copyright (C) Microsoft Corporation. All rights reserved.; //; // Permission is hereby granted, free of charge, to any person obtaining; // a copy of this software and associated documentation files (the ""Software""),; // to deal in the Software without restriction, including without limitation the; // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; // sell copies of the Software, and to permit persons to whom the Software is; // furnished to do so, subject to the following conditions:; //; // The above copyright notice and this permission notice shall be included in; // all copies or substantial portions of the Software.; //; // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; // SOFTWARE.; // </license>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:32,Deployability,install,installation,32,/// <summary>; /// The instance installation path exists.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:22,Availability,reboot,reboot,22,/// <summary>; /// No reboot is required for the instance.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:54,Deployability,install,install,54,/// <summary>; /// The instance represents a complete install.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:11,Integrability,interface,interface,11,// Forward interface declarations; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:3,Integrability,Interface,Interface,3,// Interface definitions; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:248,Availability,failure,failure,248,"/// <summary>; /// Gets the instance identifier (should match the name of the parent instance; /// directory).; /// </summary>; /// <param name=""pbstrInstanceId"">The instance identifier.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:287,Availability,failure,failure,287,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:57,Deployability,install,installation,57,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:90,Deployability,install,installed,90,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:182,Deployability,install,installation,182,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:215,Deployability,install,installed,215,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:371,Availability,failure,failure,371,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:47,Deployability,install,installation,47,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:216,Deployability,install,installation,216,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:247,Availability,failure,failure,247,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:40,Deployability,install,installation,40,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:147,Deployability,install,installation,147,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:260,Availability,failure,failure,260,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:51,Deployability,install,installed,51,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:171,Deployability,install,installed,171,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:341,Availability,failure,failure,341,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:64,Deployability,install,installed,64,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:252,Deployability,install,installed,252,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:322,Availability,failure,failure,322,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:55,Deployability,install,installed,55,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:228,Deployability,install,installed,228,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:487,Availability,failure,failure,487,"/// <summary>; /// Resolves the optional relative path to the root path of the instance.; /// </summary>; /// <param name=""pwszRelativePath"">A relative path within the instance to; /// resolve, or NULL to get the root path.</param>; /// <param name=""pbstrAbsolutePath"">The full path to the optional relative; /// path within the instance. If the relative path is NULL, the root path will; /// always terminate in a backslash.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:181,Availability,failure,failure,181,"/// <summary>; /// Gets the state of the instance.; /// </summary>; /// <param name=""pState"">The state of the instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:258,Availability,failure,failure,258,"/// <summary>; /// Gets an array of package references registered to the instance.; /// </summary>; /// <param name=""ppsaPackages"">Pointer to an array of <see; /// cref=""ISetupPackageReference""/>.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// packages property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:387,Availability,failure,failure,387,"/// <summary>; /// Gets a pointer to the <see cref=""ISetupPackageReference""/> that represents; /// the registered product.; /// </summary>; /// <param name=""ppPackage"">Pointer to an instance of <see; /// cref=""ISetupPackageReference""/>. This may be NULL if <see; /// cref=""GetState""/> does not return <see cref=""eComplete""/>.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// packages property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:73,Availability,avail,available,73,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:190,Availability,avail,available,190,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:262,Availability,failure,failure,262,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:35,Deployability,install,installed,35,"/// <summary>; /// A enumerator of installed <see cref=""ISetupInstance""/> objects.; /// </summary>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:680,Energy Efficiency,allocate,allocated,680,"/// <summary>; /// Retrieves the next set of product instances in the enumeration sequence.; /// </summary>; /// <param name=""celt"">The number of product instances to retrieve.</param>; /// <param name=""rgelt"">A pointer to an array of <see; /// cref=""ISetupInstance""/>.</param>; /// <param name=""pceltFetched"">A pointer to the number of product instances; /// retrieved. If celt is 1 this parameter may be NULL.</param>; /// <returns>S_OK if the number of elements were fetched, S_FALSE if nothing; /// was fetched (at end of enumeration), E_INVALIDARG if celt is greater than; /// 1 and pceltFetched is NULL, or E_OUTOFMEMORY if an <see; /// cref=""ISetupInstance""/> could not be allocated.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:297,Integrability,interface,interface,297,"/// <summary>; /// Creates a new enumeration object in the same state as the current; /// enumeration object: the new object points to the same place in the; /// enumeration sequence.; /// </summary>; /// <param name=""ppenum"">A pointer to a pointer to a new <see; /// cref=""IEnumSetupInstances""/> interface. If the method fails, this; /// parameter is undefined.</param>; /// <returns>S_OK if a clone was returned; otherwise, E_OUTOFMEMORY.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:248,Availability,failure,failure,248,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:62,Deployability,install,installed,62,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:153,Deployability,install,installed,153,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:211,Availability,failure,failure,211,"/// <summary>; /// Enumerates all product instances.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of all product; /// instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:192,Availability,failure,failure,192,"/// <summary>; /// Gets the general package identifier.; /// </summary>; /// <param name=""pbstrId"">The general package identifier.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:189,Availability,failure,failure,189,"/// <summary>; /// Gets the version of the package.; /// </summary>; /// <param name=""pbstrVersion"">The version of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:231,Availability,failure,failure,231,"/// <summary>; /// Gets the target process architecture of the package.; /// </summary>; /// <param name=""pbstrChip"">The target process architecture of the; /// package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:229,Availability,failure,failure,229,"/// <summary>; /// Gets the language and optional region identifier.; /// </summary>; /// <param name=""pbstrLanguage"">The language and optional region; /// identifier.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:198,Availability,failure,failure,198,"/// <summary>; /// Gets the build branch of the package.; /// </summary>; /// <param name=""pbstrBranch"">The build branch of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:180,Availability,failure,failure,180,"/// <summary>; /// Gets the type of the package.; /// </summary>; /// <param name=""pbstrType"">The type of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:251,Availability,failure,failure,251,"/// <summary>; /// Gets the unique identifier consisting of all defined tokens.; /// </summary>; /// <param name=""pbstrUniqueId"">The unique identifier consisting of all; /// defined tokens.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_UNEXPECTED if no Id was defined (required).</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:96,Integrability,interface,interface,96,"/// <summary>; /// Helper functions.; /// </summary>; /// <remarks>; /// You can query for this interface from the <see cref=""SetupConfiguration""/>; /// class.; /// </remarks>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:391,Availability,failure,failure,391,"/// <summary>; /// Parses a dotted quad version string into a 64-bit unsigned integer.; /// </summary>; /// <param name=""pwszVersion"">The dotted quad version string to parse, e.g.; /// 1.2.3.4.</param>; /// <param name=""pullVersion"">A 64-bit unsigned integer representing the; /// version. You can compare this to other versions.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:660,Availability,failure,failure,660,"/// <summary>; /// Parses a dotted quad version string into a 64-bit unsigned integer.; /// </summary>; /// <param name=""pwszVersionRange"">The string containing 1 or 2 dotted quad; /// version strings to parse, e.g. [1.0,) that means 1.0.0.0 or newer.</param>; /// <param name=""pullMinVersion"">A 64-bit unsigned integer representing the; /// minimum version, which may be 0. You can compare this to other; /// versions.</param>; /// <param name=""pullMaxVersion"">A 64-bit unsigned integer representing the; /// maximum version, which may be MAXULONGLONG. You can compare this to other; /// versions.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:470,Availability,failure,failure,470,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:146,Deployability,install,installed,146,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:316,Deployability,install,installed,316,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h:567,Security,access,access,567,"//===-- WindowsManifestMerger.h ---------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This file provides a utility for merging Microsoft .manifest files. These; // files are xml documents which contain meta-information about applications,; // such as whether or not admin access is required, system compatibility,; // versions, etc. Part of the linking process of an executable may require; // merging several of these .manifest files using a tree-merge following; // specific rules. Unfortunately, these rules are not documented well; // anywhere. However, a careful investigation of the behavior of the original; // Microsoft Manifest Tool (mt.exe) revealed the rules of this merge. As the; // saying goes, code is the best documentation, so please look below if you are; // interested in the exact merging requirements.; //; // Ref:; // https://msdn.microsoft.com/en-us/library/windows/desktop/aa374191(v=vs.85).aspx; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h:434,Availability,avail,available,434,"//===-- ResourceScriptToken.h -----------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This declares the .rc script tokens.; // The list of available tokens is located at ResourceScriptTokenList.h.; //; // Ref: msdn.microsoft.com/en-us/library/windows/desktop/aa380599(v=vs.85).aspx; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h:302,Safety,safe,safe,302,// A definition of a single resource script token. Each token has its kind; // (declared in ResourceScriptTokenList) and holds a value - a reference; // representation of the token.; // RCToken does not claim ownership on its value. A memory buffer containing; // the token value should be stored in a safe place and cannot be freed; // nor reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h:30,Usability,clear,clear,30,"/// The flush() function will clear out the current state of the visitor, to; /// allow for explicitly flushing a block's records to the currently; /// recognized thread and process combination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h:475,Energy Efficiency,consumption,consumption,475,"//===- BlockPrinter.h - FDR Block Pretty Printer -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the RecordVisitor which formats a block of records for; // easier human consumption.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h:511,Testability,log,log,511,"//===- BlockVerifier.h - FDR Block Verifier -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the RecordVisitor which verifies a sequence of records; // associated with a block, following the FDR mode log format's specifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h:64,Availability,error,error,64,"// Transitions the current record to the new record, records an error on; // invalid transitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:34,Testability,Log,Log,34,"//===- FDRLogBuilder.h - XRay FDR Log Building Utility --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:8,Testability,Log,LogBuilder,8,/// The LogBuilder class allows for creating ad-hoc collections of records; /// through the `add<...>(...)` function. An example use of this API is in; /// crafting arbitrary sequences of records:; ///; /// auto Records = LogBuilder(); /// .add<BufferExtents>(256); /// .add<NewBufferRecord>(1); /// .consume();; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:222,Testability,Log,LogBuilder,222,/// The LogBuilder class allows for creating ad-hoc collections of records; /// through the `add<...>(...)` function. An example use of this API is in; /// crafting arbitrary sequences of records:; ///; /// auto Records = LogBuilder(); /// .add<BufferExtents>(256); /// .add<NewBufferRecord>(1); /// .consume();; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h:5,Deployability,Pipeline,PipelineConsumer,5,"// A PipelineConsumer applies a set of visitors to every consumed Record, in the; // order by which the visitors are added to the pipeline in the order of; // appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h:130,Deployability,pipeline,pipeline,130,"// A PipelineConsumer applies a set of visitors to every consumed Record, in the; // order by which the visitors are added to the pipeline in the order of; // appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:54,Availability,Error,Error,54,/// All producer implementations must yield either an Error or a non-nullptr; /// unique_ptr<Record>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:87,Testability,log,log,87,"// Helper function which gets the next record by speculatively reading through; // the log, finding a buffer extents record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:45,Performance,load,loading,45,/// This producer encapsulates the logic for loading a File-backed; /// RecordProducer hidden behind a DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:35,Testability,log,logic,35,/// This producer encapsulates the logic for loading a File-backed; /// RecordProducer hidden behind a DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h:155,Testability,log,log,155,// What follows are specific Metadata record types which encapsulate the; // information associated with specific metadata record types in an FDR mode; // log.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h:42,Testability,Log,Log,42,"//===- FDRTraceExpander.h - XRay FDR Mode Log Expander --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // We define an FDR record visitor which can re-constitute XRayRecord instances; // from a sequence of FDR mode records in arrival order into a collection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:383,Testability,Test,Test,383,"//===- FDRTraceWriter.h - XRay FDR Trace Writer -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Test a utility that can write out XRay FDR Mode formatted trace files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:353,Security,validat,validation,353,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:92,Testability,log,log,92,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:129,Testability,test,testing,129,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:421,Performance,load,load,421,"//===- FileHeaderReader.h - XRay Trace File Header Reading Function -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions that can load an XRay log header from various; // sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:434,Testability,log,log,434,"//===- FileHeaderReader.h - XRay Trace File Header Reading Function -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions that can load an XRay log header from various; // sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:29,Performance,load,loading,29,/// Convenience function for loading the file header given a data extractor at a; /// specified offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:733,Availability,avail,available,733,"/// A Graph object represents a Directed Graph and is used in XRay to compute; /// and store function call graphs and associated statistical information.; ///; /// The graph takes in four template parameters, these are:; /// - VertexAttribute, this is a structure which is stored for each vertex.; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each edge; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each variable; /// - VI, this is a type over which DenseMapInfo is defined and is the type; /// used look up strings, available as VertexIdentifier.; /// - If the built in DenseMapInfo is not defined, provide a specialization; /// class type here.; ///; /// Graph is CopyConstructible, CopyAssignable, MoveConstructible and; /// MoveAssignable but is not EqualityComparible or LessThanComparible.; ///; /// Usage Example Graph with weighted edges and vertices:; /// Graph<int, int, int> G;; ///; /// G[1] = 0;; /// G[2] = 2;; /// G[{1,2}] = 1;; /// G[{2,1}] = -1;; /// for(const auto &v : G.vertices()){; /// // Do something with the vertices in the graph;; /// }; /// for(const auto &e : G.edges()){; /// // Do something with the edges in the graph;; /// }; ///; /// Usage Example with StrRef keys.; /// Graph<int, double, StrRef> StrG;; /// char va[] = ""Vertex A"";; /// char vaa[] = ""Vertex A"";; /// char vb[] = ""Vertex B""; // Vertices are referenced by String Refs.; /// G[va] = 0;; /// G[vb] = 1;; /// G[{va, vb}] = 1.0;; /// cout() << G[vaa] << "" "" << G[{vaa, vb}]; //prints ""0 1.0"".; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:620,Modifiability,variab,variable,620,"/// A Graph object represents a Directed Graph and is used in XRay to compute; /// and store function call graphs and associated statistical information.; ///; /// The graph takes in four template parameters, these are:; /// - VertexAttribute, this is a structure which is stored for each vertex.; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each edge; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each variable; /// - VI, this is a type over which DenseMapInfo is defined and is the type; /// used look up strings, available as VertexIdentifier.; /// - If the built in DenseMapInfo is not defined, provide a specialization; /// class type here.; ///; /// Graph is CopyConstructible, CopyAssignable, MoveConstructible and; /// MoveAssignable but is not EqualityComparible or LessThanComparible.; ///; /// Usage Example Graph with weighted edges and vertices:; /// Graph<int, int, int> G;; ///; /// G[1] = 0;; /// G[2] = 2;; /// G[{1,2}] = 1;; /// G[{2,1}] = -1;; /// for(const auto &v : G.vertices()){; /// // Do something with the vertices in the graph;; /// }; /// for(const auto &e : G.edges()){; /// // Do something with the edges in the graph;; /// }; ///; /// Usage Example with StrRef keys.; /// Graph<int, double, StrRef> StrG;; /// char va[] = ""Vertex A"";; /// char vaa[] = ""Vertex A"";; /// char vb[] = ""Vertex B""; // Vertices are referenced by String Refs.; /// G[va] = 0;; /// G[vb] = 1;; /// G[{va, vb}] = 1.0;; /// cout() << G[vaa] << "" "" << G[{vaa, vb}]; //prints ""0 1.0"".; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Energy Efficiency,adapt,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Integrability,adapter,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Modifiability,adapt,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:185,Performance,perform,performed,185,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:94,Security,access,access,94,/// Returns a view object allowing iteration over the vertices of the graph.; /// also allows access to the size of the vertex set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:91,Security,access,access,91,/// Returns a view object allowing iteration over the edges of the graph.; /// also allows access to the size of the edge set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:47,Availability,error,error,47,"/// Looks up a vertex with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:46,Availability,error,error,46,"/// Looks up an edge with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:161,Deployability,update,update,161,"/// Inserts an edge into the graph with Identifier Val.first, and; /// Attribute Val.second. If the key is already in the map, it returns false; /// and doesn't update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:161,Deployability,update,update,161,"/// Inserts an edge into the graph with Identifier Val.first, and; /// Attribute Val.second. If the key is already in the map, it returns false; /// and doesn't update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:395,Integrability,interface,interface,395,"//===- InstrumentationMap.h - XRay Instrumentation Map ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the interface for extracting the instrumentation map from an; // XRay-instrumented binary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:4,Performance,Load,Loads,4,/// Loads the instrumentation map from |Filename|. This auto-deduces the type of; /// the instrumentation map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:163,Integrability,interface,interface,163,"/// The InstrumentationMap represents the computed function id's and indicated; /// function addresses from an object file (or a YAML file). This provides an; /// interface to just the mapping between the function id, and the function; /// address.; ///; /// We also provide raw access to the actual instrumentation map entries we find; /// associated with a particular object file.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:279,Security,access,access,279,"/// The InstrumentationMap represents the computed function id's and indicated; /// function addresses from an object file (or a YAML file). This provides an; /// interface to just the mapping between the function id, and the function; /// address.; ///; /// We also provide raw access to the actual instrumentation map entries we find; /// associated with a particular object file.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:19,Security,access,accessor,19,/// Provides a raw accessor to the unordered map of function addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:22,Security,access,access,22,/// Provide read-only access to the entries of the instrumentation map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:431,Performance,latency,latency,431,"//===- Profile.h - XRay Profile Abstraction -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:123,Availability,error,errors,123,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:228,Availability,Error,Error,228,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:34,Performance,load,load,34,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:149,Performance,load,loading,149,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:96,Availability,error,error,96,/// Provides a sequence of function IDs from a previously interned PathID.; ///; /// Returns an error if |P| had not been interned before into the Profile.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:81,Availability,error,error,81,/// Appends a fully-formed Block instance into the Profile.; ///; /// Returns an error condition in the following cases:; ///; /// - The PathData component of the Block is empty; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:714,Availability,error,error,714,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:57,Performance,load,loaded,57,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:391,Performance,load,loaded,391,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:453,Performance,load,loadTraceFile,453,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:284,Security,access,accessor,284,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:79,Testability,log,log,79,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:144,Testability,log,logic,144,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:473,Testability,log,log,473,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:27,Performance,load,loaded,27,/// Provides access to the loaded XRay trace file header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:13,Security,access,access,13,/// Provides access to the loaded XRay trace file header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,Performance,load,load,34,/// This function will attempt to load XRay trace records from the provided; /// |Filename|.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,Performance,load,load,34,/// This function will attempt to load XRay trace records from the provided; /// DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:435,Testability,log,log,435,"//===- XRayRecord.h - XRay Trace Record -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file replicates the record definition for XRay log entries. This should; // follow the evolution of the log record versions supported in the compiler-rt; // xray project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:492,Testability,log,log,492,"//===- XRayRecord.h - XRay Trace Record -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file replicates the record definition for XRay log entries. This should; // follow the evolution of the log record versions supported in the compiler-rt; // xray project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:141,Availability,avail,available,141,/// XRay traces all have a header providing some top-matter information useful; /// to help tools determine how to interpret the information available in the; /// trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:21,Integrability,depend,depending,21,// This is different depending on the type of xray record. The naive format; // stores a Wallclock timespec. FDR logging stores the size of a thread; // buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:113,Testability,log,logging,113,// This is different depending on the type of xray record. The naive format; // stores a Wallclock timespec. FDR logging stores the size of a thread; // buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:170,Performance,load,loader,170,/// Determines the supported types of records that could be seen in XRay traces.; /// This may or may not correspond to actual record types in the raw trace (as; /// the loader implementation may synthesize this information in the process of; /// of loading).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:250,Performance,load,loading,250,/// Determines the supported types of records that could be seen in XRay traces.; /// This may or may not correspond to actual record types in the raw trace (as; /// the loader implementation may synthesize this information in the process of; /// of loading).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:171,Testability,log,logical,171,"/// An XRayRecord is the denormalized view of data associated in a trace. These; /// records may not correspond to actual entries in the raw traces, but they are; /// the logical representation of records in a higher-level event log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:229,Testability,log,log,229,"/// An XRayRecord is the denormalized view of data associated in a trace. These; /// records may not correspond to actual entries in the raw traces, but they are; /// the logical representation of records in a higher-level event log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:52,Testability,log,log,52,/// Get the full 8 bytes of the TSC when we get the log record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h:437,Testability,log,log,437,"//===- YAMLXRayRecord.h - XRay Record YAML Support Definitions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Types and traits specialisations for YAML I/O of XRay log entries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:47,Integrability,Interface,Interface,47,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:676,Integrability,interface,interface,676,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:37,Safety,abort,abort,37,/* verifier will print to stderr and abort() */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:49,Integrability,Interface,Interface,49,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:678,Integrability,interface,interface,678,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:268,Availability,error,error,268,"/**; * @defgroup LLVMCBitReader Bit Reader; * @ingroup LLVMC; *; * @{; */; /* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. This is deprecated. Use LLVMParseBitcode2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:274,Integrability,message,message,274,"/**; * @defgroup LLVMCBitReader Bit Reader; * @ingroup LLVMC; *; * @{; */; /* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. This is deprecated. Use LLVMParseBitcode2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:193,Availability,error,error,193,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:199,Integrability,message,message,199,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:103,Performance,perform,performs,103,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:110,Performance,perform,performs,110,"/** Reads a module from the given memory buffer, returning via the OutMP; * parameter a module provider which performs lazy deserialization.; *; * Returns 0 on success.; *; * Takes ownership of \p MemBuf if (and only if) the module was read; * successfully. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:49,Integrability,Interface,Interface,49,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:679,Integrability,interface,interface,679,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:92,Deployability,Release,Released,92,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:35,Integrability,Interface,Interface,35,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:362,Integrability,interface,interface,362,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:536,Safety,avoid,avoid,536,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:204,Availability,down,down,204,"// The stack size is MAX_DEPTH + 1 because we do lazy merging. For example,; // with 7 chunks, we have 3 entries in the stack. Adding an 8th chunk; // requires a 4th entry, rather than merging everything down to 1, because we; // don't know whether more input is coming. This is different from how the; // reference implementation does things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:42,Integrability,Interface,Interface,42,"/*===-- llvm-c/Comdat.h - Module Comdat C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to COMDAT. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Comdat.h - Module Comdat C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to COMDAT. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:25,Performance,perform,performed,25,///< No deduplication is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:39,Integrability,Interface,Interface,39,"/*===-- llvm-c/Core.h - Core Library C Interface ------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMCore.a, which implements *|; |* the LLVM intermediate representation. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Core.h - Core Library C Interface ------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMCore.a, which implements *|; |* the LLVM intermediate representation. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:33,Integrability,interface,interface,33,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:240,Integrability,interface,interface,240,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:512,Integrability,interface,interface,512,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:668,Integrability,depend,depend,668,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:723,Safety,safe,safe,723,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:69,Security,expose,exposes,69,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:3,Testability,Log,Logical,3,/* Logical Operators */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:5,Performance,Scalab,Scalable,5,/**< Scalable SIMD vector type */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:20,Security,access,accessible,20,/**< Function to be accessible from DLL. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:7,Performance,load,load,7,/**< A load or store which is not atomic */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Performance,load,loads,109,/**< Acquire provides a barrier of the sort; necessary to acquire a lock to access other; memory with normal loads and stores. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:76,Security,access,access,76,/**< Acquire provides a barrier of the sort; necessary to acquire a lock to access other; memory with normal loads and stores. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:5,Deployability,Release,Release,5,"/**< Release is similar to Acquire, but with; a barrier of the sort necessary to release; a lock. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:81,Deployability,release,release,81,"/**< Release is similar to Acquire, but with; a barrier of the sort necessary to release; a lock. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:37,Deployability,Release,Release,37,/**< provides both an Acquire and a; Release barrier (for fences and; operations which both read and write; memory). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Deployability,Release,Release,47,"/**< provides Acquire semantics; for loads and Release; semantics for stores.; Additionally, it guarantees; that a total ordering exists; between all; SequentiallyConsistent; operations. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:37,Performance,load,loads,37,"/**< provides Acquire semantics; for loads and Release; semantics for stores.; Additionally, it guarantees; that a total ordering exists; between all; SequentiallyConsistent; operations. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:16,Availability,error,error,16,"/**; * Emits an error if two values disagree, otherwise the resulting value is; * that of the operands.; *; * @see Module::ModFlagBehavior::Error; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:140,Availability,Error,Error,140,"/**; * Emits an error if two values disagree, otherwise the resulting value is; * that of the operands.; *; * @see Module::ModFlagBehavior::Error; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:421,Availability,error,error,421,"/**; * Adds a requirement that another module flag be present and have a; * specified value after linking is performed. The value must be a metadata; * pair, where the first element of the pair is the ID of the module flag; * to be restricted, and the second element of the pair is the value the; * module flag should be restricted to. This behavior can be used to; * restrict the allowable results (via triggering of an error) of linking; * IDs with the **Override** behavior.; *; * @see Module::ModFlagBehavior::Require; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Performance,perform,performed,109,"/**; * Adds a requirement that another module flag be present and have a; * specified value after linking is performed. The value must be a metadata; * pair, where the first element of the pair is the ID of the module flag; * to be restricted, and the second element of the pair is the value the; * module flag should be restricted to. This behavior can be used to; * restrict the allowable results (via triggering of an error) of linking; * IDs with the **Override** behavior.; *; * @see Module::ModFlagBehavior::Require; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:160,Availability,error,error,160,"/**; * Uses the specified value, regardless of the behavior or value of the; * other module. If both modules specify **Override**, but the values; * differ, an error will be emitted.; *; * @see Module::ModFlagBehavior::Override; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,Performance,optimiz,optimizations,46,/**; * Flags to indicate what fast-math-style optimizations are allowed; * on operations.; *; * See https://llvm.org/docs/LangRef.html#fast-math-flags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:60,Modifiability,variab,variables,60,/**; * @}; */; /** Deallocate and destroy all ManagedStatic variables.; @see llvm::llvm_shutdown; @see ManagedStatic */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:118,Deployability,patch,patch,118,"/*===-- Version query -----------------------------------------------------===*/; /**; * Return the major, minor, and patch version of LLVM; *; * The version components are returned via the function's three output; * parameters or skipped if a NULL pointer was supplied.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:8,Availability,Error,Error,8,/*===-- Error handling ----------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:235,Safety,safe,safe,235,"/**; * @defgroup LLVMCCoreContext Contexts; *; * Contexts are execution states for the core LLVM IR system.; *; * Most types are tied to a context instance. Multiple contexts can; * exist simultaneously. A single context is not thread safe. However,; * different contexts can execute on different threads simultaneously.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:124,Availability,avail,available,124,"/**; * Set whether the given context discards all value names.; *; * If true, only the names of GlobalValue objects will be available in the IR.; * This can be used to save memory and runtime, especially in release mode.; *; * @see LLVMContext::setDiscardValueNames(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:207,Deployability,release,release,207,"/**; * Set whether the given context discards all value names.; *; * If true, only the names of GlobalValue objects will be available in the IR.; * This can be used to save memory and runtime, especially in release mode.; *; * @see LLVMContext::setDiscardValueNames(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:253,Availability,avail,available,253,"/**; * Return an unique id given the name of a enum attribute,; * or 0 if no attribute by that name exists.; *; * See http://llvm.org/docs/LangRef.html#parameter-attributes; * and http://llvm.org/docs/LangRef.html#function-attributes; * for the list of available attributes.; *; * NB: Attribute names and/or id are subject to change without; * going through the C API deprecation cycle.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:57,Availability,Error,ErrorMessage,57,"/**; * Print a representation of a module to a file. The ErrorMessage needs to be; * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.; *; * @see Module::print(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:242,Availability,alive,alive,242,"/**; * @}; */; /**; * @defgroup LLVMCCoreType Types; *; * Types represent the type of a value.; *; * Types are associated with a context instance. The context internally; * deduplicates types so there is only 1 instance of a specific type; * alive at a time. In other words, a unique type is shared among all; * consumers within a context.; *; * A Type in the C API corresponds to llvm::Type.; *; * Types have the following hierarchy:; *; * types:; * integer type; * real type; * function type; * sequence types:; * array type; * pointer type; * vector type; * void type; * label type; * opaque type; *; * @{; */; /**; * Obtain the enumerated type of a Type instance.; *; * @see llvm::Type:getTypeID(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:99,Energy Efficiency,allocate,allocated,99,"/**; * Obtain the types of a function's parameters.; *; * The Dest parameter should point to a pre-allocated array of; * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the; * first LLVMCountParamTypes() entries in the array will be populated; * with LLVMTypeRef instances.; *; * @param FunctionTy The function type to operate on.; * @param Dest Memory address of an array to be filled with result.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:94,Energy Efficiency,allocate,allocated,94,"/**; * Get the elements within a structure.; *; * The function is passed the address of a pre-allocated array of; * LLVMTypeRef at least LLVMCountStructElementTypes() long. After; * invocation, this array will be populated with the structure's; * elements. The objects in the destination array will have a lifetime; * of the structure type itself, which is the lifetime of the context it; * is contained in.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:67,Performance,scalab,scalable,67,/**; * Create a vector type that contains a defined type and has a scalable; * number of elements.; *; * The created type will exist in the context thats its element type; * exists in.; *; * @see llvm::ScalableVectorType::get(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:202,Performance,Scalab,ScalableVectorType,202,/**; * Create a vector type that contains a defined type and has a scalable; * number of elements.; *; * The created type will exist in the context thats its element type; * exists in.; *; * @see llvm::ScalableVectorType::get(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:28,Performance,scalab,scalable,28,/**; * Obtain the (possibly scalable) number of elements in a vector type.; *; * This only works on types that represent vectors (fixed or scalable).; *; * @see llvm::VectorType::getNumElements(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:139,Performance,scalab,scalable,139,/**; * Obtain the (possibly scalable) number of elements in a vector type.; *; * This only works on types that represent vectors (fixed or scalable).; *; * @see llvm::VectorType::getNumElements(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:343,Availability,avail,available,343,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:559,Availability,avail,available,559,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:287,Integrability,Depend,Depending,287,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:182,Availability,avail,available,182,"/**; * @defgroup LLVMCCoreValueGeneral General APIs; *; * Functions in this section work on all LLVMValueRef instances,; * regardless of their sub-type. They correspond to functions available; * on llvm::Value.; *; * @{; */; /**; * Obtain the type of a value.; *; * @see llvm::Value::getType(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:148,Availability,avail,available,148,/**; * Obtain the next use of a value.; *; * This effectively advances the iterator. It returns NULL if you are on; * the final use and no more are available.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:766,Modifiability,extend,extend,766,"/**; * @defgroup LLVMCCoreValueConstantScalar Scalar constants; *; * Functions in this group model LLVMValueRef instances that correspond; * to constants referring to scalar types.; *; * For integer types, the LLVMTypeRef parameter should correspond to a; * llvm::IntegerType instance and the returned LLVMValueRef will; * correspond to a llvm::ConstantInt.; *; * For floating point types, the LLVMTypeRef returned corresponds to a; * llvm::ConstantFP.; *; * @{; */; /**; * Obtain a constant value for an integer type.; *; * The returned value corresponds to a llvm::ConstantInt.; *; * @see llvm::ConstantInt::get(); *; * @param IntTy Integer type to obtain value of.; * @param N The value the returned instance should refer to.; * @param SignExtend Whether to sign extend the produced value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:125,Availability,avail,available,125,"/**; * Obtain a constant value for an integer parsed from a string.; *; * A similar API, LLVMConstIntOfStringAndSize is also available. If the; * string's length is available, it is preferred to call that function; * instead.; *; * @see llvm::ConstantInt::get(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:165,Availability,avail,available,165,"/**; * Obtain a constant value for an integer parsed from a string.; *; * A similar API, LLVMConstIntOfStringAndSize is also available. If the; * string's length is available, it is preferred to call that function; * instead.; *; * @see llvm::ConstantInt::get(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:132,Availability,avail,available,132,"/**; * Obtain a constant for a floating point value parsed from a string.; *; * A similar API, LLVMConstRealOfStringAndSize is also available. It; * should be used if the input string's length is known.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:23,Modifiability,extend,extended,23,/**; * Obtain the zero extended value for an integer constant value.; *; * @see llvm::ConstantInt::getZExtValue(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:23,Modifiability,extend,extended,23,/**; * Obtain the sign extended value for an integer constant value.; *; * @see llvm::ConstantInt::getSExtValue(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:149,Modifiability,variab,variables,149,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:160,Performance,load,load,160,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:301,Performance,Load,LoadInst,301,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:104,Performance,Load,LoadInst,104,/**; * Set the preferred alignment of the value.; * @see llvm::AllocaInst::setAlignment(); * @see llvm::LoadInst::setAlignment(); * @see llvm::StoreInst::setAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::setAlignment(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:88,Usability,clear,clearMetadata,88,/**; * Removes all metadata attachments from this value.; *; * @see llvm::GlobalObject::clearMetadata(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:75,Modifiability,Variab,Variables,75,/**; * @}; */; /**; * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables; *; * This group contains functions that operate on global variable values.; *; * @see llvm::GlobalVariable; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:144,Modifiability,variab,variable,144,/**; * @}; */; /**; * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables; *; * This group contains functions that operate on global variable values.; *; * @see llvm::GlobalVariable; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:20,Integrability,depend,dependent,20,/**; * Add a target-dependent attribute to a function; * @see llvm::AttrBuilder::addAttribute(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:79,Energy Efficiency,allocate,allocated,79,/**; * Obtain the parameters in a function.; *; * The takes a pointer to a pre-allocated array of LLVMValueRef that is; * at least LLVMCountParams() long. This array will be filled with; * LLVMValueRef instances which correspond to the parameters the; * function receives. Each LLVMValueRef corresponds to a llvm::Argument; * instance.; *; * @see llvm::Function::arg_begin(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:139,Integrability,wrap,wrapped,139,/**; * Obtain the next parameter to a function.; *; * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is; * actually a wrapped iterator) and obtains the next parameter from the; * underlying iterator.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:156,Availability,alive,alive,156,/**; * Remove a global indirect function from its parent module.; *; * This unlinks the global indirect function from its containing module but; * keeps it alive.; *; * @see llvm::GlobalIFunc::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:145,Energy Efficiency,allocate,allocated,145,/**; * Obtain all of the basic blocks in a function.; *; * This operates on a function value. The BasicBlocks parameter is a; * pointer to a pre-allocated array of LLVMBasicBlockRef of at least; * LLVMCountBasicBlocks() in length. This array is populated with; * LLVMBasicBlockRef instances.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:137,Availability,alive,alive,137,/**; * Remove a basic block from a function.; *; * This deletes the basic block from its containing function but keep; * the basic block alive.; *; * @see llvm::BasicBlock::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:123,Availability,alive,alive,123,/**; * Remove an instruction.; *; * The instruction specified is removed from its containing building; * block but is kept alive.; *; * @see llvm::Instruction::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:62,Integrability,rout,routine,62,/**; * Determine whether an instruction is a terminator. This routine is named to; * be compatible with historical functions that did this by querying the; * underlying C++ type.; *; * @see llvm::Instruction::isTerminator(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:7,Deployability,Update,Update,7,/**; * Update the specified successor to point at the provided block.; *; * @see llvm::Instruction::setSuccessor; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:223,Energy Efficiency,allocate,allocated,223,/**; * @}; */; /**; * @defgroup LLVMCCoreValueInstructionAlloca Allocas; *; * Functions in this group only apply to instructions that map to; * llvm::AllocaInst instances.; *; * @{; */; /**; * Obtain the type that is being allocated by the alloca instruction.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:247,Integrability,interface,interface,247,/**; * @}; */; /**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreInstructionBuilder Instruction Builders; *; * An instruction builder represents a point within a basic block and is; * the exclusive means of building instructions using the C interface.; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:72,Usability,clear,clear,72,"/**; * Set location information used by debugging information.; *; * To clear the location metadata of the given instruction, pass NULL to \p Loc.; *; * @see llvm::IRBuilder::SetCurrentDebugLocation(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:84,Usability,clear,clear,84,"/**; * Set the default floating-point math metadata for the given builder.; *; * To clear the metadata, pass NULL to \p FPMathTag.; *; * @see llvm::IRBuilder::setDefaultFPMathTag(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:132,Energy Efficiency,allocate,allocated,132,"/**; * Obtain the basic blocks acting as handlers for a catchswitch instruction.; *; * The Handlers parameter should point to a pre-allocated array of; * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the; * first LLVMGetNumHandlers() entries in the array will be populated; * with LLVMBasicBlockRef instances.; *; * @param CatchSwitch The catchswitch instruction to operate on.; * @param Handlers Memory address of an array to be filled with basic blocks.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Performance,optimiz,optimizations,47,/**; * Get the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:48,Performance,optimiz,optimizations,48,/**; * Sets the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:41,Availability,mask,mask,41,/**; * Get the number of elements in the mask of a ShuffleVector instruction.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:15,Availability,mask,mask,15,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:49,Availability,mask,mask,49,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:151,Availability,mask,mask,151,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:143,Deployability,pipeline,pipeline,143,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:166,Deployability,pipeline,pipeline,166,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:202,Performance,optimiz,optimization,202,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Deployability,pipeline,pipeline,47,/** Constructs a new function-by-function pass pipeline over the module; provider. It does not take ownership of the module provider. This type of; pipeline is suitable for code generation and JIT compilation tasks.; @see llvm::FunctionPassManager::FunctionPassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:148,Deployability,pipeline,pipeline,148,/** Constructs a new function-by-function pass pipeline over the module; provider. It does not take ownership of the module provider. This type of; pipeline is suitable for code generation and JIT compilation tasks.; @see llvm::FunctionPassManager::FunctionPassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:83,Energy Efficiency,schedul,scheduled,83,"/** Initializes, executes on the provided module, and finalizes all of the; passes scheduled in the pass manager. Returns 1 if any of the passes; modified the module, 0 otherwise.; @see llvm::PassManager::run(Module&) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:43,Energy Efficiency,schedul,scheduled,43,"/** Initializes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doInitialization */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:40,Energy Efficiency,schedul,scheduled,40,"/** Executes all of the function passes scheduled in the function pass manager; on the provided function. Returns 1 if any of the passes modified the; function, false otherwise.; @see llvm::FunctionPassManager::run(Function&) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:41,Energy Efficiency,schedul,scheduled,41,"/** Finalizes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doFinalization */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:31,Deployability,pipeline,pipeline,31,"/** Frees the memory of a pass pipeline. For function pipelines, does not free; the module provider.; @see llvm::PassManagerBase::~PassManagerBase. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:54,Deployability,pipeline,pipelines,54,"/** Frees the memory of a pass pipeline. For function pipelines, does not free; the module provider.; @see llvm::PassManagerBase::~PassManagerBase. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:164,Performance,Multi-thread,Multi-threading,164,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Safety,safe,safe,109,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:16,Performance,Multi-thread,Multi-threading,16,/** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,Safety,safe,safe,46,/** Check whether LLVM is executing in thread-safe mode or not.; @see llvm::llvm_is_multithreaded */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h:584,Modifiability,portab,portability,584,"/*===-- include/llvm-c/DataTypes.h - Define fixed size types ------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file contains definitions to figure out the size of _HOST_ data types.*|; |* This file is important because different host OS's define different macros,*|; |* which makes portability tough. This file exports the following *|; |* definitions: *|; |* *|; |* [u]int(32|64)_t : typedefs for signed and unsigned 32/64 bit system types*|; |* [U]INT(8|16|32|64)_(MIN|MAX) : Constants for the min and max values. *|; |* *|; |* No library is required when using these functions. *|; |* *|; |*===----------------------------------------------------------------------===*/; /* Please leave this file C-compatible. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:477,Integrability,interface,interface,477,"//===------------ DebugInfo.h - LLVM C API Debug Info API -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file declares the C API endpoints for generating DWARF Debug Info; ///; /// Note: This interface is experimental. It is *NOT* stable, and may be; /// changed without warning.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variables,49,/**; * Finalize a specific subprogram.; * No new variables may be added to this subprogram afterwards.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:488,Performance,optimiz,optimization,488,"/**; * A CompileUnit provides an anchor for all debugging; * information generated during this instance of compilation.; * \param Lang Source programming language, eg.; * \c LLVMDWARFSourceLanguageC99; * \param FileRef File info.; * \param Producer Identify the producer of debugging information; * and code. Usually this is a compiler; * version string.; * \param ProducerLen The length of the C string passed to \c Producer.; * \param isOptimized A boolean flag which indicates whether optimization; * is enabled or not.; * \param Flags This string lists command line options. This; * string is directly embedded in debug info; * output which may be used by a tool; * analyzing generated debugging information.; * \param FlagsLen The length of the C string passed to \c Flags.; * \param RuntimeVer This indicates runtime version for languages like; * Objective-C.; * \param SplitName The name of the file that we'll split debug info; * out into.; * \param SplitNameLen The length of the C string passed to \c SplitName.; * \param Kind The kind of debug information to generate.; * \param DWOId The DWOId if this is a split skeleton compile unit.; * \param SplitDebugInlining Whether to emit inline debug info.; * \param DebugInfoForProfiling Whether to emit extra debug info for; * profile collection.; * \param SysRoot The Clang system root (value of -isysroot).; * \param SysRootLen The length of the C string passed to \c SysRoot.; * \param SDK The SDK. On Darwin, the last component of the sysroot.; * \param SDKLen The length of the C string passed to \c SDK.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:291,Modifiability,Config,ConfigMacros,291,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:415,Modifiability,Config,ConfigMacrosLen,415,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:471,Modifiability,Config,ConfigMacros,471,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:330,Modifiability,variab,variable,330,/**; * Create a new descriptor for the specified subprogram.; * \param Builder The \c DIBuilder.; * \param Scope Function scope.; * \param Name Function name.; * \param NameLen Length of enumeration name.; * \param LinkageName Mangled function name.; * \param LinkageNameLen Length of linkage name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Function type.; * \param IsLocalToUnit True if this function is not externally visible.; * \param IsDefinition True if this is a function definition.; * \param ScopeLine Set to the beginning of the scope this starts; * \param Flags E.g.: \c LLVMDIFlagLValueReference. These flags are; * used to emit dwarf attributes.; * \param IsOptimized True if optimization is ON.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:742,Performance,optimiz,optimization,742,/**; * Create a new descriptor for the specified subprogram.; * \param Builder The \c DIBuilder.; * \param Scope Function scope.; * \param Name Function name.; * \param NameLen Length of enumeration name.; * \param LinkageName Mangled function name.; * \param LinkageNameLen Length of linkage name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Function type.; * \param IsLocalToUnit True if this function is not externally visible.; * \param IsDefinition True if this is a function definition.; * \param ScopeLine Set to the beginning of the scope this starts; * \param Flags E.g.: \c LLVMDIFlagLValueReference. These flags are; * used to emit dwarf attributes.; * \param IsOptimized True if optimization is ON.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:62,Modifiability,variab,variable,62,"/**; * Create a descriptor for an imported function, type, or variable. Suitable; * for e.g. FORTRAN-style USE declarations.; * \param Builder The DIBuilder.; * \param Scope The scope this module is imported into.; * \param Decl The declaration (or definition) of a function, type,; or variable.; * \param File File where the declaration is located.; * \param Line Line number of the declaration.; * \param Name A name that uniquely identifies this imported; declaration.; * \param NameLen The length of the C string passed to \c Name.; * \param Elements Renamed elements.; * \param NumElements Number of renamed elements.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:286,Modifiability,variab,variable,286,"/**; * Create a descriptor for an imported function, type, or variable. Suitable; * for e.g. FORTRAN-style USE declarations.; * \param Builder The DIBuilder.; * \param Scope The scope this module is imported into.; * \param Decl The declaration (or definition) of a function, type,; or variable.; * \param File File where the declaration is located.; * \param Line Line number of the declaration.; * \param Name A name that uniquely identifies this imported; declaration.; * \param NameLen The length of the C string passed to \c Name.; * \param Elements Renamed elements.; * \param NumElements Number of renamed elements.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:67,Modifiability,variab,variable,67,"/**; * Create debugging information entry for Objective-C instance variable.; * \param Builder The DIBuilder.; * \param Name Member name.; * \param NameLen The length of the C string passed to \c Name.; * \param File File where this member is defined.; * \param LineNo Line number.; * \param SizeInBits Member size.; * \param AlignInBits Member alignment.; * \param OffsetInBits Member offset.; * \param Flags Flags to encode member attribute, e.g. private; * \param Ty Parent type.; * \param PropertyNode Property associated with this ivar.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:55,Modifiability,inherit,inheritance,55,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:197,Modifiability,inherit,inherits,197,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:336,Modifiability,inherit,inheritance,336,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,/**; * Create a new descriptor for the specified variable which has a complex; * address expression for its address.; * \param Builder The DIBuilder.; * \param Addr An array of complex address operations.; * \param Length Length of the address operation array.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,"/**; * Create a new descriptor for the specified variable that does not have an; * address, but does have a constant value.; * \param Builder The DIBuilder.; * \param Value The constant value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:75,Modifiability,Variab,Variable,75,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:118,Modifiability,variab,variable,118,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:230,Modifiability,variab,variable,230,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:338,Modifiability,variab,variable,338,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:402,Modifiability,Variab,Variable,402,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:474,Modifiability,variab,variable,474,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:664,Modifiability,variab,variables,664,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:697,Modifiability,Variab,Variable,697,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:63,Modifiability,variab,variable,63,/**; * Retrieves the \c DIVariable associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getVariable(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:109,Modifiability,variab,variable,109,/**; * Retrieves the \c DIVariable associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getVariable(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:65,Modifiability,variab,variable,65,/**; * Retrieves the \c DIExpression associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getExpression(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:111,Modifiability,variab,variable,111,/**; * Retrieves the \c DIExpression associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getExpression(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:60,Modifiability,variab,variable,60,/**; * Get the metadata of the file associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getFile(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:88,Modifiability,variab,variable,88,/**; * Get the metadata of the file associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getFile(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:61,Modifiability,variab,variable,61,/**; * Get the metadata of the scope associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getScope(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:89,Modifiability,variab,variable,89,/**; * Get the metadata of the scope associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getScope(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:56,Modifiability,variab,variable,56,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:126,Modifiability,Variab,Variable,126,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:169,Modifiability,variab,variable,169,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:281,Modifiability,variab,variable,281,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:388,Modifiability,variab,variable,388,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:452,Modifiability,Variab,Variable,452,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:524,Modifiability,variab,variable,524,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:647,Modifiability,Variab,Variable,647,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:152,Modifiability,variab,variable,152,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:195,Modifiability,variab,variable,195,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:282,Modifiability,variab,variable,282,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:276,Modifiability,variab,variable,276,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:319,Modifiability,variab,variable,319,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:406,Modifiability,variab,variable,406,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:144,Modifiability,variab,variable,144,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:176,Modifiability,variab,variable,176,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:263,Modifiability,variab,variable,263,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:268,Modifiability,variab,variable,268,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:300,Modifiability,variab,variable,300,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:387,Modifiability,variab,variable,387,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:48,Modifiability,variab,variable,48,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:127,Modifiability,variab,variable,127,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:167,Modifiability,Variab,Variable,167,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:210,Modifiability,variab,variable,210,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:256,Modifiability,variab,variable,256,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:356,Modifiability,variab,variable,356,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:489,Modifiability,Variab,Variable,489,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:429,Performance,optimiz,optimizations,429,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:56,Modifiability,variab,variable,56,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:135,Modifiability,variab,variable,135,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:175,Modifiability,Variab,Variable,175,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:218,Modifiability,variab,variable,218,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:281,Modifiability,variab,variable,281,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:335,Modifiability,variab,variable,335,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:435,Modifiability,variab,variable,435,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:508,Performance,optimiz,optimizations,508,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:66,Usability,clear,clear,66,"/**; * Set the debug location for the given instruction.; *; * To clear the location metadata of the given instruction, pass NULL to \p Loc.; *; * @see llvm::Instruction::setDebugLoc(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h:523,Integrability,interface,interface,523,"/*===-- llvm-c/Deprecated.h - Deprecation macro -------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares LLVM_ATTRIBUTE_C_DEPRECATED() macro, which can be *|; |* used to deprecate functions in the C interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:54,Integrability,Interface,Interface,54,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:438,Integrability,interface,interface,438,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:522,Integrability,interface,interface,522,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:23,Performance,latency,latency,23,/* The option to print latency information alongside instructions */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:158,Performance,load,load,158,"/**; * The type for the symbol lookup function. This may be called by the; * disassembler for things like adding a comment for a PC plus a constant; * offset load instruction to use a symbol name instead of a load address value.; * It is passed the block information is saved when the disassembler context is; * created and the ReferenceValue to look up as a symbol. If no symbol is found; * for the ReferenceValue NULL is returned. The ReferenceType of the; * instruction is passed indirectly as is the PC of the instruction in; * ReferencePC. If the output reference can be determined its type is returned; * indirectly in ReferenceType along with ReferenceName if any, or that is set; * to NULL.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:209,Performance,load,load,209,"/**; * The type for the symbol lookup function. This may be called by the; * disassembler for things like adding a comment for a PC plus a constant; * offset load instruction to use a symbol name instead of a load address value.; * It is passed the block information is saved when the disassembler context is; * created and the ReferenceValue to look up as a symbol. If no symbol is found; * for the ReferenceValue NULL is returned. The ReferenceType of the; * instruction is passed indirectly as is the PC of the instruction in; * ReferencePC. If the output reference can be determined its type is returned; * indirectly in ReferenceType along with ReferenceName if any, or that is set; * to NULL.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:45,Performance,load,load,45,/* The input reference is from a PC relative load instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:40,Testability,stub,stub,40,/* The output reference is to as symbol stub. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:44,Integrability,message,message,44,/* The output reference is to a Objective-C message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:44,Integrability,message,message,44,/* The output reference is to a Objective-C message ref. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:20,Availability,Error,Error,20,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:36,Availability,Error,Error,36,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:452,Availability,Error,Error,452,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:50,Integrability,Interface,Interface,50,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:432,Integrability,interface,interface,432,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,Error,Error,28,/**; * @defgroup LLVMCError Error Handling; * @ingroup LLVMC; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:30,Availability,error,error,30,/**; * Opaque reference to an error instance. Null serves as the 'success' value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:7,Availability,Error,Error,7,/**; * Error type identifier.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:41,Availability,error,error,41,"/**; * Returns the type id for the given error instance, which must be a failure; * value (i.e. non-null).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:73,Availability,failure,failure,73,"/**; * Returns the type id for the given error instance, which must be a failure; * value (i.e. non-null).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,error,error,28,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:86,Availability,error,error,86,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:218,Availability,error,error,218,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:133,Usability,usab,usable,133,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:34,Availability,error,error,34,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:77,Availability,error,error,77,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:40,Integrability,message,message,40,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:127,Usability,usab,usable,127,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,error,error,28,/**; * Dispose of the given error message.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:34,Integrability,message,message,34,/**; * Dispose of the given error message.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:15,Availability,Error,ErrorHandling,15,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:33,Availability,Error,Error,33,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:452,Availability,error,error,452,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:50,Integrability,Interface,Interface,50,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:23,Availability,error,error,23,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:74,Availability,error,error,74,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:7,Deployability,Install,Install,7,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:268,Deployability,install,install,268,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:58,Safety,detect,detects,58,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:23,Availability,error,error,23,/**; * Reset the fatal error handler. This resets LLVM's fatal error handling; * behavior to the default.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:63,Availability,error,error,63,/**; * Reset the fatal error handler. This resets LLVM's fatal error handling; * behavior to the default.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/ExecutionEngine.h - ExecutionEngine Lib C Iface --*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMExecutionEngine.o, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:683,Integrability,interface,interface,683,"/*===-- llvm-c/ExecutionEngine.h - ExecutionEngine Lib C Iface --*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMExecutionEngine.o, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:556,Availability,error,error,556,"/**; * Create an MCJIT execution engine for a module, with the given options. It is; * the responsibility of the caller to ensure that all fields in Options up to; * the given SizeOfOptions are initialized. It is correct to pass a smaller; * value of SizeOfOptions that omits some fields. The canonical way of using; * this is:; *; * LLVMMCJITCompilerOptions options;; * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));; * ... fill in those options you care about; * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),; * &error);; *; * Note that this is also correct, though possibly suboptimal:; *; * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:687,Availability,error,error,687,"/**; * Create an MCJIT execution engine for a module, with the given options. It is; * the responsibility of the caller to ensure that all fields in Options up to; * the given SizeOfOptions are initialized. It is correct to pass a smaller; * value of SizeOfOptions that omits some fields. The canonical way of using; * this is:; *; * LLVMMCJITCompilerOptions options;; * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));; * ... fill in those options you care about; * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),; * &error);; *; * Note that this is also correct, though possibly suboptimal:; *; * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:20,Availability,error,error,20,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:74,Availability,error,error,74,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:85,Integrability,message,message,85,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:117,Usability,clear,cleared,117,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:506,Availability,error,error,506,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:279,Energy Efficiency,Allocate,AllocateCodeSection,279,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:299,Energy Efficiency,Allocate,Allocate,299,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:357,Energy Efficiency,Allocate,AllocateDataSection,357,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:377,Energy Efficiency,Allocate,Allocate,377,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:470,Performance,cache,cache,470,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:16,Usability,simpl,simple,16,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h:26,Integrability,Wrap,Wrapper,26,"/*===- llvm-c/ExternC.h - Wrapper for 'extern ""C""' ----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h:442,Integrability,wrap,wrapper,442,"/*===- llvm-c/ExternC.h - Wrapper for 'extern ""C""' ----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:40,Integrability,Interface,Interface,40,"/*===-- llvm-c/IRReader.h - IR Reader C Interface -----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the IR Reader. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/IRReader.h - IR Reader C Interface -----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the IR Reader. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:253,Availability,error,errors,253,/**; * @defgroup LLVMCCoreIRReader IR Reader; * @ingroup LLVMCCore; *; * @{; */; /**; * Read LLVM IR from a memory buffer and convert it into an in-memory Module; * object. Returns 0 on success.; * Optionally returns a human-readable description of any errors that; * occurred during parsing IR. OutMessage must be disposed with; * LLVMDisposeMessage.; *; * @see llvm::ParseIR(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:42,Integrability,Interface,Interface,42,"/*===-- llvm-c/Linker.h - Module Linker C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the module/file/archive linker. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Linker.h - Module Linker C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the module/file/archive linker. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:125,Availability,error,error,125,"/* Links the source module into the destination module. The source module is; * destroyed.; * The return value is true if an error occurred, false otherwise.; * Use the diagnostic handler to get any diagnostic message.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:210,Integrability,message,message,210,"/* Links the source module into the destination module. The source module is; * destroyed.; * The return value is true if an error occurred, false otherwise.; * Use the diagnostic handler to get any diagnostic message.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:435,Integrability,interface,interface,435,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:687,Integrability,interface,interface,687,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:770,Integrability,interface,interface,770,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:508,Usability,simpl,simple,508,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:489,Modifiability,layers,layers,489,/**; * @defgroup LLVMCExecutionEngineLLJIT LLJIT; * @ingroup LLVMCExecutionEngine; *; * @{; */; /**; * A function for constructing an ObjectLinkingLayer instance to be used; * by an LLJIT instance.; *; * Clients can call LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator to; * set the creator function to use when constructing an LLJIT instance.; * This can be used to override the default linking layer implementation; * that would otherwise be chosen by LLJITBuilder.; *; * Object linking layers returned by this function will become owned by the; * LLJIT instance. The client is not responsible for managing their lifetimes; * after the function returns.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:149,Availability,error,error,149,/**; * Dispose of an LLVMOrcLLJITBuilderRef. This should only be called if ownership; * has not been passed to LLVMOrcCreateLLJIT (e.g. because some error prevented; * that function from being called).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:205,Safety,detect,detectHost,205,/**; * Set the JITTargetMachineBuilder to be used when constructing the LLJIT; * instance. Calling this function is optional: if it is not called then the; * LLJITBuilder will use JITTargeTMachineBuilder::detectHost to construct a; * JITTargetMachineBuilder.; *; * This function takes ownership of the JTMB argument: clients should not; * dispose of the JITTargetMachineBuilder after calling this function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:225,Availability,error,error,225,"/**; * Create an LLJIT instance from an LLJITBuilder.; *; * This operation takes ownership of the Builder argument: clients should not; * dispose of the builder after calling this function (even if the function; * returns an error). If a null Builder argument is provided then a; * default-constructed LLJITBuilder will be used.; *; * On success the resulting LLJIT instance is uniquely owned by the client and; * automatically manages the memory of all JIT'd code and all modules that are; * transferred to it (e.g. via LLVMOrcLLJITAddLLVMIRModule). Disposing of the; * LLJIT instance will free all memory managed by the JIT, including JIT'd code; * and not-yet compiled modules.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:435,Integrability,interface,interface,435,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:798,Integrability,interface,interface,798,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:881,Integrability,interface,interface,881,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:123,Deployability,Install,Install,123,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:135,Modifiability,plugin,plugin,135,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:204,Security,expose,expose,204,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:36,Integrability,Interface,Interface,36,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:436,Integrability,interface,interface,436,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:539,Integrability,interface,interface,539,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:471,Performance,optimiz,optimization,471,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:26,Performance,load,loaded,26,/** opaque reference to a loaded object module */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:24,Availability,error,error,24,/**; * Returns the last error string or NULL if last operation was successful.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Performance,load,loadable,29,/**; * Checks if a file is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Performance,load,loadable,29,/**; * Checks if a file is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,Performance,load,loadable,31,/**; * Checks if a buffer is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,Performance,load,loadable,31,/**; * Checks if a buffer is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:58,Availability,error,error,58,/**; * Loads an object file from disk.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:60,Availability,error,error,60,/**; * Loads an object file from memory.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from memory.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:88,Availability,error,error,88,/**; * Loads an object file from memory with an extra path argument.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=9; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from memory with an extra path argument.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=9; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:275,Availability,error,error,275,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:54,Performance,Load,Loads,54,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:131,Safety,safe,safe,131,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:197,Availability,error,error,197,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:58,Performance,Load,Loads,58,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:125,Safety,safe,safe,125,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:97,Availability,error,error,97,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:97,Availability,error,error,97,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,Energy Efficiency,allocate,allocated,35,/**; * Frees all memory internally allocated by the module.; * Upon return the lto_module_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:282,Availability,error,error,282,"/**; * If targeting mach-o on darwin, this function gets the CPU type and subtype; * that will end up being encoded in the mach-o header. These are the values; * that can be found in mach/machine.h.; *; * \p out_cputype and \p out_cpusubtype must be non-NULL.; *; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=27; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:175,Availability,error,error,175,"/**; * Diagnostic handler type.; * \p severity defines the severity.; * \p diag is the actual diagnostic.; * The diagnostic is not prefixed by any of severity keyword, e.g., 'error: '.; * \p ctxt is used to pass the context set with the diagnostic handler.; *; * \since LTO_API_VERSION=7; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:57,Availability,error,error,57,/**; * Instantiates a code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; * All modules added using \a lto_codegen_add_module() must have been created; * in the same context as the codegen.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:61,Energy Efficiency,allocate,allocated,61,/**; * Frees all code generator and all memory it internally allocated.; * Upon return the lto_code_gen_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:103,Availability,error,error,103,/**; * Add an object module to the set of modules for which code will be generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \c cg and \c mod must both be in the same context. See \a; * lto_codegen_create_in_local_context() and \a; * lto_module_create_in_codegen_context().; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:66,Availability,error,error,66,/**; * Sets if debug info should be generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:66,Availability,error,error,66,/**; * Sets which PIC code model to generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:171,Performance,optimiz,optimized,171,"/**; * Adds to a list of all global symbols that must exist in the final generated; * code. If a function is not listed there, it might be inlined into every usage; * and optimized away.; *; * \since prior to LTO_API_VERSION=3; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:139,Availability,error,error,139,/**; * Writes a new object file at the specified path that contains the; * merged contents of all modules added so far.; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:402,Availability,failure,failure,402,"/**; * Generates code for all added modules into one native object file.; * This calls lto_codegen_optimize then lto_codegen_compile_optimized.; *; * On success returns a pointer to a generated mach-o/ELF buffer and; * length set to the buffer size. The buffer is owned by the; * lto_code_gen_t and will be freed when lto_codegen_dispose(); * is called, or lto_codegen_compile() is called again.; * On failure, returns NULL (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:284,Availability,error,error,284,"/**; * Generates code for all added modules into one native object file.; * This calls lto_codegen_optimize then lto_codegen_compile_optimized (instead; * of returning a generated mach-o/ELF buffer, it writes to a file).; *; * The name of the file is written to name. Returns true on error.; *; * \since LTO_API_VERSION=5; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:64,Availability,error,error,64,/**; * Runs optimization for the merged module. Returns true on error.; *; * \since LTO_API_VERSION=12; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:12,Performance,optimiz,optimization,12,/**; * Runs optimization for the merged module. Returns true on error.; *; * \since LTO_API_VERSION=12; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:410,Availability,failure,failure,410,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:30,Performance,optimiz,optimized,30,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:109,Performance,optimiz,optimizations,109,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:47,Availability,avail,available,47,"/**; * Parses options immediately, making them available as early as possible. For; * example during executing codegen::InitTargetOptionsFromCodeGenFlags. Since; * parsing shud only happen once, only one of lto_codegen_debug_options or; * lto_set_debug_options should be called.; *; * This function takes one or more options separated by spaces.; * Warning: passing file paths through this function may confuse the argument; * parser if the paths contain spaces.; *; * \since LTO_API_VERSION=28; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:53,Performance,optimiz,optimization,53,/**; * Sets if we should run internalize pass during optimization and code; * generation.; *; * \since LTO_API_VERSION=14; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,Energy Efficiency,allocate,allocated,35,/**; * Frees all memory internally allocated by the LTO input file.; * Upon return the lto_module_t is no longer valid.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Integrability,depend,dependent,29,/**; * Returns the number of dependent library specifiers; * for the given LTO input file.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:23,Integrability,depend,dependent,23,/**; * Returns the ith dependent library specifier; * for the given LTO input file. The returned; * string is not null-terminated.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:108,Integrability,wrap,wrap,108,/**; * @} // endgoup LLVMCLTO; * @defgroup LLVMCTLTO ThinLTO; * @ingroup LLVMC; *; * @{; */; /**; * Type to wrap a single object returned by ThinLTO.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:65,Availability,error,error,65,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:280,Performance,perform,perform,280,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:300,Performance,optimiz,optimizations,300,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:56,Energy Efficiency,allocate,allocated,56,/**; * Frees the generator and all memory it internally allocated.; * Upon return the thinlto_code_gen_t is no longer valid.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:191,Availability,avail,available,191,"/**; * Add a module to a ThinLTO code generator. Identifier has to be unique among; * all the modules in a code generator. The data buffer stays owned by the; * client, and is expected to be available for the entire lifetime of the; * thinlto_code_gen_t it is added to.; *; * On failure, returns NULL (check lto_get_error_message() for details).; *; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:279,Availability,failure,failure,279,"/**; * Add a module to a ThinLTO code generator. Identifier has to be unique among; * all the modules in a code generator. The data buffer stays owned by the; * client, and is expected to be available for the entire lifetime of the; * thinlto_code_gen_t it is added to.; *; * On failure, returns NULL (check lto_get_error_message() for details).; *; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Optimiz,Optimize,7,/**; * Optimize and codegen all the modules added to the codegenerator using; * ThinLTO. Resulting objects are accessible using thinlto_module_get_object().; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:111,Security,access,accessible,111,/**; * Optimize and codegen all the modules added to the codegenerator using; * ThinLTO. Resulting objects are accessible using thinlto_module_get_object().; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:176,Availability,avail,available,176,/**; * Returns a reference to the ith object file produced by the ThinLTO; * CodeGenerator.; *; * Client should use \p thinlto_module_get_num_objects() to get the number of; * available objects.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:178,Availability,avail,available,178,/**; * Returns the path to the ith object file produced by the ThinLTO; * CodeGenerator.; *; * Client should use \p thinlto_module_get_num_object_files() to get the number; * of available objects.; *; * \since LTO_API_VERSION=21; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:65,Availability,error,error,65,/**; * Sets which PIC code model to generate.; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:131,Availability,avail,available,131,/**; * Sets the path to a directory to use as a storage for temporary bitcode files.; * The intention is to make the bitcode files available for debugging at various; * stage of the pipeline.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:182,Deployability,pipeline,pipeline,182,/**; * Sets the path to a directory to use as a storage for temporary bitcode files.; * The intention is to make the bitcode files available for debugging at various; * stage of the pipeline.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:190,Availability,avail,available,190,"/**; * Set the path to a directory where to save generated object files. This; * path can be used by a linker to request on-disk files instead of in-memory; * buffers. When set, results are available through; * thinlto_module_get_object_file() instead of thinlto_module_get_object().; *; * \since LTO_API_VERSION=21; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Perform,Perform,7,/**; * Perform CodeGen only: disable all other stages.; *; * \since LTO_API_VERSION=19; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Testability,Test,Test,7,/**; * Test if a module has support for ThinLTO linking.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:178,Performance,optimiz,optimized,178,"/**; * Adds a symbol to the list of global symbols that must exist in the final; * generated code. If a function is not listed there, it might be inlined into; * every usage and optimized away. For every single module, the functions; * referenced from code outside of the ThinLTO modules need to be added here.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:208,Performance,optimiz,optimized,208,"/**; * Adds a symbol to the list of global symbols that are cross-referenced between; * ThinLTO files. If the ThinLTO CodeGenerator can ensure that every; * references from a ThinLTO module to this symbol is optimized away, then; * the symbol can be discarded.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:70,Performance,Cache,Cache,70,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:151,Performance,cache,cache,151,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:162,Performance,cache,cache,162,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:287,Performance,cache,cache,287,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:611,Performance,cache,cache,611,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:889,Performance,cache,cache,889,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:1006,Performance,cache,cache,1006,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:453,Safety,avoid,avoid,453,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:16,Performance,cache,cache,16,"/**; * Sets the cache pruning interval (in seconds). A negative value disables the; * pruning. An unspecified default value will be applied, and a value of 0 will; * force prunning to occur.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:105,Availability,avail,available,105,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:239,Availability,avail,available,239,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:409,Availability,Avail,AvailableSpace,409,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:474,Availability,Avail,AvailableSpace,474,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:281,Energy Efficiency,reduce,reduced,281,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:24,Performance,cache,cache,24,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:194,Performance,cache,cache,194,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:60,Performance,cache,cache,60,/**; * Sets the expiration (in seconds) for an entry in the cache. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:94,Availability,avail,available,94,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:158,Availability,avail,available,158,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:130,Energy Efficiency,reduce,reduced,130,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:36,Performance,cache,cache,36,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:47,Performance,cache,cache,47,/**; * Sets the maximum number of files in the cache directory. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Object.h - Object Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMObject.a, which */; /* implements object file reading and writing. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:674,Integrability,interface,interface,674,"/*===-- llvm-c/Object.h - Object Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMObject.a, which */; /* implements object file reading and writing. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:108,Integrability,wrap,wrappers,108,/**; * @defgroup LLVMCObject Object file reading and writing; * @ingroup LLVMC; *; * @{; */; // Opaque type wrappers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:431,Availability,Error,ErrorMessage,431,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:479,Availability,error,error,479,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:555,Integrability,message,message,555,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:174,Availability,Error,ErrorMessage,174,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:222,Availability,error,error,222,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:298,Integrability,message,message,298,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:14,Security,access,accessors,14,// SectionRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:13,Security,access,accessors,13,// SymbolRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:17,Security,access,accessors,17,// RelocationRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:435,Integrability,interface,interface,435,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:885,Integrability,interface,interface,885,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:968,Integrability,interface,interface,968,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Availability,Error,Error,7,/**; * Error reporter function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:186,Integrability,contract,contract,186,/**; * A MaterializationUnit materialize callback.; *; * Ownership of the Ctx and MR arguments passes to the callback which must; * adhere to the LLVMOrcMaterializationResponsibilityRef contract (see comment; * for that type).; *; * If this callback is called then the LLVMOrcMaterializationUnitDestroy; * callback will NOT be called.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:152,Deployability,release,released,152,/**; * A MaterializationUnit discard callback.; *; * Ownership of JD and Symbol remain with the caller: These arguments should; * not be disposed of or released.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:397,Availability,error,errors,397,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:462,Availability,error,errors,462,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:543,Availability,error,error,543,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:342,Deployability,release,release,342,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:357,Energy Efficiency,allocate,allocated,357,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:962,Availability,error,errors,962,"/**; * A custom generator function. This can be used to create a custom generator; * object using LLVMOrcCreateCustomCAPIDefinitionGenerator. The resulting; * object can be attached to a JITDylib, via LLVMOrcJITDylibAddGenerator, to; * receive callbacks when lookups fail to match existing definitions.; *; * GeneratorObj will contain the address of the custom generator object.; *; * Ctx will contain the context object passed to; * LLVMOrcCreateCustomCAPIDefinitionGenerator.; *; * LookupState will contain a pointer to an LLVMOrcLookupStateRef object. This; * can optionally be modified to make the definition generation process; * asynchronous: If the LookupStateRef value is copied, and the original; * LLVMOrcLookupStateRef set to null, the lookup will be suspended. Once the; * asynchronous definition process has been completed clients must call; * LLVMOrcLookupStateContinueLookup to continue the lookup (this should be; * done unconditionally, even if errors have occurred in the mean time, to; * free the lookup state memory and notify the query object of the failures).; * If LookupState is captured this function must return LLVMErrorSuccess.; *; * The Kind argument can be inspected to determine the lookup kind (e.g.; * as-if-during-static-link, or as-if-during-dlsym).; *; * The JD argument specifies which JITDylib the definitions should be generated; * into.; *; * The JDLookupFlags argument can be inspected to determine whether the original; * lookup included non-exported symbols.; *; * Finally, the LookupSet argument contains the set of symbols that could not; * be found in JD already (the set of generation candidates).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1071,Availability,failure,failures,1071,"/**; * A custom generator function. This can be used to create a custom generator; * object using LLVMOrcCreateCustomCAPIDefinitionGenerator. The resulting; * object can be attached to a JITDylib, via LLVMOrcJITDylibAddGenerator, to; * receive callbacks when lookups fail to match existing definitions.; *; * GeneratorObj will contain the address of the custom generator object.; *; * Ctx will contain the context object passed to; * LLVMOrcCreateCustomCAPIDefinitionGenerator.; *; * LookupState will contain a pointer to an LLVMOrcLookupStateRef object. This; * can optionally be modified to make the definition generation process; * asynchronous: If the LookupStateRef value is copied, and the original; * LLVMOrcLookupStateRef set to null, the lookup will be suspended. Once the; * asynchronous definition process has been completed clients must call; * LLVMOrcLookupStateContinueLookup to continue the lookup (this should be; * done unconditionally, even if errors have occurred in the mean time, to; * free the lookup state memory and notify the query object of the failures).; * If LookupState is captured this function must return LLVMErrorSuccess.; *; * The Kind argument can be inspected to determine the lookup kind (e.g.; * as-if-during-static-link, or as-if-during-dlsym).; *; * The JD argument specifies which JITDylib the definitions should be generated; * into.; *; * The JDLookupFlags argument can be inspected to determine whether the original; * lookup included non-exported symbols.; *; * Finally, the LookupSet argument contains the set of symbols that could not; * be found in JD already (the set of generation candidates).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:339,Security,access,accessed,339,"/**; * A function for applying transformations as part of an transform layer.; *; * Implementations of this type are responsible for managing the lifetime; * of the Module pointed to by ModInOut: If the LLVMModuleRef value is; * overwritten then the function is responsible for disposing of the incoming; * module. If the module is simply accessed/mutated in-place then ownership; * returns to the caller and the function does not need to do any lifetime; * management.; *; * Clients can call LLVMOrcLLJITGetIRTransformLayer to obtain the transform; * layer of a LLJIT instance, and use LLVMOrcIRTransformLayerSetTransform; * to set the function. This can be used to override the default transform; * layer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:332,Usability,simpl,simply,332,"/**; * A function for applying transformations as part of an transform layer.; *; * Implementations of this type are responsible for managing the lifetime; * of the Module pointed to by ModInOut: If the LLVMModuleRef value is; * overwritten then the function is responsible for disposing of the incoming; * module. If the module is simply accessed/mutated in-place then ownership; * returns to the caller and the function does not need to do any lifetime; * management.; *; * Clients can call LLVMOrcLLJITGetIRTransformLayer to obtain the transform; * layer of a LLJIT instance, and use LLVMOrcIRTransformLayerSetTransform; * to set the function. This can be used to override the default transform; * layer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:522,Availability,error,error,522,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:347,Security,access,accessed,347,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:340,Usability,simpl,simply,340,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:23,Availability,error,error,23,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:82,Availability,error,error,82,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:123,Availability,failure,failure,123,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:202,Availability,failure,failure,202,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:280,Availability,error,error,280,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:376,Availability,Failure,FailureToMaterialize,376,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:397,Availability,error,error,397,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:98,Deployability,release,release,98,"/**; * Clear all unreferenced symbol string pool entries.; *; * This can be called at any time to release unused entries in the; * ExecutionSession's string pool. Since it locks the pool (preventing; * interning of any new strings) it is recommended that it only be called; * infrequently, ideally when the caller has reason to believe that some; * entries will have become unreferenced, e.g. after removing a module or; * closing a JITDylib.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Usability,Clear,Clear,7,"/**; * Clear all unreferenced symbol string pool entries.; *; * This can be called at any time to release unused entries in the; * ExecutionSession's string pool. Since it locks the pool (preventing; * interning of any new strings) it is recommended that it only be called; * infrequently, ideally when the caller has reason to believe that some; * entries will have become unreferenced, e.g. after removing a module or; * closing a JITDylib.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:184,Deployability,release,released,184,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:464,Performance,perform,perform,464,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:400,Testability,test,test,400,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:219,Availability,failure,failure,219,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:343,Availability,error,error,343,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:487,Deployability,release,release,487,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:288,Security,access,accessed,288,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:909,Availability,error,error,909,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1005,Availability,failure,failure,1005,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:719,Deployability,release,release,719,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1272,Energy Efficiency,allocate,allocate,1272,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:64,Integrability,wrap,wrapper,64,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Energy Efficiency,Reduce,Reduces,7,/**; * Reduces the ref-count for of a SymbolStringPool entry.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:163,Deployability,release,released,163,/**; * Return the c-string for the given symbol. This string will remain valid until; * the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been; * released).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Energy Efficiency,Reduce,Reduces,7,/**; * Reduces the ref-count of a ResourceTracker.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:147,Availability,error,error,147,/**; * Dispose of a JITDylib::DefinitionGenerator. This should only be called if; * ownership has not been passed to a JITDylib (e.g. because some error; * prevented the client from calling LLVMOrcJITDylibAddGenerator).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:550,Deployability,release,release,550,"/**; * Create a custom MaterializationUnit.; *; * Name is a name for this MaterializationUnit to be used for identification; * and logging purposes (e.g. if this MaterializationUnit produces an; * object buffer then the name of that buffer will be derived from this name).; *; * The Syms list contains the names and linkages of the symbols provided by this; * unit. This function takes ownership of the elements of the Syms array. The; * Name fields of the array elements are taken to have been retained for this; * function. The client should *not* release the elements of the array, but is; * still responsible for destroying the array itself.; *; * The InitSym argument indicates whether or not this MaterializationUnit; * contains static initializers. If three are no static initializers (the common; * case) then this argument should be null. If there are static initializers; * then InitSym should be set to a unique name that also appears in the Syms; * list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag; * set. This function takes ownership of the InitSym, which should have been; * retained twice on behalf of this function: once for the Syms entry and once; * for InitSym. If clients wish to use the InitSym value after this function; * returns they must retain it once more for themselves.; *; * If any of the symbols in the Syms list is looked up then the Materialize; * function will be called.; *; * If any of the symbols in the Syms list is overridden then the Discard; * function will be called.; *; * The caller owns the underling MaterializationUnit and is responsible for; * either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing; * of it by calling LLVMOrcDisposeMaterializationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:131,Testability,log,logging,131,"/**; * Create a custom MaterializationUnit.; *; * Name is a name for this MaterializationUnit to be used for identification; * and logging purposes (e.g. if this MaterializationUnit produces an; * object buffer then the name of that buffer will be derived from this name).; *; * The Syms list contains the names and linkages of the symbols provided by this; * unit. This function takes ownership of the elements of the Syms array. The; * Name fields of the array elements are taken to have been retained for this; * function. The client should *not* release the elements of the array, but is; * still responsible for destroying the array itself.; *; * The InitSym argument indicates whether or not this MaterializationUnit; * contains static initializers. If three are no static initializers (the common; * case) then this argument should be null. If there are static initializers; * then InitSym should be set to a unique name that also appears in the Syms; * list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag; * set. This function takes ownership of the InitSym, which should have been; * retained twice on behalf of this function: once for the Syms entry and once; * for InitSym. If clients wish to use the InitSym value after this function; * returns they must retain it once more for themselves.; *; * If any of the symbols in the Syms list is looked up then the Materialize; * function will be called.; *; * If any of the symbols in the Syms list is overridden then the Discard; * function will be called.; *; * The caller owns the underling MaterializationUnit and is responsible for; * either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing; * of it by calling LLVMOrcDisposeMaterializationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:69,Deployability,release,release,69,/**; * Disposes of the passed LLVMOrcCSymbolFlagsMap.; *; * Does not release the entries themselves.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:80,Deployability,release,release,80,/**; * Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .; *; * Does not release the symbols themselves.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:482,Availability,error,error,482,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:544,Availability,error,error,544,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:567,Availability,failure,failure,567,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:621,Availability,error,error,621,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:92,Deployability,update,update,92,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:580,Integrability,depend,dependency,580,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:729,Integrability,depend,dependencies,729,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:647,Testability,log,log,647,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:209,Availability,error,error,209,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:271,Availability,error,error,271,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:294,Availability,failure,failure,294,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:348,Availability,error,error,348,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:307,Integrability,depend,dependency,307,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:459,Integrability,depend,dependencies,459,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:374,Testability,log,log,374,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:353,Availability,error,errors,353,"/**; * Attempt to claim responsibility for new definitions. This method can be; * used to claim responsibility for symbols that are added to a; * materialization unit during the compilation process (e.g. literal pool; * symbols). Symbol linkage rules are the same as for symbols that are; * defined up front: duplicate strong definitions will result in errors.; * Duplicate weak definitions will be discarded (in which case they will; * not be added to this responsibility instance).; *; * This method can be used by materialization units that want to add; * additional symbols at materialization time (e.g. stubs, compile; * callbacks, metadata); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:608,Testability,stub,stubs,608,"/**; * Attempt to claim responsibility for new definitions. This method can be; * used to claim responsibility for symbols that are added to a; * materialization unit during the compilation process (e.g. literal pool; * symbols). Symbol linkage rules are the same as for symbols that are; * defined up front: duplicate strong definitions will result in errors.; * Duplicate weak definitions will be discarded (in which case they will; * not be added to this responsibility instance).; *; * This method can be used by materialization units that want to add; * additional symbols at materialization time (e.g. stubs, compile; * callbacks, metadata); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:100,Availability,error,error,100,"/**; * Notify all not-yet-emitted covered by this MaterializationResponsibility; * instance that an error has occurred.; * This will remove all symbols covered by this MaterializationResponsibility; * from the target JITDylib, and send an error to any queries waiting on; * these symbols.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:239,Availability,error,error,239,"/**; * Notify all not-yet-emitted covered by this MaterializationResponsibility; * instance that an error has occurred.; * This will remove all symbols covered by this MaterializationResponsibility; * from the target JITDylib, and send an error to any queries waiting on; * these symbols.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:12,Integrability,depend,dependencies,12,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:138,Integrability,Depend,Dependencies,138,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:340,Integrability,Depend,Dependence,340,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:448,Integrability,Depend,Dependence,448,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:605,Integrability,Depend,Dependencies,605,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:12,Integrability,depend,dependencies,12,/**; * Adds dependencies to all symbols that the MaterializationResponsibility is; * responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for; * notes about memory responsibility.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:206,Deployability,install,install,206,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:312,Deployability,configurat,configuration,312,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:312,Modifiability,config,configuration,312,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:280,Deployability,install,install,280,"/**; * Create a JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * If a Platform is attached to the ExecutionSession then; * Platform::setupJITDylib will be called to install standard platform symbols; * (e.g. standard library interposes). If no Platform is installed then this; * call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will; * always return success.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:371,Deployability,install,installed,371,"/**; * Create a JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * If a Platform is attached to the ExecutionSession then; * Platform::setupJITDylib will be called to install standard platform symbols; * (e.g. standard library interposes). If no Platform is installed then this; * call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will; * always return success.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:153,Deployability,release,released,153,"/**; * Return a reference to a newly created resource tracker associated with JD.; * The tracker is returned with an initial ref-count of 1, and must be released; * with LLVMOrcReleaseResourceTracker when no longer needed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:84,Usability,clear,clear,84,"/**; * Calls remove on all trackers associated with this JITDylib, see; * JITDylib::clear().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:546,Availability,error,error,546,"/**; * Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect; * static library symbols into the JITDylib. On success the resulting; * generator is owned by the client. Ownership is typically transferred by; * adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,; *; * Call with the optional TargetTriple argument will succeed if the file at; * the given path is a static library or a MachO universal binary containing a; * static library that is compatible with the given triple. Otherwise it will; * return an error.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; * ; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:321,Availability,alive,alive,321,/**; * Create a ThreadSafeContext containing a new LLVMContext.; *; * Ownership of the underlying ThreadSafeContext data is shared: Clients; * can and should dispose of their ThreadSafeContext as soon as they no longer; * need to refer to it directly. Other references (e.g. from ThreadSafeModules); * will keep the data alive as long as it is needed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:30,Integrability,wrap,wrapped,30,/**; * Get a reference to the wrapped LLVMContext.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:33,Integrability,wrap,wrapper,33,/**; * Create a ThreadSafeModule wrapper around the given LLVM module. This takes; * ownership of the M argument which should not be disposed of or referenced; * after this function returns.; *; * Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT; * (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer; * responsible for it. If it is not transferred to the JIT then the client; * should call LLVMOrcDisposeThreadSafeModule to dispose of it.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:129,Availability,error,error,129,/**; * Dispose of a ThreadSafeModule. This should only be called if ownership has; * not been passed to LLJIT (e.g. because some error prevented the client from; * adding this to the JIT).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:43,Safety,detect,detecting,43,/**; * Create a JITTargetMachineBuilder by detecting the host.; *; * On success the client owns the resulting JITTargetMachineBuilder. It must be; * passed to a consuming operation (e.g.; * LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling; * LLVMOrcDisposeJITTargetMachineBuilder.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:697,Integrability,interface,interface,697,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:780,Integrability,interface,interface,780,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:122,Usability,simpl,simplify,122,"/**; * Create a RTDyldObjectLinkingLayer instance using MCJIT-memory-manager-like; * callbacks.; *; * This is intended to simplify transitions for existing MCJIT clients. The; * callbacks used are similar (but not identical) to the callbacks for; * LLVMCreateSimpleMCJITMemoryManager: Unlike MCJIT, RTDyldObjectLinkingLayer; * will create a new memory manager for each object linked by calling the given; * CreateContext callback. This allows for code removal by destroying each; * allocator individually. Every allocator will be destroyed (if it has not been; * already) at RTDyldObjectLinkingLayer destruction time, and the; * NotifyTerminating callback will be called to indicate that no further; * allocation contexts will be created.; *; * To implement MCJIT-like behavior clients can implement CreateContext,; * NotifyTerminating, and Destroy as:; *; * void *CreateContext(void *CtxCtx) { return CtxCtx; }; * void NotifyTerminating(void *CtxCtx) { MyOriginalDestroy(CtxCtx); }; * void Destroy(void *Ctx) { }; *; * This scheme simply reuses the CreateContextCtx pointer as the one-and-only; * allocation context.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:1032,Usability,simpl,simply,1032,"/**; * Create a RTDyldObjectLinkingLayer instance using MCJIT-memory-manager-like; * callbacks.; *; * This is intended to simplify transitions for existing MCJIT clients. The; * callbacks used are similar (but not identical) to the callbacks for; * LLVMCreateSimpleMCJITMemoryManager: Unlike MCJIT, RTDyldObjectLinkingLayer; * will create a new memory manager for each object linked by calling the given; * CreateContext callback. This allows for code removal by destroying each; * allocator individually. Every allocator will be destroyed (if it has not been; * already) at RTDyldObjectLinkingLayer destruction time, and the; * NotifyTerminating callback will be called to indicate that no further; * allocation contexts will be created.; *; * To implement MCJIT-like behavior clients can implement CreateContext,; * NotifyTerminating, and Destroy as:; *; * void *CreateContext(void *CtxCtx) { return CtxCtx; }; * void NotifyTerminating(void *CtxCtx) { MyOriginalDestroy(CtxCtx); }; * void Destroy(void *Ctx) { }; *; * This scheme simply reuses the CreateContextCtx pointer as the one-and-only; * allocation context.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:44,Integrability,Interface,Interface,44,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:438,Integrability,interface,interface,438,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:528,Integrability,interface,interface,528,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:90,Performance,optimiz,optimizations,90,"/**; * The type of the remark. For example, it can allow users to only keep the; * missed optimizations from the compiler.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:122,Availability,avail,available,122,/**; * Get the next argument in \p Remark from the position of \p It.; *; * Returns `NULL` if there are no more arguments available.; *; * The lifetime of the returned value is bound to the lifetime of \p Remark.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,Safety,avoid,avoid,214,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,Safety,avoid,avoid,214,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=1; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:421,Availability,error,error,421,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:588,Availability,error,error,588,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:615,Availability,error,error,615,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:696,Availability,error,error,696,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:785,Availability,error,error,785,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:1134,Deployability,Release,Release,1134,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:597,Integrability,message,message,597,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:48,Availability,error,error,48,/**; * Returns `1` if the parser encountered an error while parsing the buffer.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:54,Availability,error,error,54,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:89,Availability,error,error,89,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:267,Deployability,release,released,267,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:60,Integrability,message,message,60,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:7,Deployability,Release,Releases,7,/**; * Releases all the resources used by \p Parser.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:37,Integrability,Interface,Interface,37,"/*===-- llvm-c/Support.h - Support C Interface --------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the LLVM support library. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Support.h - Support C Interface --------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the LLVM support library. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:76,Performance,load,loads,76,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:226,Performance,Load,LoadLibraryPermanently,226,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:130,Safety,safe,safe,130,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:56,Performance,load,loaded,56,"/**; * This function will search through all previously loaded dynamic; * libraries for the symbol \p symbolName. If it is found, the address of; * that symbol is returned. If not, null is returned.; *; * @see sys::DynamicLibrary::SearchForAddressOfSymbol(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Target.h - Target Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMTarget.a, which */; /* implements target information. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:661,Integrability,interface,interface,661,"/*===-- llvm-c/Target.h - Target Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMTarget.a, which */; /* implements target information. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:63,Availability,avail,available,63,/* Declare all of the target-initialization functions that are available. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available assembly printer initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available assembly parser initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available disassembler initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:105,Availability,avail,available,105,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:136,Modifiability,config,configured,136,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:91,Security,access,access,91,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:102,Availability,avail,available,102,/** LLVMInitializeAllTargets - The main program should call this function if it; wants to link in all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:133,Modifiability,config,configured,133,/** LLVMInitializeAllTargets - The main program should call this function if it; wants to link in all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:103,Availability,avail,available,103,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:136,Modifiability,config,configured,136,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:89,Security,access,access,89,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:158,Availability,avail,available,158,"/** LLVMInitializeAllAsmPrinters - The main program should call this function if; it wants all asm printers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:121,Modifiability,config,configured,121,"/** LLVMInitializeAllAsmPrinters - The main program should call this function if; it wants all asm printers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:156,Availability,avail,available,156,"/** LLVMInitializeAllAsmParsers - The main program should call this function if; it wants all asm parsers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:119,Modifiability,config,configured,119,"/** LLVMInitializeAllAsmParsers - The main program should call this function if; it wants all asm parsers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:161,Availability,avail,available,161,"/** LLVMInitializeAllDisassemblers - The main program should call this function; if it wants all disassemblers that LLVM is configured to support, to make; them available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:124,Modifiability,config,configured,124,"/** LLVMInitializeAllDisassemblers - The main program should call this function; if it wants all disassemblers that LLVM is configured to support, to make; them available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:49,Modifiability,variab,variable,49,/** Computes the preferred alignment of a global variable in bytes for a target.; See the method llvm::DataLayout::getPreferredAlignment. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:58,Integrability,Interface,Interface,58,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:701,Integrability,interface,interface,701,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:124,Availability,error,error,124,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:133,Availability,Error,ErrorMessage,133,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:186,Integrability,message,message,186,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:189,Deployability,release,released,189,/*===-- Target Machine ----------------------------------------------------===*/; /**; * Create a new set of options for an llvm::TargetMachine.; *; * The returned option structure must be released with; * LLVMDisposeTargetMachineOptions() after the call to; * LLVMCreateTargetMachineWithOptions().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:178,Deployability,configurat,configuration,178,/**; * Create a new llvm::TargetMachine.; *; * \param T the target to create a machine for.; * \param Triple a triple describing the target machine.; * \param Options additional configuration (see; * LLVMCreateTargetMachineOptions()).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:178,Modifiability,config,configuration,178,/**; * Create a new llvm::TargetMachine.; *; * \param T the target to create a machine for.; * \param Triple a triple describing the target machine.; * \param Options additional configuration (see; * LLVMCreateTargetMachineOptions()).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:8,Safety,abort,abort,8,/** Set abort behaviour when global instruction selection fails to lower/select; * an instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:148,Availability,error,error,148,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:157,Availability,Error,ErrorMessage,157,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:76,Integrability,wrap,wraps,76,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:209,Integrability,message,message,209,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:29,Integrability,Interface,Interface,29,"/*===-- llvm-c/Support.h - C Interface Types declarations ---------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines types used by the C interface to LLVM. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:446,Integrability,interface,interface,446,"/*===-- llvm-c/Support.h - C Interface Types declarations ---------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines types used by the C interface to LLVM. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:545,Availability,down,downcasts,545,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:655,Integrability,interface,interfaces,655,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:40,Modifiability,polymorphi,polymorphic,40,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:526,Performance,perform,performs,526,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:7,Integrability,Interface,Interface,7,"/**; * Interface used to provide a module to JIT or interpreter.; * This is now just a synonym for llvm::Module, but we have to keep using the; * different type to keep binary compatibility.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:440,Integrability,interface,interface,440,"/*===-- llvm-c/Transform/PassBuilder.h - PassBuilder for LLVM C ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header contains the LLVM-C interface into the new pass manager *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:288,Deployability,pipeline,pipelines,288,"/**; * Construct and run a set of passes over a module; *; * This function takes a string with the passes that should be used. The format; * of this string is the same as opt's -passes argument for the new pass; * manager. Individual passes may be specified, separated by commas. Full; * pipelines may also be invoked using `default<O3>` and friends. See opt for; * full reference of the Passes format.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:7,Deployability,Toggle,Toggle,7,"/**; * Toggle adding the VerifierPass for the PassBuilder, ensuring all functions; * inside the module is valid.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:7,Deployability,Toggle,Toggle,7,/**; * Toggle debug logging when running the PassBuilder; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:20,Testability,log,logging,20,/**; * Toggle debug logging when running the PassBuilder; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:25,Energy Efficiency,allocate,allocated,25,/**; * Dispose of a heap-allocated PassBuilderOptions instance; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:49,Integrability,Interface,Interface,49,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:430,Integrability,interface,interface,430,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:472,Integrability,interface,interface,472,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:616,Integrability,interface,interface,616,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:729,Safety,detect,detect,729,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:718,Testability,test,tests,718,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:711,Usability,simpl,simple,711,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:1185,Usability,simpl,simple,1185,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:87,Testability,test,testing,87,/// Allow disabling BasicAA from the AA results. This is particularly useful; /// when testing to isolate a single AA implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:191,Integrability,depend,dependency,191,"// AAResults preserves the AAManager by default, due to the stateless nature; // of AliasAnalysis. There is no need to check whether it has been preserved; // explicitly. Check if any module dependency was invalidated and caused the; // AAManager to be invalidated. Invalidate ourselves in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:32,Integrability,depend,dependencies,32,"// Check if any of the function dependencies were invalidated, and invalidate; // ourselves in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Integrability,depend,depend,17,"// Everything we depend on is still fine, so are we. Nothing to invalidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:84,Security,access,access,84,"// Otherwise, check if the call modifies or references the; // location this memory access defines. The best we can say; // is that if the call references what this instruction; // defines, it must be clobbered by this location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:213,Security,access,accessible,213,"// Try to refine the mod-ref info further using other API entry points to the; // aggregate set of AA results.; // We can completely ignore inaccessible memory here, because MemoryLocations; // can only reference accessible memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:20,Availability,mask,mask,20,"// Apply the ModRef mask. This ensures that if Loc is a constant memory; // location, we take into account the fact that the call definitely could not; // modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:51,Integrability,depend,dependence,51,"// If they both only read from memory, there is no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:40,Integrability,depend,dependence,40,"// If Call1 only reads memory, the only dependence on Call2 can be; // from Call1 reading memory written by Call2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Security,access,access,17,"// If Call2 only access memory through arguments, accumulate the mod/ref; // information from Call1's references to the memory referenced by; // Call2's arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:73,Integrability,depend,dependence,73,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:160,Integrability,depend,dependence,160,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:244,Integrability,depend,dependence,244,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:90,Deployability,update,update,90,"// ModRefC1 indicates what Call1 might do to Call2ArgLoc, and we use; // above ArgMask to update dependence info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:97,Integrability,depend,dependence,97,"// ModRefC1 indicates what Call1 might do to Call2ArgLoc, and we use; // above ArgMask to update dependence info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Security,access,accesses,17,"// If Call1 only accesses memory through arguments, check if Call2 references; // any of the memory referenced by Call1's arguments. If not, return NoModRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:10,Performance,load,load,10,"// If the load address doesn't alias the given address, it doesn't read; // or write the specified memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:16,Performance,load,load,16,"// Otherwise, a load just reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:22,Availability,mask,mask,22,"// Examine the ModRef mask. If Mod isn't present, then return NoModRef.; // This ensures that if Loc is a constant memory location, we take into; // account the fact that the store definitely could not modify the memory; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:76,Availability,mask,mask,76,"// All we know about a fence instruction is what we get from the ModRef; // mask: if Loc is a constant memory location, the fence definitely could; // not modify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:103,Security,access,accessed,103,"// If the va_arg address cannot alias the pointer in question, then the; // specified memory cannot be accessed by the va_arg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:11,Deployability,Release,Release,11,// Acquire/Release cmpxchg has properties that matter for arbitrary addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:67,Security,access,access,67,"// If the cmpxchg address does not alias the location, it does not access; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:11,Deployability,Release,Release,11,// Acquire/Release atomicrmw has properties that matter for arbitrary addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:69,Security,access,access,69,"// If the atomicrmw address does not alias the location, it does not access; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:439,Testability,test,test,439,"/// Return information about whether a particular call site modifies; /// or reads the specified memory location \p MemLoc before instruction \p I; /// in a BasicBlock.; /// FIXME: this is really just shoring-up a deficiency in alias analysis.; /// BasicAA isn't willing to spend linear time determining whether an alloca; /// was captured before or after this particular call, while we are. However,; /// with a smarter AA in place, this test is just wasting compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:297,Availability,avail,available,297,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:12,Integrability,wrap,wrapper,12,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:117,Integrability,interface,interface,117,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:357,Modifiability,config,configured,357,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:279,Availability,down,down,279,"// NB! This *must* be reset before adding new AA results to the new; // AAResults object because in the legacy pass manager, each instance; // of these will refer to the *same* immutable analyses, registering and; // unregistering themselves with them. We need to carefully tear down the; // previous object first, in this case replacing it with an empty one, before; // registering new results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:21,Availability,avail,available,21,"// BasicAA is always available for function analyses. Also, we add it first; // so that it can trump TBAA results when it proves MustAlias.; // FIXME: TBAA should have an explicit mode to support this and then we; // should reconsider the ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:43,Availability,avail,available,43,// Populate the results with the currently available AAs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:6,Availability,avail,available,6,"// If available, run an external AA providing callback over the results as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:7,Performance,load,load,7,// The load case works because isNonEscapingLocalObject considers all; // stores to be escapes (it passes true for the StoreCaptures argument; // to PointerMayBeCaptured).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:193,Performance,load,load,193,"// The inttoptr case works because isNonEscapingLocalObject considers all; // means of converting or equating a pointer to an int (ptrtoint, ptr store; // which could be followed by an integer load, ptr<->int compare) as; // escaping, and objects located at well-known addresses via platform-specific; // means cannot be considered non-escaping local objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:27,Security,access,accessible,27,"// A noalias return is not accessible from any other code. If the pointer; // does not escape prior to the unwind, then the caller cannot access the; // memory either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:138,Security,access,access,138,"// A noalias return is not accessible from any other code. If the pointer; // does not escape prior to the unwind, then the caller cannot access the; // memory either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:115,Performance,perform,perform,115,"// We don't consider globals as writable: While the physical memory is writable,; // we may not have provenance to perform the write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp:29,Performance,load,load,29,"// iterate over all pairs of load, store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:3,Deployability,Update,Update,3,// Update the alias and access types of this set...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:24,Security,access,access,24,// Update the alias and access types of this set...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:3,Deployability,Update,Update,3,// Update TotalAliasSetSize only if not forwarding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:83,Availability,down,downgrade,83,"// If we cannot find a must-alias with any of the existing MemoryLocs, we; // must downgrade to may-alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:291,Availability,avail,available,291,"/// mergeAliasSetsForMemoryLocation - Given a memory location, merge all alias; /// sets that may alias it. Return the unified set, or nullptr if no aliasing; /// set was found. A known existing alias set for the pointer value of the; /// memory location can be passed in (or nullptr if not available). MustAliasAll; /// is updated to true/false if the memory location is found to MustAlias all; /// the sets it merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:324,Deployability,update,updated,324,"/// mergeAliasSetsForMemoryLocation - Given a memory location, merge all alias; /// sets that may alias it. Return the unified set, or nullptr if no aliasing; /// set was found. A known existing alias set for the pointer value of the; /// memory location can be passed in (or nullptr if not available). MustAliasAll; /// is updated to true/false if the memory location is found to MustAlias all; /// the sets it merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:14,Performance,perform,perform,14,"// Otherwise, perform the actual merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:29,Performance,Cache,Cache,29,"//===- AssumptionCache.cpp - Cache finding @llvm.assume calls -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:30,Safety,avoid,avoid,30,// Try using find_as first to avoid creating extra value handles just for the; // purpose of doing the lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:88,Performance,cache,cache,88,"// Go through all instructions in all blocks, add all calls to @llvm.assume; // to this cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:3,Deployability,Update,Update,3,// Update affected values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:61,Testability,assert,asserts,61,"// We expect the number of assumptions to be small, so in an asserts build; // check that we don't accumulate duplicates and that all assumptions point; // to the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:46,Safety,avoid,avoid,46,"// We probe the function map twice to try and avoid creating a value handle; // around the function in common cases. This makes insertion a bit slower,; // but if we have to insert we're going to scan the whole function so that; // shouldn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:19,Performance,cache,cache,19,"// Ok, build a new cache by scanning the function, insert it and the value; // handle into our map, and return the newly populated cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:131,Performance,cache,cache,131,"// Ok, build a new cache by scanning the function, insert it and the value; // handle into our map, and return the newly populated cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:129,Deployability,update,update,129,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:254,Deployability,update,updated,254,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:155,Performance,cache,cache,155,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:464,Integrability,interface,interface,464,"//===- BasicAliasAnalysis.cpp - Stateless Alias Analysis Impl -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the primary stateless implementation of the; // Alias Analysis interface that implements identities (two different; // globals cannot alias, etc), but does no stateful analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:118,Integrability,depend,depends,118,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been. Note that we; // may be created without handles to some analyses and in that case don't; // depend on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:232,Integrability,depend,depend,232,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been. Note that we; // may be created without handles to some analyses and in that case don't; // depend on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:630,Energy Efficiency,allocate,allocated,630,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:1141,Usability,simpl,simplicity,1141,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:89,Security,access,accesses,89,"// If we have dereferenceability information we know a lower bound for the; // extent as accesses for a lower offset would be valid. We need to exclude; // the ""or null"" part if null is a valid pointer. We can ignore frees, as an; // access after free would be undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:234,Security,access,access,234,"// If we have dereferenceability information we know a lower bound for the; // extent as accesses for a lower offset would be valid. We need to exclude; // the ""or null"" part if null is a valid pointer. We can ignore frees, as an; // access after free would be undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:83,Security,access,accessed,83,"// If queried with a precise location size, we assume that location size to be; // accessed, thus valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:262,Integrability,wrap,wrap-arounds,262,"/// To ensure a pointer offset fits in an integer of size IndexSize; /// (in bits) when that size is smaller than the maximum index size. This is; /// an issue, for example, in particular for 32b pointers with negative indices; /// that rely on two's complement wrap-arounds for precise alias information; /// where the maximum index size is 64b.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:161,Integrability,wrap,wrapping,161,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:194,Integrability,wrap,wraps,194,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:104,Safety,avoid,avoid,104,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:71,Usability,simpl,simply,71,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:105,Modifiability,variab,variable,105,"// Represents the internal structure of a GEP, decomposed into a base pointer,; // constant offsets, and variable scaled indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:10,Modifiability,variab,variable,10,// Scaled variable (non-constant) indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:40,Performance,scalab,scalable,40,// Don't attempt to analyze GEPs if the scalable index is not zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Modifiability,extend,extended,81,"// If the integer type is smaller than the index size, it is implicitly; // sign extended or truncated to index size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:49,Modifiability,variab,variable,49,"// If we already had an occurrence of this index variable, merge this; // scale into it. For example, we want to handle:; // A[x][x] -> x*16 + x*4 -> x*20; // This also ensures that 'x' only appears in the index list once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:16,Integrability,wrap,wrap-arounds,16,// Take care of wrap-arounds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:112,Integrability,depend,dependence,112,"// These intrinsics can read arbitrary memory, and additionally modref; // inaccessible memory to model control dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:225,Usability,simpl,simple,225,"/// Checks to see if the specified callsite can clobber the specified memory; /// object.; ///; /// Since we only look at local properties of this function, we really can't; /// say much about this query. We do, however, use simple ""address taken""; /// analysis on local objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:31,Energy Efficiency,allocate,allocated,31,"// A call can access a locally allocated object either because it is passed as; // an argument to the call, or because it has escaped prior to the call.; //; // Make sure the object has not escaped here, and then check that none of the; // call arguments alias the object below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:14,Security,access,access,14,"// A call can access a locally allocated object either because it is passed as; // an argument to the call, or because it has escaped prior to the call.; //; // Make sure the object has not escaped here, and then check that none of the; // call arguments alias the object below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:16,Security,access,access,16,"// Call doesn't access memory through this operand, so we don't care; // if it aliases with Object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:148,Integrability,rout,routines,148,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:248,Integrability,rout,routines,248,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:263,Security,access,access,263,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:26,Security,access,accessed,26,// Be conservative if the accessed pointer may alias the allocation -; // fallback to the generic handling below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:111,Integrability,depend,dependencies,111,"// Like assumes, invariant.start intrinsics were also marked as arbitrarily; // writing so that proper control dependencies are maintained but they never; // mod any particular memory location visible to the IR.; // *Unlike* assumes (which are now modeled as NoModRef), invariant.start; // intrinsic is now modeled as reading memory. This prevents hoisting the; // invariant.start intrinsic over stores. Consider:; // *ptr = 40;; // *ptr = 50;; // invariant_start(ptr); // int val = *ptr;; // print(val);; //; // This cannot be transformed to:; //; // *ptr = 40;; // invariant_start(ptr); // *ptr = 50;; // int val = *ptr;; // print(val);; //; // The transformation will cause the second store to be ignored (based on; // rules of invariant.start) and print 40, while the first program always; // prints 50.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Integrability,depend,dependencies,81,"// Guard intrinsics are marked as arbitrarily writing so that proper control; // dependencies are maintained but they never mods any particular memory; // location.; //; // *Unlike* assumes, guard intrinsics are modeled as reading memory since the; // heap state at the point the guard is issued needs to be consistent in case; // the guard invokes the ""deopt"" continuation.; // NB! This function is *not* commutative, so we special case two; // possibilities for guard intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:160,Integrability,rout,routines,160,"// TODO: We can handle other cases here; // 1) For GC languages, arguments to functions are often required to be; // base pointers.; // 2) Result of allocation routines are often base pointers. Leverage TLI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Safety,avoid,avoid,81,// TODO: This limitation exists for compile-time reasons. Relax it if we; // can avoid exponential pathological cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:11,Security,access,accesses,11,"// If both accesses have unknown size, we can only check whether the base; // objects don't alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:184,Performance,scalab,scalable,184,"// If an inbounds GEP would have to start from an out of bounds address; // for the two to alias, then we can assume noalias.; // TODO: Remove !isScalable() once BasicAA fully support scalable location; // size",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Performance,perform,performing,81,"// For GEPs with identical offsets, we can preserve the size and AAInfo; // when performing the alias check on the underlying objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:21,Performance,scalab,scalable,21,// Bail on analysing scalable LocationSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:72,Performance,cache,cache,72,"// Memory referenced by right pointer is nested. Save the offset in; // cache. Note that originally offset estimated as GEP1-V2, but; // AliasResult contains the shift that represents GEP1+Offset=V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:15,Security,access,accesses,15,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:176,Security,access,accesses,176,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:256,Security,access,access,256,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:33,Security,access,accessed,33,"// Compute ranges of potentially accessed bytes for both accesses. If the; // interseciton is empty, there can be no overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:57,Security,access,accesses,57,"// Compute ranges of potentially accessed bytes for both accesses. If the; // interseciton is empty, there can be no overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:80,Integrability,wrap,wrapping,80,// Check if abs(V*Scale) >= abs(Scale) holds in the presence of; // potentially wrapping math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:199,Integrability,wrap,wrap,199,// If Scale is small enough so that abs(V*Scale) >= abs(Scale) holds.; // The max value of abs(V) is 2^ValOrigBW - 1. Multiplying with a; // constant smaller than 2^(bitwidth(Val) - ValOrigBW) won't wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:97,Integrability,wrap,wrapping,97,"// Refine MinAbsVarIndex, if abs(Scale*V) >= abs(Scale) holds in the; // presence of potentially wrapping math.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:136,Safety,avoid,avoid,136,"// VarIndex = Scale*V0 + (-Scale)*V1.; // If V0 != V1 then abs(VarIndex) >= abs(Scale).; // Check that MayBeCrossIteration is false, to avoid reasoning about; // inequality of values across loop iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:85,Energy Efficiency,efficient,efficient,85,"// If the values are PHIs in the same block, we can do a more precise; // as well as efficient check: just check for aliases between the values; // on corresponding edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:292,Modifiability,variab,variable,292,"// To control potential compile time explosion, we choose to be; // conserviate when we have more than one Phi input. It is important; // that we handle the single phi case as that lets us handle LCSSA; // phi nodes and (combined with the recursive phi handling) simple; // pointer induction variable patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:263,Usability,simpl,simple,263,"// To control potential compile time explosion, we choose to be; // conserviate when we have more than one Phi input. It is important; // that we handle the single phi case as that lets us handle LCSSA; // phi nodes and (combined with the recursive phi handling) simple; // pointer induction variable patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:52,Performance,load,load,52,"// If one pointer is the result of a call/invoke or load and the other is a; // non-escaping local object within the same function, then we know the; // object couldn't escape to a point where the call could return it.; //; // Note that if the pointers are in different functions, there are a; // variety of complications. A call with a nocapture argument may still; // temporary store the nocapture argument's value in a temporary memory; // location if that memory location doesn't escape. Or it may pass a; // nocapture value to other functions as long as they don't capture it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:22,Security,access,access,22,"// If the size of one access is larger than the entire object on the other; // side, then we know such behavior is undefined and can assume no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:38,Modifiability,rewrite,rewrites,38,"// This is often a no-op; instcombine rewrites this for us. No-op; // getUnderlyingObject calls are fast, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:431,Performance,cache,cache,431,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:14,Security,access,accesses,14,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:41,Security,access,accessed,41,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:127,Security,access,accesses,127,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:382,Security,access,accesses,382,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:50,Performance,cache,cache,50,"// FIXME: If this depth limit is hit, then we may cache sub-optimal results; // for recursive queries. For this reason, this limit is chosen to be large; // enough to be very rarely hit, while still being small enough to avoid; // stack overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:221,Safety,avoid,avoid,221,"// FIXME: If this depth limit is hit, then we may cache sub-optimal results; // for recursive queries. For this reason, this limit is chosen to be large; // enough to be very rarely hit, while still being small enough to avoid; // stack overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:13,Performance,cache,cache,13,"// Check the cache before climbing up use-def chains. This also terminates; // otherwise infinitely recursive queries. Include MayBeCrossIteration in the; // cache key, because some cases where MayBeCrossIteration==false returns; // MustAlias or NoAlias may become MayAlias under MayBeCrossIteration==true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:158,Performance,cache,cache,158,"// Check the cache before climbing up use-def chains. This also terminates; // otherwise infinitely recursive queries. Include MayBeCrossIteration in the; // cache key, because some cases where MayBeCrossIteration==false returns; // MustAlias or NoAlias may become MayAlias under MayBeCrossIteration==true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Performance,Cache,Cache,3,"// Cache contains sorted {V1,V2} pairs but we should return original order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Performance,Cache,Cache,3,"// Cache contains sorted {V1,V2} pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:133,Deployability,update,updates,133,"// If the assumption has been disproven, remove any results that may have; // been based on this assumption. Do this after the Entry updates above to; // avoid iterator invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:154,Safety,avoid,avoid,154,"// If the assumption has been disproven, remove any results that may have; // been based on this assumption. Do this after the Entry updates above to; // avoid iterator invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:118,Performance,cache,cache,118,"// The result may still be based on assumptions higher up in the chain.; // Remember it, so it can be purged from the cache later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:74,Security,access,accesses,74,"// If both pointers are pointing into the same object and one of them; // accesses the entire object, then the accesses must overlap in some way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:111,Security,access,accesses,111,"// If both pointers are pointing into the same object and one of them; // accesses the entire object, then the accesses must overlap in some way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:90,Modifiability,variab,variable,90,"// Find V in Dest. This is N^2, but pointer indices almost never have more; // than a few variable indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:304,Integrability,wrap,wrapping,304,"// We have a hit - Var0 and Var1 only differ by a constant offset!; // If we've been sext'ed then zext'd the maximum difference between Var0 and; // Var1 is possible to calculate, but we're just interested in the absolute; // minimum difference between the two. The minimum distance may occur due to; // wrapping; consider ""add i3 %i, 5"": if %i == 7 then 7 + 5 mod 8 == 4, and so; // the minimum distance between %i and %i + 5 is 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:69,Integrability,wrap,wrapping,69,"// We can't definitely say whether GEP1 is before or after V2 due to wrapping; // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other; // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and; // V2Size can fit in the MinDiffBytes gap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:399,Usability,simpl,simplified,399,"//===- BlockFrequencyInfo.cpp - Block Frequency Analysis ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:258,Availability,avail,available,258,// Explicitly define the default constructor otherwise it would be implicitly; // defined at the first ODR-use which is the BFI member in the; // LazyBlockFrequencyInfo header. The dtor needs the BlockFrequencyInfoImpl; // template instantiated which is not available in the header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:25,Safety,avoid,avoid,25,// Use 128 bits APInt to avoid overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:184,Safety,avoid,avoid,184,"// udiv is an expensive operation in the general case. If this ends up being; // a hot spot, one of the options proposed in; // https://reviews.llvm.org/D28535#650071 could be used to avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:399,Usability,simpl,simplified,399,"//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:131,Availability,error,error,131,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:654,Deployability,Update,Update,654,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:179,Integrability,depend,depends,179,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update the total.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,Security,hash,hash,9,// Use a hash table for many successors to keep this linear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,Availability,down,down,9,"// Scale down below UINT32_MAX. Since Shift is larger than necessary, we; // can round here without concern about overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update the total.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:69,Usability,clear,clear,69,"// Swap with a default-constructed std::vector, since std::vector<>::clear(); // does not actually clear heap storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:99,Usability,clear,clear,99,"// Swap with a default-constructed std::vector, since std::vector<>::clear(); // does not actually clear heap storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:32,Availability,down,downstream,32,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:83,Availability,down,downstream,83,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:54,Deployability,Release,Releases,54,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:4,Usability,Clear,Clear,4,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:25,Safety,Abort,Abort,25,// Irreducible backedge. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:143,Availability,down,down,143,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:255,Safety,avoid,avoid,255,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Usability,Clear,Clear,3,// Clear the subloop exits to prevent quadratic memory usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:129,Safety,avoid,avoid,129,// Users often add up multiple BlockFrequency values or multiply them with; // things like instruction costs. Leave some room to avoid saturating; // operations reaching UIN64_MAX too early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:107,Deployability,update,updated,107,"// Propagate the head scale through the loop. Since members are visited in; // RPO, the head scale will be updated by the loop scale first, and then the; // final head scale will be used for updated the rest of the members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:191,Deployability,update,updated,191,"// Propagate the head scale through the loop. Since members are visited in; // RPO, the head scale will be updated by the loop scale first, and then the; // final head scale will be used for updated the rest of the members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update min/max scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:45,Safety,avoid,avoid,45,// Use 128 bit APInt to do the arithmetic to avoid overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update loop hierarchy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:399,Usability,simpl,simplified,399,"//===- BranchProbabilityInfo.cpp - Branch Probability Analysis ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:161,Safety,predict,predict,161,"// Weights are for internal use only. They are used by heuristics to help to; // estimate edges' probability. Example:; //; // Using ""Loop Branch Heuristics"" we predict weights of edges for the; // block BB2.; // ...; // |; // V; // BB1<-+; // | |; // | | (Weight = 124); // V |; // BB2--+; // |; // | (Weight = 4); // V; // BB3; //; // Probability of the edge BB2->BB1 = 124 / (124 + 4) = 0.96875; // Probability of the edge BB2->BB3 = 4 / (124 + 4) = 0.03125",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:184,Safety,predict,predicted,184,/// Unreachable-terminating branch taken probability.; ///; /// This is the probability for a branch being taken to a block that terminates; /// (eventually) in unreachable. These are predicted as unlikely as possible.; /// All reachable probability will proportionally share the remaining part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:144,Testability,test,test,144,"/// This is the probability for an unordered floating point comparison, it means; /// one or two of the operands are NaN. Usually it is used to test for an; /// exceptional case, so the result is unlikely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:165,Performance,cache,cache,165,// Record SCC numbers of blocks in the CFG to identify irreducible loops.; // FIXME: We could only calculate this if the CFG is known to be irreducible; // (perhaps cache this info in LoopInfo if we can easily calculate it there?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:57,Performance,cache,cache,57,// Lazily compute the set of headers for a given SCC and cache the results; // in the SccHeaderMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:69,Availability,down,down,69,"// If the sum of weights does not fit in 32 bits, scale every weight down; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:111,Availability,error,error,111,// If all oldBP[i] are zeroes then the proportional distribution results; // in all zero probabilities and the error stays big. In this case we; // evenly spread NewReachableSum over the reachable edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:44,Availability,error,error,44,"// We use uint64_t to avoid double rounding error of the following; // calculation: BP[i] = BP[i] * NewReachableSum / OldReachableSum; // The formula is taken from the private constructor; // BranchProbability(uint32_t Numerator, uint32_t Denominator)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:22,Safety,avoid,avoid,22,"// We use uint64_t to avoid double rounding error of the following; // calculation: BP[i] = BP[i] * NewReachableSum / OldReachableSum; // The formula is taken from the private constructor; // BranchProbability(uint32_t Numerator, uint32_t Denominator)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:54,Safety,Predict,Predict,54,"// Calculate Edge Weights using ""Pointer Heuristics"". Predict a comparison; // between two pointer or pointer and NULL will fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:516,Integrability,depend,depends,516,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:414,Safety,detect,detect,414,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:21,Modifiability,extend,extends,21,// Stop if the chain extends outside of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Deployability,Update,Updates,3,// Updates \p LoopBB's weight and returns true. If \p LoopBB has already; // an associated weight it is unchanged and false is returned.; //; // Please note by the algorithm the weight is not expected to change once set; // thus 'false' status is used to track visited blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:750,Deployability,update,updated,750,"// Starting from \p BB traverse through dominator blocks and assign \p BBWeight; // to all such blocks that are post dominated by \BB. In other words to all; // blocks that the one is executed if and only if another one is executed.; // Importantly, we skip loops here for two reasons. First weights of blocks in; // a loop should be scaled by trip count (yet possibly unknown). Second there is; // no any value in doing that because that doesn't give any additional; // information regarding distribution of probabilities inside the loop.; // Exception is loop 'enter' and 'exit' edges that are handled in a special way; // at calcEstimatedHeuristics.; //; // In addition, \p WorkList is populated with basic blocks if at leas one; // successor has updated estimated weight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:37,Availability,down,down,37,// TODO: Consider propagating weight down the domination line as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:125,Safety,avoid,avoid,125,"// Important note regarding the order of checks. They are ordered by weight; // from lowest to highest. Doing that allows to avoid ""unstable"" results; // when several conditions heuristics can be applied simultaneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:188,Availability,down,down,188,"// Does RPO traversal over all blocks in \p F and assigns weights to; // 'unreachable', 'noreturn', 'cold', 'unwind' blocks. In addition it does its; // best to propagate the weight to up/down the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid adjustment of ZERO weight since it should remain unchanged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:9,Availability,down,down,9,// Scale down loop exiting weight by trip count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid adjustment of ZERO weight since it should remain unchanged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:69,Availability,down,down,69,"// If the sum of weights does not fit in 32 bits, scale every weight down; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:23,Availability,error,errors,23,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:254,Availability,error,error,254,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:307,Availability,error,error,307,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:3,Deployability,Update,Update,3,// Update parent CG for all call graph's nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:78,Testability,assert,assertion,78,// Reset all node's use counts to zero before deleting them to prevent an; // assertion from firing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:106,Availability,down,down,106,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:92,Safety,avoid,avoid,92,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:30,Energy Efficiency,schedul,scheduled,30,"/// Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:26,Deployability,update,update,26,// Yep. Emit a remark and update InstrCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:129,Deployability,update,updated,129,"// After the CGSCCPass is done, when assertions are enabled, use; // RefreshCallGraph to verify that the callgraph was correctly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:37,Testability,assert,assertions,37,"// After the CGSCCPass is done, when assertions are enabled, use; // RefreshCallGraph to verify that the callgraph was correctly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:262,Deployability,update,updated,262,"/// Scan the functions in the specified CFG and resync the; /// callgraph with the call sites found in it. This is used after; /// FunctionPasses have potentially munged the callgraph, and can be used after; /// CallGraphSCC passes to verify that they correctly updated the callgraph.; ///; /// This function returns true if it devirtualized an existing function call,; /// meaning it turned an indirect call into a direct call. This happens when; /// a function pass like GVN optimizes away stuff feeding the indirect call.; /// This never happens in checking mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:477,Performance,optimiz,optimizes,477,"/// Scan the functions in the specified CFG and resync the; /// callgraph with the call sites found in it. This is used after; /// FunctionPasses have potentially munged the callgraph, and can be used after; /// CallGraphSCC passes to verify that they correctly updated the callgraph.; ///; /// This function returns true if it devirtualized an existing function call,; /// meaning it turned an indirect call into a direct call. This happens when; /// a function pass like GVN optimizes away stuff feeding the indirect call.; /// This never happens in checking mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:3,Deployability,Update,Update,3,// Update the edge target in CGN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:506,Energy Efficiency,reduce,reduced,506,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:321,Performance,optimiz,optimize,321,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:399,Safety,detect,detect,399,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:156,Safety,abort,abort,156,"// After scanning this function, if we still have entries in callsites, then; // they are dangling pointers. WeakTrackingVH should save us for this, so; // abort if; // this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:31,Usability,clear,clear,31,// Periodically do an explicit clear to remove tombstones when processing; // large scc's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:87,Safety,avoid,avoid,87,"// If we're in -debug-pass=Executions mode, construct the SCC node list,; // otherwise avoid constructing this string as it is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:30,Energy Efficiency,schedul,scheduled,30,"/// Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:3,Deployability,Update,Update,3,// Update the active scc_iterator so that it doesn't contain dangling; // pointers to the old CallGraphNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:527,Availability,avail,available,527,"//===- CallPrinter.cpp - DOT printer for call graph -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines '-dot-callgraph', which emit a callgraph.<fnname>.dot; // containing the call graph of a module.; //; // There is also a pass available to directly call dotty ('-view-callgraph').; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:113,Availability,avail,available,113,// This option shows static (relative) call counts.; // FIXME:; // Need to show real counts when profile data is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:402,Integrability,rout,routines,402,"//===--- CaptureTracking.cpp - Determine whether a pointer is captured ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; // A pointer value is captured if the function makes a copy of any part of the; // pointer that outlives the call. Not being captured means, more or less, that; // the pointer is only dereferenced and not stored in a global. Returning part; // of the pointer as the function return value may or may not count as capturing; // the pointer, depending on the context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:800,Integrability,depend,depending,800,"//===--- CaptureTracking.cpp - Determine whether a pointer is captured ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; // A pointer value is captured if the function makes a copy of any part of the; // pointer that outlives the call. Not being captured means, more or less, that; // the pointer is only dereferenced and not stored in a global. Returning part; // of the pointer as the function return value may or may not count as capturing; // the pointer, depending on the context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:189,Performance,cache,cached,189,"/// The default value for MaxUsesToExplore argument. It's relatively small to; /// keep the cost of analysis reasonable for clients like BasicAliasAnalysis,; /// where the results can't be cached.; /// TODO: we should probably introduce a caching CaptureTracking analysis and; /// use it where possible. The caching version can use much higher limit or; /// don't have this cap at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:281,Safety,safe,safe,281,"// We want comparisons to null pointers to not be considered capturing,; // but need to guard against cases like gep(p, -ptrtoint(p2)) == null,; // which are equivalent to p == p2 and would capture the pointer.; //; // A dereferenceable pointer is a case where this is known to be safe,; // because the pointer resulting from such a construction would not be; // dereferenceable.; //; // It is not sufficient to check for inbounds GEP here, because GEP with; // zero offset is always inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:64,Safety,avoid,avoid,64,// Check isSafeToPrune() here rather than in shouldExplore() to avoid; // an expensive reachability query for every instruction we look at.; // Instead we only do one for actual capturing candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:143,Integrability,rout,routine,143,"/// PointerMayBeCaptured - Return true if this pointer value may be captured; /// by the enclosing function (which is required to exist). This routine can; /// be expensive, so consider caching the results. The boolean ReturnCaptures; /// specifies whether returning the value (or part of it) from the function; /// counts as capturing it or not. The boolean StoreCaptures specified whether; /// storing the value (or part of it) into memory anywhere automatically; /// counts as capturing it or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:182,Deployability,update,updated,182,"// TODO: If StoreCaptures is not true, we could do Fancy analysis; // to determine whether this store is not actually an escape point.; // In that case, BasicAliasAnalysis should be updated as well to; // take advantage of this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:263,Integrability,rout,routine,263,"/// PointerMayBeCapturedBefore - Return true if this pointer value may be; /// captured by the enclosing function (which is required to exist). If a; /// DominatorTree is provided, only captures which happen before the given; /// instruction are considered. This routine can be expensive, so consider; /// caching the results. The boolean ReturnCaptures specifies whether; /// returning the value (or part of it) from the function counts as capturing; /// it or not. The boolean StoreCaptures specified whether storing the value; /// (or part of it) into memory anywhere automatically counts as capturing it; /// or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:184,Integrability,depend,depending,184,"// Not captured if the callee is readonly, doesn't return a copy through; // its return value and doesn't unwind (a readonly function can leak bits; // by throwing an exception or not depending on the input value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:77,Performance,load,load,77,// Volatile operations effectively capture the memory location that they; // load and store to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:221,Performance,load,loading,221,"// Calling a function pointer does not in itself cause the pointer to; // be captured. This is a subtle point considering that (for example); // the callee might return its own address. It is analogous to saying; // that loading a value from a pointer does not cause the pointer to be; // captured, even though the loaded value might be the pointer itself; // (think of self-referential objects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:315,Performance,load,loaded,315,"// Calling a function pointer does not in itself cause the pointer to; // be captured. This is a subtle point considering that (for example); // the callee might return its own address. It is analogous to saying; // that loading a value from a pointer does not cause the pointer to be; // captured, even though the loaded value might be the pointer itself; // (think of self-referential objects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:12,Performance,load,loads,12,// Volatile loads make the address observable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:42,Performance,load,load,42,"// atomicrmw conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:125,Security,access,accessed,125,"// atomicrmw conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:40,Performance,load,load,40,"// cmpxchg conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:123,Security,access,accessed,123,"// cmpxchg conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:83,Safety,avoid,avoid,83,"// If there are lots of uses, conservatively say that the value; // is captured to avoid taking too much compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:9,Performance,cache,cached,9,"// Found cached result, return it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:110,Performance,load,load,110,"// Set StoreCaptures to True so that we can assume in our callers that the; // pointer is not the result of a load instruction. Currently; // PointerMayBeCaptured doesn't have any special analysis for the; // StoreCaptures=false case; if it did, our callers could be refined to be; // more precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:408,Performance,perform,performs,408,"//===-- CFG.cpp - BasicBlock analysis --------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:6,Availability,down,down,6,// Go down one level if there is a unvisited successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:173,Availability,error,error,173,/// GetSuccessorNumber - Search for the specified successor of basic block BB; /// and return its position in the terminator instruction's list of; /// successors. It is an error to call this with a block that is not a; /// successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:125,Usability,simpl,simply,125,"// If we're in a loop with a hole, not all blocks in the loop are; // reachable from all other blocks. That implies we can't simply jump to; // the loop's exit blocks, as that exit might need to pass through an; // excluded block. Clear Outer so we process BB's successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:231,Usability,Clear,Clear,231,"// If we're in a loop with a hole, not all blocks in the loop are; // reachable from all other blocks. That implies we can't simply jump to; // the loop's exit blocks, as that exit might need to pass through an; // excluded block. Clear Outer so we process BB's successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp:215,Integrability,depend,depends,215,"/// viewCFG - This function is meant for use from the debugger. You can just; /// say 'call F->viewCFG()' and a ghostview window should pop up from the; /// program, displaying the CFG of the current function. This depends on there; /// being a 'dot' and 'gv' program in your path.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:80,Deployability,update,updates,80,/// Explicitly specialize the pass manager run method to handle call graph; /// updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:99,Deployability,update,update,99,"// The SCC may be refined while we are running passes over it, so set up; // a pointer that we can update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the SCC if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:11,Deployability,update,updated,11,"// If C is updated, also create a proxy and update FAM inside the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:44,Deployability,update,update,44,"// If C is updated, also create a proxy and update FAM inside the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:292,Deployability,update,update,292,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:362,Performance,cache,cache,362,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:317,Usability,simpl,simplified,317,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:170,Availability,redundant,redundant,170,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:154,Deployability,update,update,154,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:220,Deployability,update,updated,220,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:164,Safety,avoid,avoid,164,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:170,Safety,redund,redundant,170,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:167,Performance,queue,queued,167,"// Due to call graph mutations, we may have invalid SCCs or SCCs from; // other RefSCCs in the worklist. The invalid ones are dead and the; // other RefSCCs should be queued above, so we just need to skip both; // scenarios here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:662,Deployability,update,updates,662,"// We used to also check if the current SCC is part of the current; // RefSCC and bail if it wasn't, since it should be in RCWorklist.; // However, this can cause compile time explosions in some cases on; // modules with a huge RefSCC. If a non-trivial amount of SCCs in the; // huge RefSCC can become their own child RefSCC, we create one child; // RefSCC, bail on the current RefSCC, visit the child RefSCC, revisit; // the huge RefSCC, and repeat. By visiting all SCCs in the original; // RefSCC we create all the child RefSCCs in one pass of the RefSCC,; // rather one pass of the RefSCC creating one child RefSCC at a time.; // Ensure we can proxy analysis updates from the CGSCC analysis manager; // into the Function analysis manager by getting a proxy here.; // This also needs to update the FunctionAnalysisManager, as this may be; // the first time we see this SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:789,Deployability,update,update,789,"// We used to also check if the current SCC is part of the current; // RefSCC and bail if it wasn't, since it should be in RCWorklist.; // However, this can cause compile time explosions in some cases on; // modules with a huge RefSCC. If a non-trivial amount of SCCs in the; // huge RefSCC can become their own child RefSCC, we create one child; // RefSCC, bail on the current RefSCC, visit the child RefSCC, revisit; // the huge RefSCC, and repeat. By visiting all SCCs in the original; // RefSCC we create all the child RefSCCs in one pass of the RefSCC,; // rather one pass of the RefSCC creating one child RefSCC at a time.; // Ensure we can proxy analysis updates from the CGSCC analysis manager; // into the Function analysis manager by getting a proxy here.; // This also needs to update the FunctionAnalysisManager, as this may be; // the first time we see this SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:832,Availability,robust,robustness,832,"// Each time we visit a new SCC pulled off the worklist,; // a transformation of a child SCC may have also modified this parent; // and invalidated analyses. So we invalidate using the update record's; // cross-SCC preserved set. This preserved set is intersected by any; // CGSCC pass that handles invalidation (primarily pass managers) prior; // to marking its SCC as preserved. That lets us track everything that; // might need invalidation across SCCs without excessive invalidations; // on a single SCC.; //; // This essentially allows SCC passes to freely invalidate analyses; // of any ancestor SCC. If this becomes detrimental to successfully; // caching analyses, we could force each SCC pass to manually; // invalidate the analyses for any SCCs other than themselves which; // are mutated. However, that seems to lose the robustness of the; // pass-manager driven invalidation scheme.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:185,Deployability,update,update,185,"// Each time we visit a new SCC pulled off the worklist,; // a transformation of a child SCC may have also modified this parent; // and invalidated analyses. So we invalidate using the update record's; // cross-SCC preserved set. This preserved set is intersected by any; // CGSCC pass that handles invalidation (primarily pass managers) prior; // to marking its SCC as preserved. That lets us track everything that; // might need invalidation across SCCs without excessive invalidations; // on a single SCC.; //; // This essentially allows SCC passes to freely invalidate analyses; // of any ancestor SCC. If this becomes detrimental to successfully; // caching analyses, we could force each SCC pass to manually; // invalidate the analyses for any SCCs other than themselves which; // are mutated. However, that seems to lose the robustness of the; // pass-manager driven invalidation scheme.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the SCC and RefSCC if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:35,Deployability,update,update,35,"// If we're updating the SCC, also update the FAM inside the proxy's; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC,; // the current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC,; // the current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:92,Deployability,update,updated,92,// We handle invalidating the CGSCC analysis manager's information; // for the (potentially updated) SCC here. Note that any other SCCs; // whose structure has changed should have been invalidated by; // whatever was updating the call graph. This SCC gets invalidated; // late as it contains the nodes that were actively being; // processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:312,Availability,avail,available,312,"// The pass may have restructured the call graph and refined the; // current SCC and/or RefSCC. We need to update our current SCC and; // RefSCC pointers to follow these. Also, when the current SCC is; // refined, re-run the SCC pass over the newly refined SCC in order; // to observe the most precise SCC model available. This inherently; // cannot cycle excessively as it only happens when we split SCCs; // apart, at most converging on a DAG of single nodes.; // FIXME: If we ever start having RefSCC passes, we'll want to; // iterate there too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:107,Deployability,update,update,107,"// The pass may have restructured the call graph and refined the; // current SCC and/or RefSCC. We need to update our current SCC and; // RefSCC pointers to follow these. Also, when the current SCC is; // refined, re-run the SCC pass over the newly refined SCC in order; // to observe the most precise SCC model available. This inherently; // cannot cycle excessively as it only happens when we split SCCs; // apart, at most converging on a DAG of single nodes.; // FIXME: If we ever start having RefSCC passes, we'll want to; // iterate there too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:79,Usability,clear,clear,79,"// We only need to keep internal inlined edge information within; // a RefSCC, clear it to save on space and let the next time we visit; // any of these functions have a fresh start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:99,Deployability,update,update,99,"// The SCC may be refined while we are running passes over it, so set up; // a pointer that we can update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager with each run and intersect the total set; // of preserved analyses so we're ready to iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:38,Performance,optimiz,optimizing,38,"// The SCC may get split while we are optimizing functions due to deleting; // edges. If this happens, the current SCC can shift, so keep track of; // a pointer we can overwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:106,Integrability,contract,contract,106,"// We know that the function pass couldn't have invalidated any other; // function's analyses (that's the contract of a function pass), so; // directly handle the function analysis manager's invalidation here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:44,Deployability,update,update,44,"// If the call graph hasn't been preserved, update it based on this; // function pass. This may also update the current SCC to point to; // a smaller, more refined SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:101,Deployability,update,update,101,"// If the call graph hasn't been preserved, update it based on this; // function pass. This may also update the current SCC to point to; // a smaller, more refined SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:30,Deployability,update,updated,30,// We've also ensured that we updated the call graph along the way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:116,Usability,clear,clear,116,"// This is still a valid proxy.; // If this proxy or the call graph is going to be invalidated, we also need; // to clear all the keys coming from that analysis.; //; // We also directly invalidate the FAM's module proxy if necessary, and if; // that proxy isn't preserved we can't preserve this proxy either. We rely on; // it to handle module -> function analysis invalidation in the face of; // structural changes and so if it's unavailable we conservatively clear the; // entire SCC layer as well rather than trying to do invalidation ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:462,Usability,clear,clear,462,"// This is still a valid proxy.; // If this proxy or the call graph is going to be invalidated, we also need; // to clear all the keys coming from that analysis.; //; // We also directly invalidate the FAM's module proxy if necessary, and if; // that proxy isn't preserved we can't preserve this proxy either. We rely on; // it to handle module -> function analysis invalidation in the face of; // structural changes and so if it's unavailable we conservatively clear the; // entire SCC layer as well rather than trying to do invalidation ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:61,Availability,down,down,61,"// Ok, we have a graph, so we can propagate the invalidation down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:50,Availability,avail,available,50,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:82,Security,access,accessed,82,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:214,Testability,assert,assert,214,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:183,Testability,assert,assertion,183,"// Note: unconditionally getting checking that the proxy exists may get it at; // this point. There are cases when this is being run unnecessarily, but; // it is cheap and having the assertion in place is more valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:59,Deployability,update,updateFAM,59,// We just return an empty result. The caller will use the updateFAM interface; // to correctly register the relevant FunctionAnalysisManager based on the; // context in which this proxy is run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:69,Integrability,interface,interface,69,// We just return an empty result. The caller will use the updateFAM interface; // to correctly register the relevant FunctionAnalysisManager based on the; // context in which this proxy is run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:40,Deployability,update,updates,40,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:251,Deployability,update,updated,251,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:322,Performance,cache,cached,322,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:457,Performance,cache,cached,457,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:388,Usability,clear,cleared,388,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:76,Deployability,update,update,76,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:248,Deployability,update,updates,248,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:607,Integrability,depend,dependencies,607,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:632,Integrability,depend,dependencies,632,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:188,Performance,cache,cached,188,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:471,Performance,cache,cached,471,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:109,Integrability,depend,dependencies,109,// Now walk the functions in this SCC and invalidate any function analysis; // results that might have outer dependencies on an SCC analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:48,Integrability,depend,dependencies,48,"// Forcibly abandon all the inner analyses with dependencies, but; // invalidate nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:23,Deployability,update,update,23,"/// Helper function to update both the \c CGSCCAnalysisManager \p AM and the \c; /// CGSCCPassManager's \c CGSCCUpdateResult \p UR based on a range of newly; /// added SCCs.; ///; /// The range of new SCCs must be in postorder already. The SCC they were split; /// out of must be provided as \p C. The current node being mutated and; /// triggering updates must be passed as \p N.; ///; /// This function returns the SCC containing \p N. This will be either \p C if; /// no new SCCs have been split out, or it will be the new SCC containing \p N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:349,Deployability,update,updates,349,"/// Helper function to update both the \c CGSCCAnalysisManager \p AM and the \c; /// CGSCCPassManager's \c CGSCCUpdateResult \p UR based on a range of newly; /// added SCCs.; ///; /// The range of new SCCs must be in postorder already. The SCC they were split; /// out of must be provided as \p C. The current node being mutated and; /// triggering updates must be passed as \p N.; ///; /// This function returns the SCC containing \p N. This will be either \p C if; /// no new SCCs have been split out, or it will be the new SCC containing \p N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,"// Update the current SCC. Note that if we have new SCCs, this must actually; // change the SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:15,Performance,cache,cached,15,"// If we had a cached FAM proxy originally, we will want to create more of; // them for each SCC that was split off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:216,Deployability,update,updater,216,// We need to propagate an invalidation call to all but the newly current SCC; // because the outer pass manager won't do that for us after splitting them.; // FIXME: We should accept a PreservedAnalysis from the CG updater so that if; // there are preserved analysis we can avoid invalidating them here for; // split-off SCCs.; // We know however that this will preserve any FAM proxy so go ahead and mark; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:275,Safety,avoid,avoid,275,// We need to propagate an invalidation call to all but the newly current SCC; // because the outer pass manager won't do that for us after splitting them.; // FIXME: We should accept a PreservedAnalysis from the CG updater so that if; // there are preserved analysis we can avoid invalidating them here for; // split-off SCCs.; // We know however that this will preserve any FAM proxy so go ahead and mark; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:54,Deployability,update,updated,54,// Ensure the now-current SCC's function analyses are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:42,Deployability,update,updated,42,// Ensure new SCCs' function analyses are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:88,Deployability,update,updateCGAndAnalysisManagerForPass,88,// We can miss devirtualization if an indirect call is created then; // promoted before updateCGAndAnalysisManagerForPass runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:7,Deployability,update,update,7,// Now update the call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:233,Deployability,Update,Update,233,"// Note that we don't bother to invalidate analyses as ref-edge; // connectivity is not really observable in any way and is intended; // exclusively to be used for ordering of transforms rather than for; // analysis conclusions.; // Update RC to the ""bottom"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:7,Deployability,update,update,7,// Now update the call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:126,Deployability,Update,UpdateResult,126,"// Otherwise we are switching an internal ref edge to a call edge. This; // may merge away some SCCs, and we add those to the UpdateResult. We also; // need to make sure to update the worklist in the event SCCs have moved; // before the current one in the post-order sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:173,Deployability,update,update,173,"// Otherwise we are switching an internal ref edge to a call edge. This; // may merge away some SCCs, and we add those to the UpdateResult. We also; // need to make sure to update the worklist in the event SCCs have moved; // before the current one in the post-order sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:57,Deployability,release,release,57,"// FIXME: We should really do a 'clear' here to forcibly release; // memory, but we don't have a good way of doing that and; // preserving the function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Usability,clear,clear,33,"// FIXME: We should really do a 'clear' here to forcibly release; // memory, but we don't have a good way of doing that and; // preserving the function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:58,Deployability,update,update,58,"// If we formed a cycle by creating this call, we need to update more data; // structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:40,Performance,cache,cached,40,"// If one of the invalidated SCCs had a cached proxy to a function; // analysis manager, we need to create a proxy in the new current SCC as; // the invalidated SCCs had their functions moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:149,Deployability,update,update,149,"// Any analyses cached for this SCC are no longer precise as the shape; // has changed by introducing this cycle. However, we have taken care to; // update the proxies so it remains valide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:16,Performance,cache,cached,16,"// Any analyses cached for this SCC are no longer precise as the shape; // has changed by introducing this cycle. However, we have taken care to; // update the proxies so it remains valide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:220,Performance,optimiz,optimize,220,"// Put our current SCC back onto the worklist as we'll visit other SCCs; // that are now definitively ordered prior to the current one in the; // post-order sequence, and may end up observing more precise context to; // optimize the current SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:91,Deployability,update,updates,91,// Record the current SCC for higher layers of the CGSCC pass manager now that; // all the updates have been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:37,Modifiability,layers,layers,37,// Record the current SCC for higher layers of the CGSCC pass manager now that; // all the updates have been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp:396,Integrability,rout,routines,396,"//===- CmpInstAnalysis.cpp - Utils to help fold compares ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse compare instructions; // and fold them into constants or other compare instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:81,Availability,alive,alive,81,"// Note: We don't speculate PHIs here, so we'll miss instruction chains kept; // alive only by ephemeral values.; // Walk the worklist using an index but without caching the size so we can; // append more entries as we process the worklist. This forms a queue without; // quadratic behavior by just leaving processed nodes at the head of the; // worklist forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:254,Performance,queue,queue,254,"// Note: We don't speculate PHIs here, so we'll miss instruction chains kept; // alive only by ephemeral values.; // Walk the worklist using an index but without caching the size so we can; // append more entries as we process the worklist. This forms a queue without; // quadratic behavior by just leaving processed nodes at the head of the; // worklist forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:138,Security,expose,exposed,138,"// If a function is both internal and has a single use, then it is; // extremely likely to get inlined in the future (it was probably; // exposed by an interleaved devirtualization pass).; // When preparing for LTO, liberally consider calls as inline; // candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:406,Safety,safe,safely,406,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this indirect; // jump would jump from the inlined copy of the function into the original; // function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions; // with indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function. And as a QOI issue,; // if someone is using a blockaddress without an indirectbr, and that; // reference somehow ends up in another function or global, we probably; // don't want to inline this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:373,Testability,log,logic,373,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this indirect; // jump would jump from the inlined copy of the function into the original; // function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions; // with indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function. And as a QOI issue,; // if someone is using a blockaddress without an indirectbr, and that; // reference somehow ends up in another function or global, we probably; // don't want to inline this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:401,Integrability,rout,routines,401,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:568,Integrability,rout,routines,568,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:677,Integrability,depend,dependency,677,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:505,Usability,simpl,simplifications,505,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:83,Usability,simpl,simplify,83,"// If the vector is a vector of floating point, convert it to vector of int; // to simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:172,Integrability,depend,depends,172,"// Now we know that the input and output vectors are both integer vectors; // of the same size, and that their #elements is not the same. Do the; // conversion here, which depends on whether the input or output has; // more elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:8,Modifiability,extend,extend,8,// Zero extend the element to the right size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:32,Integrability,depend,depending,32,"// Shift it to the right place, depending on endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:54,Integrability,depend,depending,54,"// Shift the piece of the value into the right place, depending on; // endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:72,Availability,down,down,72,"// If this isn't an aggregate type, there is nothing we can do to drill down; // and find a bitcastable constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:118,Availability,down,down,118,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:22,Performance,load,load,22,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:243,Performance,load,load,243,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:18,Security,access,access,18,"// If the element access is to the element itself and not to tail padding,; // read the bytes from the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:59,Modifiability,variab,variable,59,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:33,Performance,load,load,33,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:43,Performance,scalab,scalable,43,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:28,Performance,load,load,28,// If this isn't an integer load we can't fold it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:28,Performance,load,load,28,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:66,Performance,load,load,66,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:240,Performance,load,load,240,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:31,Performance,load,load,31,// Be careful not to replace a load of an addrspace value with an inttoptr here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:16,Security,access,accessing,16,"// If we're not accessing anything in this constant, the result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:38,Performance,scalab,scalable,38,// TODO: We should be able to support scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:16,Security,access,accessing,16,"// If we're not accessing anything in this constant, the result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:12,Performance,load,loading,12,"// If we're loading off the beginning of the global, some bytes may be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:51,Safety,avoid,avoid,51,// Bail for large initializers in excess of 64K to avoid allocating; // too much memory.; // Offset is assumed to be less than or equal than InitSize (this; // is enforced in ReadDataFromGlobal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:38,Security,access,access,38,"// Explicitly check for out-of-bounds access, so we return poison even if the; // constant is a uniform value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:20,Performance,load,loads,20,// Try hard to fold loads from bitcasted strange and non-type-safe things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:62,Safety,safe,safe,62,// Try hard to fold loads from bitcasted strange and non-type-safe things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:20,Performance,load,loads,20,"// We can only fold loads from constant globals with a definitive initializer.; // Check this upfront, to skip expensive offset calculations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:11,Performance,load,load,11,"// If this load comes from anywhere in a uniform constant global, the value; // is always the same, regardless of the loaded offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:118,Performance,load,loaded,118,"// If this load comes from anywhere in a uniform constant global, the value; // is always the same, regardless of the loaded offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:167,Availability,avail,available,167,"/// One of Op0/Op1 is a constant expression.; /// Attempt to symbolically evaluate the result of a binary operator merging; /// these together. If target data info is available, it is provided as DL,; /// otherwise DL is null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:47,Availability,mask,masking,47,// All the bits of Op0 that the 'and' could be masking are already zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:47,Availability,mask,masking,47,// All the bits of Op1 that the 'and' could be masking are already zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:104,Safety,avoid,avoid,104,// Try to add additional zero indices to reach the desired result element; // type.; // TODO: Should we avoid extra zero indices if ResElemTy can't be reached and; // we'll have to insert a bitcast anyway?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:248,Performance,load,loads,248,"/// Attempt to constant fold an instruction with the; /// specified opcode and operands. If successful, the constant result is; /// returned, if not, null is returned. Note that this function can fail when; /// attempting to fold instructions like loads and stores, which have no; /// constant expression form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:26,Performance,perform,perform,26,"// If we have GEP, we can perform the following folds:; // (ptrtoint (gep null, x)) -> x; // (ptrtoint (gep (gep null, x), y) -> x + y, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:68,Integrability,depend,depend,68,// Operations that do not operate floating-point numbers and do not depend on; // FP environment can be folded even in strictfp functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:24,Integrability,depend,depend,24,// The intrinsics below depend on rounding mode in MXCSR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:4,Usability,Clear,Clear,4,/// Clear the floating-point exception state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:4,Testability,Test,Test,4,/// Test if a floating-point exception was raised.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:368,Availability,avail,available,368,"/// Attempt to fold an SSE floating point to integer conversion of a constant; /// floating point. If roundTowardZero is false, the default IEEE rounding is; /// used (toward nearest, ties to even). This matches the behavior of the; /// non-truncating SSE instructions in the default rounding mode. The desired; /// integer type Ty is used to select how many bits are available for the; /// result. Returns null if the conversion cannot be performed, otherwise; /// returns the Constant value resulting from the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:440,Performance,perform,performed,440,"/// Attempt to fold an SSE floating point to integer conversion of a constant; /// floating point. If roundTowardZero is false, the default IEEE rounding is; /// used (toward nearest, ties to even). This matches the behavior of the; /// non-truncating SSE instructions in the default rounding mode. The desired; /// integer type Ty is used to select how many bits are available for the; /// result. Returns null if the conversion cannot be performed, otherwise; /// returns the Constant value resulting from the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:66,Safety,safe,safe,66,"// If the operation does not change exception status flags, it is safe; // to fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:53,Integrability,depend,depend,53,"// If evaluation raised FP exception, the result can depend on rounding; // mode. If the latter is unknown, folding is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:181,Integrability,depend,depend,181,"// Even if the rounding mode is unknown, try evaluating the operation.; // If it does not raise inexact exception, rounding was not applied,; // so the result is exact and does not depend on rounding mode. Whether; // other FP exceptions are raised, it does not depend on rounding mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:262,Integrability,depend,depend,262,"// Even if the rounding mode is unknown, try evaluating the operation.; // If it does not raise inexact exception, rounding was not applied,; // so the result is exact and does not depend on rounding mode. Whether; // other FP exceptions are raised, it does not depend on rounding mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:117,Integrability,depend,depend,117,"// We know we have a ""Constant"" argument. But we want to only; // return true for manifest constants, not those that depend on; // constants with unknowable values, e.g. GlobalValue or BlockAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:127,Availability,avail,available,127,"// If instruction is not yet put in a basic block (e.g. when cloning; // a function during inlining), Call's caller may not be available.; // So check Call's BB first before querying Call->getCaller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:161,Availability,error,errors,161,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:91,Safety,abort,aborted,91,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:60,Usability,clear,clear,60,// Undef operand with no poison min --> 0 (sign bit must be clear),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:13,Performance,perform,performs,13,"// This code performs rounding towards negative infinity in case the result; // cannot be represented exactly for the given scale. Targets that do care; // about rounding should use a target hook for specifying how rounding; // should be done, and provide their own folding to be consistent with; // rounding. This is the same approach as used by; // DAGTypeLegalizer::ExpandIntRes_MULFIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:101,Safety,avoid,avoid,101,"// The shift amount is interpreted as modulo the bitwidth. If the shift; // amount is effectively 0, avoid UB due to oversized inverse shift below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:37,Usability,simpl,simplify,37,// Use the regular scalar folding to simplify this column.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:70,Safety,avoid,avoid,70,"// The exponent is an ""unspecified value"" for inf/nan. We use zero to avoid; // using undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:10,Modifiability,Refactor,Refactor,10,// FIXME: Refactor this code; this duplicates logic in LibCallsShrinkWrap; // (and to some extent ConstantFoldScalarCall).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:46,Testability,log,logic,46,// FIXME: Refactor this code; this duplicates logic in LibCallsShrinkWrap; // (and to some extent ConstantFoldScalarCall).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:115,Availability,error,error,115,"// Although IEEE-754 says atan2(+/-0.0, +/-0.0) are well-defined, and; // GLIBC and MSVC do not appear to raise an error on those, we; // cannot rely on that behavior. POSIX and C11 say that a domain error; // may occur, so allow for that possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:200,Availability,error,error,200,"// Although IEEE-754 says atan2(+/-0.0, +/-0.0) are well-defined, and; // GLIBC and MSVC do not appear to raise an error on those, we; // cannot rely on that behavior. POSIX and C11 say that a domain error; // may occur, so allow for that possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:177,Integrability,depend,dependence,177,"// Implementation of Fourier–Motzkin elimination, with some tricks from the; // paper Pugh, William. ""The Omega test: a fast and practical integer; // programming algorithm for dependence; // analysis.""; // Supercomputing'91: Proceedings of the 1991 ACM/; // IEEE conference on Supercomputing. IEEE, 1991.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:112,Testability,test,test,112,"// Implementation of Fourier–Motzkin elimination, with some tricks from the; // paper Pugh, William. ""The Omega test: a fast and practical integer; // programming algorithm for dependence; // analysis.""; // Supercomputing'91: Proceedings of the 1991 ACM/; // IEEE conference on Supercomputing. IEEE, 1991.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:28,Modifiability,variab,variable,28,"// First, either remove the variable in place if it is 0 or add the row to; // RemainingRows and remove it from the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:26,Modifiability,variab,variable,26,// Process rows where the variable is != 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:3,Testability,assert,assert,3,"// assert(!Parts.empty() && ""need to have at least some parts"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, we have 'C >= 0'. If the constant is >=; // 0, R is always true, regardless of the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:693,Performance,throughput,throughput,693,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:737,Performance,load,loads,737,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:751,Performance,cache,cache,751,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:779,Safety,predict,predicted,779,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp:245,Integrability,wrap,wrapper,245,//===----------------------------------------------------------------------===//; // CycleInfoWrapperPass Implementation; //===----------------------------------------------------------------------===//; //; // The implementation details of the wrapper pass that holds a CycleInfo; // suitable for use with the legacy pass manager.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:22,Integrability,Depend,Dependence,22,"//===- DDG.cpp - Data Dependence Graph -------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the data dependence graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:415,Integrability,depend,dependence,415,"//===- DDG.cpp - Data Dependence Graph -------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the data dependence graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:83,Usability,Simpl,SimpleDDGNode,83,//===--------------------------------------------------------------------===//; // SimpleDDGNode implementation; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:53,Integrability,depend,dependence,53,// Put the basic blocks in program order for correct dependence; // directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:53,Integrability,depend,dependence,53,// Put the basic blocks in program order for correct dependence; // directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:73,Safety,safe,safe,73,"// In general, if the root node is already created and linked, it is not safe; // to add new nodes since they may be unreachable by the root. However,; // pi-block nodes need to be added after the root node is linked, and they are; // always reachable by the root, because they represent components that are; // already reachable by root.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:3,Safety,Avoid,Avoid,3,// Avoid printing nodes that are part of a pi-block twice. They will get; // printed when the pi-block is printed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:41,Usability,simpl,simple,41,// Only merge two nodes if they are both simple nodes and the consecutive; // instructions after merging belong to the same BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp:49,Integrability,depend,dependence,49,"//===- DDGPrinter.cpp - DOT printer for the data dependence graph ----------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // This file defines the `-dot-ddg` analysis pass, which emits DDG in DOT format; // in a file named `ddg.<graph-name>.dot` for each loop in a function.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:550,Testability,test,testing,550,"//===---- Delinearization.cpp - MultiDimensional Index Delinearization ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements an analysis pass that tries to delinearize all GEP; // instructions in all loops using the SCEV analysis functionality. This pass is; // only used for testing purposes: if your pass needs delinearization, please; // use the on-demand SCEVAddRecExpr::delinearize() function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:409,Modifiability,variab,variable,409,"// Find factors that are multiplied with an expression that (possibly as a; // subexpression) contains an AddRecExpr. In the expression:; //; // 8 * (100 + %p * %q * (%a + {0, +, 1}_loop)); //; // ""%p * %q"" are factors multiplied by the expression ""(%a + {0, +, 1}_loop)""; // that contains the AddRec {0, +, 1}_loop. %p * %q are likely to be array size; // parameters as they form a product with an induction variable.; //; // This collector expects all array size parameters to be in the same MulExpr.; // It might be necessary to later add support for collecting parameters that are; // spread over different nested MulExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:14,Security,access,access,14,// Record the access function for the current subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:85,Security,access,access,85,// Also push in last position the remainder of the last division: it will be; // the access function of the innermost dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1629,Energy Efficiency,allocate,allocated,1629,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2129,Performance,load,loads,2129,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:101,Security,access,access,101,"/// Splits the SCEV into two vectors of SCEVs representing the subscripts and; /// sizes of an array access. Returns the remainder of the delinearization that; /// is the offset start of the array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:572,Security,access,access,572,"/// Splits the SCEV into two vectors of SCEVs representing the subscripts and; /// sizes of an array access. Returns the remainder of the delinearization that; /// is the offset start of the array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1030,Security,access,access,1030," array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1830,Security,access,access,1830,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2199,Security,access,access,2199,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1926,Testability,test,testcase,1926,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2027,Testability,test,testcases,2027,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:27,Security,access,access,27,// Third step: compute the access functions for each subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:13,Usability,simpl,simple,13,// Check the simple case where the array dimensions are fixed size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:133,Usability,clear,clear,133,"// Check that the two size arrays are non-empty and equal in length and; // value.; // TODO: it would be better to let the caller to clear Subscripts, similar; // to how we handle Sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:16,Performance,load,loads,16,// Only analyze loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:26,Security,access,access,26,// Delinearize the memory access as analyzed in all the surrounding loops.; // Do not analyze memory accesses outside loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:101,Security,access,accesses,101,// Delinearize the memory access as analyzed in all the surrounding loops.; // Do not analyze memory accesses outside loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:264,Performance,cache,cache,264,"// We're called once per operand, but for some instructions, we need to; // compute known bits of both operands in order to determine the live bits of; // either (when both operands are instructions themselves). We don't,; // however, want to do this twice, so we cache the result in APInts that live; // in the caller. For the two-relevant-operands case, both operand values are; // provided here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,Availability,alive,alive,7,// The alive bits of the input are the swapped alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:47,Availability,alive,alive,47,// The alive bits of the input are the swapped alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,Availability,alive,alive,7,// The alive bits of the input are the reversed alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:48,Availability,alive,alive,48,// The alive bits of the input are the reversed alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:44,Energy Efficiency,power,powers,44,// Shift amount is modulo the bitwidth. For powers of two we have; // SA % BW == SA & (BW - 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:67,Availability,alive,alive,67,"// For integer-valued instructions, set up an initial empty set of alive; // bits and add the instruction to the work list. For other instructions; // add their operands to the work list (for integer values operands, mark; // all bits as live).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:22,Availability,alive,alive,22,"// Compute the set of alive bits for each operand. These are anded into the; // existing set, if any, and if that changes the set of alive bits, the; // operand is added to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:133,Availability,alive,alive,133,"// Compute the set of alive bits for each operand. These are anded into the; // existing set, if any, and if that changes the set of alive bits, the; // operand is added to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:19,Safety,detect,detect,19,"// We also want to detect dead uses of arguments, but will only store; // demanded bits for instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:49,Availability,alive,alive,49,"// Bits of each operand that are used to compute alive bits of the; // output are alive, all others are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:82,Availability,alive,alive,82,"// Bits of each operand that are used to compute alive bits of the; // output are alive, all others are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:32,Availability,alive,alive,32,"// If we've added to the set of alive bits (or the operand has not; // been previously visited), then re-queue the operand to be visited; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:105,Performance,queue,queue,105,"// If we've added to the set of alive bits (or the operand has not; // been previously visited), then re-queue the operand to be visited; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:58,Availability,mask,mask,58,"// We only track integer uses, everything else produces a mask with all bits; // set",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:14,Availability,alive,alive,14,"// First, the alive carry bits are determined from the alive output bits:; // Let demand ripple to the right but only up to any set bit in Bound.; // AOut = -1----; // Bound = ----1-; // ACarry&~AOut = --111-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:55,Availability,alive,alive,55,"// First, the alive carry bits are determined from the alive output bits:; // Let demand ripple to the right but only up to any set bit in Bound.; // AOut = -1----; // Bound = ----1-; // ACarry&~AOut = --111-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:13,Availability,alive,alive,13,"// Then, the alive input bits are determined from the alive carry bits:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:54,Availability,alive,alive,54,"// Then, the alive input bits are determined from the alive carry bits:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:16,Usability,simpl,simplified,16,// The below is simplified from; //; // APInt CarryKnownZero = ~(PossibleSumZero ^ LHS.Zero ^ RHS.Zero);; // APInt CarryKnownOne = PossibleSumOne ^ LHS.One ^ RHS.One;; // APInt CarryUnknown = ~(CarryKnownZero | CarryKnownOne);; //; // APInt NeededToMaintainCarry =; // (CarryKnownZero & NeededToMaintainCarryZero) |; // (CarryKnownOne & NeededToMaintainCarryOne) |; // CarryUnknown;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1219,Availability,recover,recover,1219,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Integrability,Depend,DependenceAnalysis,8,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:383,Integrability,Depend,DependenceAnalysis,383,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependences,432,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,Depend,Dependence,572,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:685,Integrability,depend,dependence,685,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:781,Integrability,depend,dependence,781,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:843,Integrability,depend,dependence,843,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1165,Integrability,depend,dependence,1165,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:2039,Integrability,interface,interface,2039,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1219,Safety,recover,recover,1219,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1283,Safety,avoid,avoid,1283,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:463,Security,access,accesses,463,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1821,Security,expose,expose,1821,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:583,Testability,Test,Testing,583,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1003,Testability,test,test,1003,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1329,Testability,test,tests,1329,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1528,Testability,test,tests,1528,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1686,Testability,test,test,1686,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1714,Testability,test,tests,1714,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1810,Testability,test,test,1810,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1855,Usability,simpl,simplification,1855,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Integrability,depend,dependence,20,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:127,Integrability,depend,depends,127,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:102,Security,access,access,102,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:11,Testability,test,test,11,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,Dependence,85,//===----------------------------------------------------------------------===//; // Dependence methods; // Returns true if this is an input dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:141,Integrability,depend,dependence,141,//===----------------------------------------------------------------------===//; // Dependence methods; // Returns true if this is an input dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:37,Integrability,depend,dependence,37,// Returns true if this is an output dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,Integrability,depend,dependence,46,// Returns true if this is an flow (aka true) dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:35,Integrability,depend,dependence,35,// Returns true if this is an anti dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:133,Modifiability,variab,variable,133,"// Returns true if a particular level is scalar; that is,; // if no subscript in the source or destination mention the induction; // variable associated with the loop at this level.; // Leave this out of line, so it will serve as a virtual method anchor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:200,Integrability,depend,dependency,200,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:356,Integrability,depend,dependence,356,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:447,Integrability,depend,dependence,447,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:579,Integrability,depend,dependency,579,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:625,Integrability,depend,dependency,625,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:15,Integrability,depend,dependence,15,// Reverse the dependence distance as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:16,Usability,simpl,simple,16,// The rest are simple getters that hide the implementation.; // getDirection - Returns the direction associated with a particular level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:133,Modifiability,variab,variable,133,"// Returns true if a particular level is scalar; that is,; // if no subscript in the source or destination mention the induction; // variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:82,Integrability,depend,dependence,82,// Returns true if peeling the first iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:81,Integrability,depend,dependence,81,// Returns true if peeling the last iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,depend,dependence,54,// Returns true if splitting this loop will break the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,DependenceInfo,85,"//===----------------------------------------------------------------------===//; // DependenceInfo::Constraint methods; // If constraint is a point <X, Y>, returns X.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:182,Testability,assert,assert,182,"//===----------------------------------------------------------------------===//; // DependenceInfo::Constraint methods; // If constraint is a point <X, Y>, returns X.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:61,Testability,assert,assert,61,"// If constraint is a point <X, Y>, returns Y.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns A.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns B.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns C.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Testability,assert,assert,57,"// If constraint is a distance, returns D.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,Update,Updates,3,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:159,Integrability,Depend,Dependence,159,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:170,Testability,Test,Testing,170,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,DependenceInfo,85,//===----------------------------------------------------------------------===//; // DependenceInfo methods; // For debugging purposes. Dumps a dependence to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:144,Integrability,depend,dependence,144,//===----------------------------------------------------------------------===//; // DependenceInfo methods; // For debugging purposes. Dumps a dependence to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:232,Integrability,depend,dependecy,232,"// Returns NoAlias/MayAliass/MustAlias for two memory locations based upon their; // underlaying objects. If LocA and LocB are known to not alias (for any reason:; // tbaa, non-overlapping regions etc), then it is known there is no dependecy.; // Otherwise the underlying objects are checked to see if they point to; // different identifiable objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:23,Performance,load,load,23,// Returns true if the load or store can be analyzed. Atomic and volatile; // operations have properties which this analysis does not understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:561,Energy Efficiency,allocate,allocate,561,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:255,Integrability,rout,routine,255,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1503,Integrability,depend,dependence,1503,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:110,Modifiability,variab,variables,110,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:703,Modifiability,variab,variable,703,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1559,Performance,load,load,1559,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:92,Security,access,accesses,92,// This tries to make sure that we assign unique numbers to src and dst when; // the memory accesses reside in different loops that have the same depth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Security,access,access,60,"// Unlike ScalarEvolution::isLoopInvariant() we consider an access outside of; // any loop as invariant, because we only consier expression evaluation at a; // specific position (where the array access takes place), and not across the; // entire function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:195,Security,access,access,195,"// Unlike ScalarEvolution::isLoopInvariant() we consider an access outside of; // any loop as invariant, because we only consier expression evaluation at a; // specific position (where the array access takes place), and not across the; // entire function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:72,Modifiability,extend,extend,72,// Go through each pair and find the widest bit to which we need; // to extend all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:7,Modifiability,extend,extend,7,// Now extend each pair to the widest seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Modifiability,extend,extend,8,// Sign-extend Src to widestType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Modifiability,extend,extend,8,// Sign-extend Dst to widestType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:126,Modifiability,extend,extended,126,"// removeMatchingExtensions - Examines a subscript pair.; // If the source and destination are identically sign (or zero); // extended, it strips off the extension in an effect to simplify; // the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:180,Usability,simpl,simplify,180,"// removeMatchingExtensions - Examines a subscript pair.; // If the source and destination are identically sign (or zero); // extended, it strips off the extension in an effect to simplify; // the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Integrability,depend,depend,19,"// The AddRec must depend on one of the containing loops. Otherwise,; // mapSrcLoop and mapDstLoop return indices outside the intended range. This; // can happen when a subscript in one loop references an IV from a sibling; // loop that could not be replaced with a concrete exit value by; // getSCEVAtScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:336,Deployability,update,updated,336,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:5,Integrability,wrap,wrapper,5,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:169,Modifiability,extend,extended,169,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:417,Usability,simpl,simple,417,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Safety,avoid,avoid,188,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:113,Testability,test,testing,113,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:144,Testability,test,testing,144,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Integrability,wrap,wrap,65,"// We know S is for Ptr, the operand on a load/store, so doesn't wrap.; // If both parts are NonNegative, the end result will be NonNegative",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:42,Performance,load,load,42,"// We know S is for Ptr, the operand on a load/store, so doesn't wrap.; // If both parts are NonNegative, the end result will be NonNegative",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:376,Availability,avail,available,376,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:155,Integrability,rout,routine,155,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:276,Integrability,wrap,wrap,276,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:103,Modifiability,extend,extend,103,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Modifiability,extend,extends,188,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:238,Safety,safe,safe,238,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,Integrability,depend,dependence,301,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:359,Integrability,depend,dependence,359,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:427,Integrability,depend,dependence,427,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:462,Integrability,depend,dependence,462,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:126,Security,attack,attack,126,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testZIV,3,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:154,Testability,test,test,154,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:174,Testability,test,test,174,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,Integrability,depend,dependent,12,// provably dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,Integrability,depend,dependent,12,// possibly dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:49,Integrability,Depend,Dependence,49,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:484,Integrability,depend,dependence,484,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:537,Integrability,depend,dependence,537,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:603,Integrability,depend,dependence,603,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:706,Integrability,depend,dependence,706,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:729,Integrability,depend,dependence,729,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:858,Integrability,depend,dependence,858,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:192,Modifiability,variab,variable,192,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Testability,Test,Testing,60,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:302,Testability,test,test,302,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:41,Integrability,depend,dependence,41,// Distance greater than trip count - no dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:37,Integrability,depend,dependence,37,"// Coeff doesn't divide Distance, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:55,Integrability,Depend,Dependence,55,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:537,Integrability,depend,dependence,537,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:584,Integrability,depend,dependence,584,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:639,Integrability,depend,dependence,639,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:702,Integrability,depend,dependence,702,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:764,Integrability,depend,dependence,764,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:838,Integrability,depend,dependence,838,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:892,Integrability,depend,dependence,892,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1057,Integrability,depend,dependence,1057,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:198,Modifiability,variab,variable,198,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:66,Testability,Test,Testing,66,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:319,Testability,test,test,319,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,Depend,DependenceInfo,32,// compute SplitIter for use by DependenceInfo::getSplitIteration(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:75,Integrability,depend,dependence,75,"// We're certain that ConstCoeff > 0; therefore,; // if Delta < 0, then no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, Delta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:21,Integrability,depend,dependence,21,"// Delta too big, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:34,Integrability,depend,dependence,34,"// Coeff doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:266,Integrability,depend,dependence,266,"// Kirch's algorithm, from; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; // MIT Press, 1989; //; // Program 2.1, page 29.; // Computes the GCD of AM and BM.; // Also finds a solution to the equation ax - by = gcd(a, b).; // Returns true if dependence disproved; i.e., gcd does not divide Delta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:35,Performance,Optimiz,Optimizing,35,"// Kirch's algorithm, from; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; // MIT Press, 1989; //; // Program 2.1, page 29.; // Computes the GCD of AM and BM.; // Also finds a solution to the equation ax - by = gcd(a, b).; // Returns true if dependence disproved; i.e., gcd does not divide Delta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:320,Integrability,Depend,Dependence,320,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:657,Integrability,depend,dependence,657,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:791,Integrability,depend,depends,791,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:859,Integrability,depend,dependencies,859,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:125,Modifiability,variab,variable,125,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:822,Modifiability,extend,extends,822,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:456,Testability,test,tests,456,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:605,Testability,test,test,605,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:772,Testability,test,tested,772,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,Depend,Dependence,54,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependence,432,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:477,Integrability,depend,dependence,477,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,depend,dependence,572,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:669,Integrability,depend,dependence,669,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:874,Integrability,depend,dependences,874,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:967,Integrability,depend,dependence,967,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:191,Modifiability,variab,variable,191,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,Test,Testing,65,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:308,Testability,test,test,308,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,test,test,19,"// For the WeakSIV test, it's possible the loop isn't common to; // the Src and Dst loops. If it isn't, then there's no need to; // record a direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by first iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by last iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, newDelta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// if SrcCoeff doesn't divide Delta, then no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,Depend,Dependence,54,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependence,432,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:477,Integrability,depend,dependence,477,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,depend,dependence,572,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:669,Integrability,depend,dependence,669,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:874,Integrability,depend,dependences,874,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:967,Integrability,depend,dependence,967,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:191,Modifiability,variab,variable,191,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,Test,Testing,65,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:308,Testability,test,test,308,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,test,test,19,"// For the WeakSIV test, it's possible the loop isn't common to the; // Src and Dst loops. If it isn't, then there's no need to record a direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by first iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by last iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, newDelta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// if SrcCoeff doesn't divide Delta, then no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:53,Integrability,depend,dependence,53,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:251,Integrability,depend,dependence,251,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:147,Modifiability,variab,variable,147,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,Test,Tests,19,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Integrability,Depend,Dependence,58,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Integrability,depend,dependence,316,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:629,Integrability,depend,dependences,629,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:810,Integrability,depend,dependence,810,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1087,Integrability,depend,dependence,1087,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1768,Integrability,depend,dependence,1768,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:533,Modifiability,variab,variables,533,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:719,Modifiability,variab,variable,719,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:69,Testability,Test,Testing,69,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:186,Testability,Test,Test,186,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:412,Testability,test,tests,412,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:606,Testability,test,tests,606,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:679,Testability,test,test,679,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:746,Testability,test,test,746,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:789,Testability,test,tests,789,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1076,Testability,test,test,1076,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:405,Integrability,depend,dependence,405,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:119,Modifiability,variab,variable,119,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:194,Security,attack,attack,194,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testSIV,3,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Testability,test,test,216,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:274,Testability,test,test,274,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:311,Testability,test,tests,311,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:303,Usability,simpl,simpler,303,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Energy Efficiency,adapt,adaptation,234,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:629,Integrability,depend,dependence,629,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:124,Modifiability,variab,variables,124,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Modifiability,adapt,adaptation,234,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:300,Modifiability,Variab,Variable,300,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testRDIV,3,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:266,Testability,test,test,266,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Testability,test,test,316,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:467,Testability,test,test,467,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:501,Testability,test,test,501,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:540,Testability,test,test,540,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Integrability,depend,dependence,57,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:88,Integrability,depend,dependence,88,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Tests,3,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:134,Integrability,depend,dependence,134,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:179,Integrability,depend,dependence,179,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:534,Modifiability,variab,variables,534,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:585,Modifiability,variab,variables,585,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:777,Modifiability,variab,variables,777,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:361,Performance,Perform,Performance,361,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:102,Testability,Test,Tests,102,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:670,Testability,test,test,670,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:710,Testability,test,tests,710,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:817,Testability,test,test,817,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:148,Integrability,depend,dependence,148,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:271,Usability,simpl,simplify,271,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1460,Integrability,depend,dependence,1460,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,Performance,Optimiz,Optimizing,301,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:138,Testability,test,test,138,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:229,Testability,Test,Test,229,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:410,Usability,simpl,simplified,410,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1000,Usability,simpl,simplify,1000,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1153,Usability,simpl,simplifications,1153,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Test,3,"// Test the *, *, *, ... case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:104,Integrability,depend,dependences,104,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:185,Integrability,depend,dependences,185,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Integrability,depend,dependence,216,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:109,Safety,avoid,avoid,109,"// This algorithm has worst case complexity of O(3^n), where 'n' is the number; // of common loop levels. To avoid excessive compile-time, pessimize all the; // results and immediately return when the number of common levels is beyond; // the given threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,"// test bounds for <, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Test,3,"// Test bounds for =, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,"// test bounds for >, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:290,Usability,simpl,simplify,290,"// Computes the upper and lower bounds for level K; // using the * direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^*_k = (A^-_k - B^+_k)(U_k - L_k) + (A_k - B_k)L_k; // UB^*_k = (A^+_k - B^-_k)(U_k - L_k) + (A_k - B_k)L_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^*_k = (A^-_k - B^+_k)U_k; // UB^*_k = (A^+_k - B^-_k)U_k; //; // We must be careful to handle the case where the upper bound is unknown.; // Note that the lower bound is always <= 0; // and the upper bound is always >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:288,Usability,simpl,simplify,288,"// Computes the upper and lower bounds for level K; // using the = direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^=_k = (A_k - B_k)^- (U_k - L_k) + (A_k - B_k)L_k; // UB^=_k = (A_k - B_k)^+ (U_k - L_k) + (A_k - B_k)L_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^=_k = (A_k - B_k)^- U_k; // UB^=_k = (A_k - B_k)^+ U_k; //; // We must be careful to handle the case where the upper bound is unknown.; // Note that the lower bound is always <= 0; // and the upper bound is always >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:324,Usability,simpl,simplify,324,"// Computes the upper and lower bounds for level K; // using the < direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; // UB^<_k = (A^+_k - B_k)^+ (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 1) - B_k; // UB^<_k = (A^+_k - B_k)^+ (U_k - 1) - B_k; //; // We must be careful to handle the case where the upper bound is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:324,Usability,simpl,simplify,324,"// Computes the upper and lower bounds for level K; // using the > direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^>_k = (A_k - B^+_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k + A_k N_k; // UB^>_k = (A_k - B^-_k)^+ (U_k - L_k - N_k) + (A_k - B_k)L_k + A_k N_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^>_k = (A_k - B^+_k)^- (U_k - 1) + A_k; // UB^>_k = (A_k - B^-_k)^+ (U_k - 1) + A_k; //; // We must be careful to handle the case where the upper bound is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:119,Testability,test,test,119,"//===----------------------------------------------------------------------===//; // Constraint manipulation for Delta test.; // Given a linear SCEV,; // return the coefficient (the step); // corresponding to the specified loop.; // If there isn't one, return 0.; // For example, given a*i + b*j + c*k, finding the coefficient; // corresponding to the j loop would yield b.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Integrability,depend,dependence,234,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:333,Integrability,Depend,Dependence,333,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:344,Testability,Test,Testing,344,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Usability,simpl,simplify,60,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:125,Usability,simpl,simplification,125,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:159,Usability,simpl,simplification,159,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:220,Integrability,depend,dependence,220,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:111,Usability,simpl,simplification,111,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:145,Usability,simpl,simplification,145,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Integrability,depend,dependence,216,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:107,Usability,simpl,simplification,107,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:141,Usability,simpl,simplification,141,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:108,Usability,simpl,simplification,108,// Attempt to propagate a point; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,Update,Update,3,// Update direction vector entry based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Integrability,depend,dependence,57,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:104,Integrability,depend,dependence,104,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:68,Testability,test,test,68,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:115,Testability,test,test,115,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:87,Security,access,accessed,87,/// Try to delinearize \p SrcAccessFn and \p DstAccessFn if the underlying; /// arrays accessed are fixed-size arrays. Return true if delinearization was; /// successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Availability,recover,recovered,58,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:24,Safety,safe,safely,24,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Safety,recover,recovered,58,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:27,Security,access,access,27,// Third step: compute the access functions for each subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Security,access,access,60,// Fail when there is only a subscript: that's a linearized access function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:339,Integrability,depend,dependency,339,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:169,Safety,safe,safe,169,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Integrability,depend,dependencies,20,// Check transitive dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,depends,3,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:81,Integrability,Depend,Dependence,81,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Integrability,Depend,Dependence,188,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:283,Integrability,rout,routine,283,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:355,Integrability,rout,routine,355,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:199,Testability,Test,Testing,199,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:59,Integrability,depend,dependence,59,"// if both instructions don't reference memory, there's no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:27,Performance,load,loads,27,"// can only analyze simple loads and stores, i.e., no calls, invokes, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Usability,simpl,simple,20,"// can only analyze simple loads and stores, i.e., no calls, invokes, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,Security,access,accesses,46,"// If the objects noalias, they are distinct, accesses are independent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:51,Integrability,depend,dependence,51,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:38,Security,access,accesses,38,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:33,Testability,test,test,33,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test separable subscripts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test coupled subscript groups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test & propagate remaining RDIVs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test remaining MIVs; // This code is temporary.; // Better to somehow test all remaining subscripts simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:73,Testability,test,test,73,// test remaining MIVs; // This code is temporary.; // Better to somehow test all remaining subscripts simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,update,update,3,// update Result.DV from constraint vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:129,Integrability,depend,dependence,129,"// Make sure the LoopIndependent flag is set correctly.; // All directions must include equal, otherwise no; // loop-independent dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:86,Integrability,depend,dependence,86,"// On the other hand, if all directions are equal and there's no; // loop-independent dependence possible, then no dependence exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:115,Integrability,depend,dependence,115,"// On the other hand, if all directions are equal and there's no; // loop-independent dependence possible, then no dependence exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:305,Integrability,depend,dependence,305,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:367,Integrability,depend,dependence,367,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:526,Integrability,rout,routine,526,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:545,Integrability,depend,depends,545,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:579,Integrability,depend,dependence,579,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:627,Integrability,depend,dependence,627,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:701,Integrability,depend,dependences,701,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:881,Integrability,depend,dependences,881,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1028,Integrability,depend,dependences,1028,"---------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1558,Integrability,depend,dependence,1558,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1642,Integrability,depend,dependence,1642,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1695,Integrability,depend,dependence,1695,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1822,Integrability,depend,dependence,1822,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1994,Integrability,depend,dependence,1994,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1591,Performance,load,load,1591,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:212,Testability,test,test,212,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Testability,test,test,316,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1632,Testability,test,test,1632,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:333,Usability,simpl,simplified,333,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test separable subscripts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test coupled subscript groups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:7,Integrability,Depend,DependenceGraphBuilder,7,"//===- DependenceGraphBuilder.cpp ------------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file implements common steps of the build algorithm for construction; // of dependence graphs such as DDG and PDG.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:460,Integrability,depend,dependence,460,"//===- DependenceGraphBuilder.cpp ------------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file implements common steps of the build algorithm for construction; // of dependence graphs such as DDG and PDG.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,Availability,redundant,redundant,629,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:653,Integrability,depend,depending,653,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,Safety,redund,redundant,629,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:20,Usability,usab,usable,20,// To make the enum usable as an array index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:45,Availability,redundant,redundant,45,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:30,Safety,avoid,avoid,30,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:45,Safety,redund,redundant,45,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:140,Usability,simpl,simply,140,"// In the case of loops, the scope of the subgraph is all the; // basic blocks (and instructions within them) belonging to the loop. We; // simply ignore all the edges coming from (or going into) instructions; // or basic blocks outside of this range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,Availability,redundant,redundant,50,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:8,Integrability,depend,dependencies,8,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,Safety,redund,redundant,50,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:16,Integrability,depend,dependence,16,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:154,Integrability,depend,dependence,154,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:211,Integrability,depend,dependencies,211,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating duplicate edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:365,Availability,avail,available,365,"// This algorithm works by first collecting a set of candidate nodes that have; // an out-degree of one (in terms of def-use edges), and then ignoring those; // whose targets have an in-degree more than one. Each node in the resulting; // set can then be merged with its corresponding target and put back into the; // worklist until no further merge candidates are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:91,Deployability,update,updated,91,// Insert an element into the in-degree map and initialize to zero. The; // count will get updated in the next step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:50,Performance,load,loadable,50,"//===- DevelopmentModeInlineAdvisor.cpp - runtime-loadable model runner --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner using TFLite, allowing the; // loading of a model from a command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:449,Performance,load,loading,449,"//===- DevelopmentModeInlineAdvisor.cpp - runtime-loadable model runner --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner using TFLite, allowing the; // loading of a model from a command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:156,Testability,log,logged,156,"R""(Path to SavedModel from the previous training iteration.; The directory is also expected to contain a JSON specification of the ; outputs expected to be logged, where the first entry must be the ; inlining decision. The file containing the specification should be ; called output_spec.json. The expected JSON value is an array of ; dictionaries. Each dictionary should have 2 keys: . - ""tensor_spec, followed by the TensorSpec description of the; output; and ; - ""logging_name"", a string indicating the name to use when; logging the output values. . Example:; [; {; ""logging_name"" : ""some_name"", ; ""tensor_spec"" : { ; ""name"" : ""model_name"", ; ""port"" : 0,; ""shape"" : [2, 3],; ""type"" : ""float""; }; }; ]. The first value must always correspond to the decision.)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:524,Testability,log,logging,524,"R""(Path to SavedModel from the previous training iteration.; The directory is also expected to contain a JSON specification of the ; outputs expected to be logged, where the first entry must be the ; inlining decision. The file containing the specification should be ; called output_spec.json. The expected JSON value is an array of ; dictionaries. Each dictionary should have 2 keys: . - ""tensor_spec, followed by the TensorSpec description of the; output; and ; - ""logging_name"", a string indicating the name to use when; logging the output values. . Example:; [; {; ""logging_name"" : ""some_name"", ; ""tensor_spec"" : { ; ""name"" : ""model_name"", ; ""port"" : 0,; ""shape"" : [2, 3],; ""type"" : ""float""; }; }; ]. The first value must always correspond to the decision.)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:80,Availability,error,error,80,"/// What actually happened. This would be 'false' in the case of an inline; /// error, even if AdvisedDecision were true, otherwise it agrees with; /// AdvisedDecision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:4,Testability,Log,Log,4,/// Log one inlining event.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:16,Usability,clear,clearly,16,"/// Set these 2 clearly OOB, to make sure we set them later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:951,Deployability,release,release,951,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1081,Deployability,release,release,1081,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1124,Deployability,release,release,1124,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1385,Deployability,release,release,1385,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:908,Security,validat,validation,908,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1144,Security,validat,validate,1144,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:229,Testability,log,logs,229,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:318,Testability,log,logs,318,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:493,Testability,log,logs,493,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:752,Testability,log,logs,752,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:864,Testability,log,logging,864,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:98,Testability,log,logging,98,"/// A variant of MLInlineAdvice that tracks all non-trivial inlining; /// decisions, for training/logging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:4,Testability,Log,Log,4,/// Log one inlining event.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:52,Testability,log,logging,52,// We cannot have the case of neither inference nor logging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:2,Testability,Log,Logger,2,/*Logger=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:2,Testability,Log,Logger,2,/*Logger=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp:277,Usability,clear,clearer,277,"// TODO: This code is very similar to findAffectedValues() in; // AssumptionCache, but currently specialized to just the patterns that; // computeKnownBits() supports, and without the notion of result elem indices; // that are AC specific. Deduplicate this code once we have a clearer picture; // of how much they can be shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:647,Availability,avail,available,647,"//===- DomPrinter.cpp - DOT printer for the dominance trees ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines '-dot-dom' and '-dot-postdom' analysis passes, which emit; // a dom.<fnname>.dot or postdom.<fnname>.dot file for each function in the; // program, with a graph of the dominance/postdominance tree of that; // function.; //; // There are also passes available to directly call dotty ('-view-dom' or; // '-view-postdom'). By appending '-only' like '-dot-dom-only' only the; // names of the bbs are printed, but the content is hidden.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:49,Deployability,Update,Updater,49,"//===- DomTreeUpdater.cpp - DomTree/Post DomTree Updater --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DomTreeUpdater class, which provides a uniform way; // to update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:466,Deployability,update,update,466,"//===- DomTreeUpdater.cpp - DomTree/Post DomTree Updater --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DomTreeUpdater class, which provides a uniform way; // to update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:11,Deployability,update,updates,11,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:185,Deployability,update,update,185,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:217,Deployability,update,updates,217,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:253,Deployability,update,update,253,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:32,Deployability,update,update,32,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:56,Deployability,update,updates,56,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:70,Deployability,update,update,70,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:149,Deployability,update,update,149,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:14,Deployability,update,updates,14,// Only apply updates not are applied by DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:14,Deployability,update,updates,14,// Only apply updates not are applied by PostDomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:57,Deployability,Update,UpdateStrategy,57,"// After calling deleteBB or callbackDeleteBB under Lazy UpdateStrategy,; // validateDeleteBB() removes all instructions of DelBB and adds an; // UnreachableInst as its terminator. So we check whether the BasicBlock to; // delete only has an UnreachableInst inside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:77,Security,validat,validateDeleteBB,77,"// After calling deleteBB or callbackDeleteBB under Lazy UpdateStrategy,; // validateDeleteBB() removes all instructions of DelBB and adds an; // UnreachableInst as its terminator. So we check whether the BasicBlock to; // delete only has an UnreachableInst inside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:113,Availability,avail,available,113,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:80,Deployability,Update,UpdateStrategy,80,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:19,Performance,perform,performance,19,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:3,Usability,Resume,Resume,3,// Resume forceFlushDeletedBB() to erase DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:47,Deployability,update,updates,47,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:80,Deployability,update,update,80,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:165,Deployability,Update,UpdateStrategy,165,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:198,Deployability,Update,UpdateStrategy,198,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:35,Deployability,update,updates,35,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:82,Deployability,update,updates,82,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:194,Deployability,update,update,194,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:236,Deployability,update,update,236,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:323,Deployability,update,update,323,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:520,Deployability,update,updates,520,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:617,Deployability,update,updates,617,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:741,Deployability,update,updates,741,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:997,Deployability,update,update,997,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:1146,Deployability,update,update,1146,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:140,Safety,safe,safe,140,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:720,Safety,safe,safely,720,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:10,Deployability,update,update,10,"// If the update doesn't appear in the CFG, it means that; // either the change isn't made or relevant operations; // result in a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:12,Deployability,update,updates,12,// Drop all updates applied by both trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:179,Deployability,update,updated,179,"// For BBs that are likely to change, we subtract from feature totals their; // contribution. Some features, like max loop counts or depths, are left; // invalid, as they will be updated post-inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:385,Availability,down,down,385,"// Update feature values from the BBs that were copied from the callee, or; // might have been modified because of inlining. The latter have been; // subtracted in the FunctionPropertiesUpdater ctor.; // There could be successors that were reached before but now are only; // reachable from elsewhere in the CFG.; // One example is the following diamond CFG (lines are arrows pointing down):; // A; // / \; // B C; // | |; // | D; // | |; // | E; // \ /; // F; // There's a call site in C that is inlined. Upon doing that, it turns out; // it expands to; // call void @llvm.trap(); // unreachable; // F isn't reachable from C anymore, but we did discount it when we set up; // FunctionPropertiesUpdater, so we need to re-include it here.; // At the same time, D and E were reachable before, but now are not anymore,; // so we need to leave D out (we discounted it at setup), and explicitly; // remove E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:3,Deployability,Update,Update,3,"// Update feature values from the BBs that were copied from the callee, or; // might have been modified because of inlining. The latter have been; // subtracted in the FunctionPropertiesUpdater ctor.; // There could be successors that were reached before but now are only; // reachable from elsewhere in the CFG.; // One example is the following diamond CFG (lines are arrows pointing down):; // A; // / \; // B C; // | |; // | D; // | |; // | E; // \ /; // F; // There's a call site in C that is inlined. Upon doing that, it turns out; // it expands to; // call void @llvm.trap(); // unreachable; // F isn't reachable from C anymore, but we did discount it when we set up; // FunctionPropertiesUpdater, so we need to re-include it here.; // At the same time, D and E were reachable before, but now are not anymore,; // so we need to leave D out (we discounted it at setup), and explicitly; // remove E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:198,Performance,perform,perform,198,"// For reinclusion, we want to stop at the reachable successors, who are at; // the beginning of the worklist; but, starting from the callsite bb and; // ending at those successors, we also want to perform a traversal.; // IncludeSuccessorsMark is the index after which we include successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:27,Usability,Simpl,Simple,27,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:388,Usability,simpl,simple,388,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:584,Usability,simpl,simple,584,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:590,Performance,perform,performance,590,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:689,Performance,perform,performance,689,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:23,Safety,unsafe,unsafe,23,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:390,Safety,unsafe,unsafe,390,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:12,Integrability,wrap,wrapper,12,"/// Build a wrapper struct that has 8-byte alignment. All heap allocations; /// should provide this much alignment at least, but this makes it clear we; /// specifically rely on this amount of alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:143,Usability,clear,clear,143,"/// Build a wrapper struct that has 8-byte alignment. All heap allocations; /// should provide this much alignment at least, but this makes it clear we; /// specifically rely on this amount of alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:219,Availability,mask,masks,219,/// The bit that flags that this function may read any global. This is; /// chosen to mix together with ModRefInfo bits.; /// FIXME: This assumes ModRefInfo lattice will remain 4 bits!; /// FunctionInfo.getModRefInfo() masks out everything except ModRef so; /// this remains correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:16,Usability,clear,clears,16,/// This method clears MayReadAnyGlobal bit added by GlobalsAAResult to return; /// the corresponding ModRefInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:54,Modifiability,variab,variable,54,"/// Returns whether this function may read any global variable, and we don't; /// know which global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:4,Usability,Clear,Clear,4,/// Clear a global's ModRef info. Should be used when a global is being; /// deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:7,Usability,clear,clear,7,// And clear out the handle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Safety,Detect,Detect,3,// Detect calls to free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:72,Usability,simpl,simple,72,"// In general, we return true for unknown calls, but there are; // some simple checks that we can do for functions that; // will never call back into the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:71,Modifiability,variab,variable,71,"/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable; /// which holds a pointer type. See if the global always points to non-aliased; /// heap memory: that is, all initializers of the globals store a value known; /// to be obtained via a noalias return function call which have no other use.; /// Further, all loads out of GV must directly use the memory, not store the; /// pointer somewhere. If this is true, we consider the memory pointed to by; /// GV to be owned by GV and can disambiguate other pointers from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:337,Performance,load,loads,337,"/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable; /// which holds a pointer type. See if the global always points to non-aliased; /// heap memory: that is, all initializers of the globals store a value known; /// to be obtained via a noalias return function call which have no other use.; /// Further, all loads out of GV must directly use the memory, not store the; /// pointer somewhere. If this is true, we consider the memory pointed to by; /// GV to be owned by GV and can disambiguate other pointers from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:81,Performance,load,load,81,"// Walk the user list of the global. If we find anything other than a direct; // load or store, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:15,Performance,load,loaded,15,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:105,Performance,load,loading,105,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:162,Performance,load,loaded,162,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:58,Usability,simpl,simple,58,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Performance,Load,Loaded,3,// Loaded pointer escapes.; // TODO: Could try some IP mod/ref of the loaded pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:70,Performance,load,loaded,70,// Loaded pointer escapes.; // TODO: Could try some IP mod/ref of the loaded pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:101,Usability,simpl,simple,101,// Too hard to analyze.; // Analyze all uses of the allocation. If any of them are used in a; // non-simple way (e.g. stored to another global) bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Performance,Load,Loaded,3,// Loaded pointer escapes.; // Remember that this allocation is related to the indirect global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:30,Integrability,synchroniz,synchronizing,30,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:326,Security,access,accesses,326,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:41,Performance,load,loads,41,// Scan the function bodies for explicit loads or stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:235,Security,hash,hash,235,"// Finally, now that we know the full effect on this SCC, clone the; // information to each function in the SCC.; // FI is a reference into FunctionInfos, so copy it now so that it doesn't; // get invalidated if DenseMap decides to re-hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:69,Performance,load,loaded,69,"// GV is a non-escaping global. V is a pointer address that has been loaded from.; // If we can prove that V must escape, we can conclude that a load from V cannot; // alias GV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:145,Performance,load,load,145,"// GV is a non-escaping global. V is a pointer address that has been loaded from.; // If we can prove that V must escape, we can conclude that a load from V cannot; // alias GV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:187,Performance,load,loads,187,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:216,Safety,safe,safe,216,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:48,Performance,load,loads,48,"// Recurse through a limited number of selects, loads and PHIs. This is an; // arbitrary depth of 4, lower numbers could be used to fix compile time; // issues if needed, but this is generally expected to be only be important; // for small depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1344,Modifiability,variab,variables,1344,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1394,Modifiability,variab,variable,1394,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1570,Modifiability,variab,variables,1570,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:466,Performance,load,loading,466,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1182,Performance,optimiz,optimization,1182,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:558,Safety,safe,safe,558,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1440,Security,expose,expose,1440,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:200,Performance,load,load,200,"// In order to know that the underlying object cannot alias the; // non-addr-taken global, we must know that it would have to be an escape.; // Thus if the underlying object is a function argument, a load from; // a global, or the return of a function, it cannot alias. We can also; // recurse through PHI nodes and select nodes provided all of their inputs; // resolve to one of these known-escaping roots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:48,Performance,load,loads,48,"// Recurse through a limited number of selects, loads and PHIs. This is an; // arbitrary depth of 4, lower numbers could be used to fix compile time; // issues if needed, but this is generally expected to be only be important; // for small depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:13,Performance,load,loaded,13,"// A pointer loaded from a global would have been captured, and we know; // that the global is non-escaping, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:7,Performance,load,load,7,// The load does not alias with GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:16,Performance,load,load,16,"// Otherwise, a load could come from anywhere, so bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:89,Usability,clear,clear,89,"// FIXME: It would be good to handle other obvious no-alias cases here, but; // it isn't clear how to do so reasonably without building a small version; // of BasicAA into this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:106,Performance,perform,performance,106,"// If one is and the other isn't, it isn't strictly safe but we can fake; // this result if necessary for performance. This does not appear to be; // a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:52,Safety,safe,safe,52,"// If one is and the other isn't, it isn't strictly safe but we can fake; // this result if necessary for performance. This does not appear to be; // a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:97,Security,access,accesses,97,"// Otherwise if they are both derived from the same addr-taken global, we; // can't know the two accesses don't overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:171,Performance,load,load,171,"// These pointers may be based on the memory owned by an indirect global. If; // so, we may be able to handle this. First check to see if the base pointer; // is a direct load from an indirect global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:134,Performance,perform,performance,134,"// If one is based on an indirect global and the other isn't, it isn't; // strictly safe but we can fake this result if necessary for performance.; // This does not appear to be a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:84,Safety,safe,safe,84,"// If one is based on an indirect global and the other isn't, it isn't; // strictly safe but we can fake this result if necessary for performance.; // This does not appear to be a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Deployability,Update,Update,3,// Update the parent for each DeletionCallbackHandle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp:402,Performance,perform,perform,402,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp:12,Safety,avoid,avoid,12,"// We could avoid second lookup, but it would make the code ultra ugly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp:531,Availability,avail,available,531,"//===-- IndirectCallPromotionAnalysis.cpp - Find promotion candidates ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Helper methods for identifying profitable indirect call promotion; // candidates for an instruction when the indirect-call value profile metadata; // is available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:23,Integrability,message,messages,23,/// Flag to add inline messages as callsite attributes 'inline-remark'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:498,Availability,avail,available,498,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:10,Safety,detect,detect,10,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:764,Testability,log,logic,764,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:71,Safety,avoid,avoiding,71,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:258,Safety,avoid,avoid,258,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:307,Safety,avoid,avoid,307,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,Security,expose,exposed,132,// InlineSavingsMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:159,Testability,test,testing,159,// InlineSavingsMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:142,Security,expose,exposed,142,// InlineSavingsProfitableMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:169,Testability,test,testing,169,// InlineSavingsProfitableMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Performance,perform,performance,39,// We introduce this threshold to help performance of instrumentation based; // PGO before we actually hook up inliner with analysis passes such as BPI and; // BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:296,Integrability,wrap,wrapper,296,"/// Carry out call site analysis, in order to evaluate inlinability.; /// NOTE: the type is currently used as implementation detail of functions such; /// as llvm::getInlineCost. Note the function_ref constructor parameters - the; /// expectation is that they come from the outer scope, from the wrapper; /// functions. If we want to support constructing CallAnalyzer objects where; /// lambdas are provided inline at construction, or where the object needs to; /// otherwise survive past the scope of the provided functions, we need to; /// revisit the argument types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Availability,avail,available,28,/// The TargetTransformInfo available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Performance,cache,cache,19,/// Getter for the cache of @llvm.assume intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Performance,Cache,Cache,3,// Cache the DataLayout since we use it a lot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:34,Availability,avail,available,34,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,Performance,Optimiz,OptimizationRemarkEmitter,8,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:158,Performance,cache,cacheable,158,"/// The candidate callsite being analyzed. Please do not use this to do; /// analysis in the caller function; we want the inline cost query to be; /// easily cacheable. Instead, use the cover function paramHasAttr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:42,Performance,load,load,42,/// Called the analysis engine determines load elimination won't happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Performance,load,load,28,/// Called to account for a load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:73,Performance,load,load,73,/// Called to account for the expectation the inlining would result in a load; /// elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Performance,load,load,28,/// Called to account for a load relative intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:20,Energy Efficiency,allocate,allocated,20,/// Number of bytes allocated statically by the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:99,Usability,simpl,simplified,99,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:315,Usability,simpl,simplifications,315,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:402,Usability,simpl,simplifications,402,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:124,Usability,simpl,simplified,124,/// Keep track of the values which map back (through function arguments) to; /// allocas on the caller stack which could be simplified through SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:63,Performance,optimiz,optimization,63,/// Keep track of Allocas for which we believe we may get SROA optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:38,Performance,load,loads,38,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:156,Performance,load,loads,156,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:88,Usability,simpl,simplify,88,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Integrability,rout,routines,32,// Custom simplification helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:10,Usability,simpl,simplification,10,// Custom simplification helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Integrability,rout,routines,19,// Custom analysis routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:732,Usability,simpl,simple,732,"// Considering forming a binary search, we should find the number of nodes; // which is same as the number of comparisons when lowered. For a given; // number of clusters, n, we can define a recursive function, f(n), to find; // the number of nodes in the tree. The recursion is :; // f(n) = 1 + f(n/2) + f (n - n/2), when n > 3,; // and f(n) = n, when n <= 3.; // This will lead a binary tree where the leaf should be either f(2) or f(3); // when n > 3. So, the number of comparisons from leaves should be n, while; // the number of non-leaf should be :; // 2^(log2(n) - 1) - 1; // = 2^log2(n) * 2^-1 - 1; // = n / 2 - 1.; // Considering comparisons from leaf and non-leaf nodes, we can estimate the; // number of comparisons in a simple closed form :; // n + n / 2 - 1 = n * 3 / 2 - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:107,Deployability,update,updateThreshold,107,/// Bonus to be applied when percentage of vector instructions in callee is; /// high (see more details in updateThreshold).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Deployability,Update,Update,4,/// Update Threshold based on callsite properties such as callee; /// attributes and callee hotness for PGO builds. The Callee is explicitly; /// passed to support analyzing indirect calls whose target is inferred by; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:13,Usability,simpl,simply,13,// Otherwise simply add the cost for merely making the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:143,Testability,log,logic,143,// buildInlinerPipeline in the pass builder sets HotCallSiteThreshold to 0; // for the prelink phase of the AutoFDO + ThinLTO build. Honor the logic by; // falling back to the cost-based metric.; // TODO: Improve this hacky condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:343,Modifiability,variab,variable,343,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,Safety,avoid,avoid,132,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:312,Safety,avoid,avoid,312,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:452,Safety,avoid,avoid,452,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:862,Safety,avoid,avoid,862,"// Let R be the ratio of CycleSavings to Size. We accept the inlining; // opportunity if R is really high and reject if R is really low. If R is; // somewhere in the middle, we fall back to the cost-based analysis.; //; // Specifically, let R = CycleSavings / Size, we accept the inlining; // opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R > -------------------------------------------------; // getInliningCostBenefitAnalysisSavingsMultiplier(); //; // and reject the inlining opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R <= ----------------------------------------------------; // getInliningCostBenefitAnalysisProfitableMultiplier(); //; // Otherwise, we fall back to the cost-based analysis.; //; // Implementation-wise, use multiplication (CycleSavings * Multiplier,; // HotCountThreshold * Size) rather than division to avoid precision loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:193,Performance,perform,perform,193,"// Loops generally act a lot like calls in that they act like barriers to; // movement, require a certain amount of setup, etc. So when optimising for; // size, we penalise any call sites that perform loops. We do this after all; // other costs here, so will likely only be dealing with relatively small; // functions (and hence DT and LI will hopefully be cheap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:303,Modifiability,evolve,evolved,303,"// Perform some tweaks to the cost and threshold based on the direct; // callsite information.; // We want to more aggressively inline vector-dense kernels, so up the; // threshold, and we'll lower it if the % of vector instructions gets too; // low. Note that these bonuses are some what arbitrary and evolved over; // time by accident as much as because they are principled bonuses.; //; // FIXME: It would be nice to remove all such bonuses. At least it would be; // nice to base the bonus values on something more scientific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Performance,Perform,Perform,3,"// Perform some tweaks to the cost and threshold based on the direct; // callsite information.; // We want to more aggressively inline vector-dense kernels, so up the; // threshold, and we'll lower it if the % of vector instructions gets too; // low. Note that these bonuses are some what arbitrary and evolved over; // time by accident as much as because they are principled bonuses.; //; // FIXME: It would be nice to remove all such bonuses. At least it would be; // nice to base the bonus values on something more scientific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Deployability,Update,Update,3,// Update the threshold based on callsite properties,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Integrability,depend,depends,19,"// While Threshold depends on commandline options that can take negative; // values, we want to enforce the invariant that the computed threshold and; // bonuses are non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,Integrability,depend,dependent,65,"// Prints the same analysis as dump(), but its definition is not dependent; // on the build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:135,Safety,avoid,avoid,135,// FIXME: These constants are taken from the heuristic-based cost visitor.; // These should be removed entirely in a later revision to avoid reliance on; // heuristics in the ML inliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:128,Safety,avoid,avoid,128,// FIXME: These are taken from the heuristic-based cost visitor: we should; // eventually abstract these to the CallAnalyzer to avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:35,Testability,log,logic,35,"// FIXME: we shouldn't repeat this logic in both the Features and Cost; // analyzer - instead, we should abstract it to a common method in the; // CallAnalyzer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:18,Testability,Test,Test,18,// namespace; /// Test whether the given value is an Alloca-derived function argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:154,Usability,simpl,simplified,154,/// Accumulate a constant GEP offset into an APInt if possible.; ///; /// Returns false if unable to compute the offset for any reason. Respects any; /// simplified values known during the analysis of this callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:67,Usability,simpl,simplified,67,/// Use TTI to check whether a GEP is free.; ///; /// Respects any simplified values known during the analysis of this callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:166,Safety,Avoid,Avoid,166,"// Sometimes a dynamic alloca could be converted into a static alloca; // after this constant prop, and become a huge static alloca on an; // unconditional CFG path. Avoid inlining if this is going to happen above; // a threshold.; // FIXME: If the threshold is removed or lowered too much, we could end up; // being too pessimistic and prevent inlining non-problematic code. This; // could result in unintended perf regressions. A better overall strategy; // is needed to track stack usage during inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:18,Energy Efficiency,allocate,allocated,18,// Accumulate the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:210,Usability,simpl,simply,210,"// FIXME: This is overly conservative. Dynamic allocas are inefficient for; // a variety of reasons, and so we would like to not inline them into; // functions which don't currently have a dynamic alloca. This simply; // disables inlining altogether in the presence of a dynamic alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:12,Testability,log,logic,12,"// The same logic as above, but check pointer with constant offset here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Modifiability,Variab,Variable,3,// Variable GEPs will require math and will disable SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:52,Deployability,update,update,52,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Usability,Simpl,Simplify,4,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:59,Usability,Simpl,SimplifiedValues,59,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a call to llvm.is.constant.; ///; /// Duplicate the argument checking from CallAnalyzer::simplifyCallSite since; /// we expect calls of this specific intrinsic to be infrequent.; ///; /// FIXME: Given that we know CB's parent (F) caller; /// (CandidateCall->getParent()->getParent()), we might be able to determine; /// whether inlining F into F's caller would change how the call to; /// llvm.is.constant would evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:109,Usability,simpl,simplifyCallSite,109,"/// Try to simplify a call to llvm.is.constant.; ///; /// Duplicate the argument checking from CallAnalyzer::simplifyCallSite since; /// we expect calls of this specific intrinsic to be infrequent.; ///; /// FIXME: Given that we know CB's parent (F) caller; /// (CandidateCall->getParent()->getParent()), we might be able to determine; /// whether inlining F into F's caller would change how the call to; /// llvm.is.constant would evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Integrability,wrap,wrap,39,"// Casts don't change the offset, just wrap it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:336,Usability,simpl,simplified,336,"// Does the *call site* have the NonNull attribute set on an argument? We; // use the attribute on the call site to memoize any analysis done in the; // caller. This will also trip if the callee function has a non-null; // parameter attribute, but that's a less interesting case because hopefully; // the callee would already have been simplified based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:113,Deployability,update,updated,113,// Is this an alloca in the caller? This is distinct from the attribute case; // above because attributes aren't updated within the inliner itself and we; // always want to catch the alloca derived case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Safety,predict,predict,19,// We can actually predict the result of comparisons between an; // alloca-derived value and null. Note that this fires regardless of; // SROA firing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:635,Deployability,update,updateThreshold,635,"// If the normal destination of the invoke or the parent block of the call; // site is unreachable-terminated, there is little point in inlining this; // unless there is literally zero cost.; // FIXME: Note that it is possible that an unreachable-terminated block has a; // hot entry. For example, in below scenario inlining hot_call_X() may be; // beneficial :; // main() {; // hot_call_1();; // ...; // hot_call_N(); // exit(0);; // }; // For now, we are not handling this corner case here as it is rare in real; // code. In future, we should elaborate this based on BPI and BFI in more; // general threshold adjusting heuristics in updateThreshold().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Availability,avail,available,32,"// If global profile summary is available, then callsite's coldness is; // determined based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,Availability,avail,available,31,// Otherwise we need BFI to be available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:90,Performance,cache,cache,90,"// Determine if the callsite is cold relative to caller's entry. We could; // potentially cache the computation of scaled entry frequency, but the added; // complexity is not worth it unless this scaling shows up high in the; // profiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Availability,avail,available,32,"// If global profile summary is available, then callsite's hotness is; // determined based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,Availability,avail,available,31,// Otherwise we need BFI to be available and to have a locally hot callsite; // threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:89,Performance,cache,cache,89,"// Determine if the callsite is hot relative to caller's entry. We could; // potentially cache the computation of scaled entry frequency, but the added; // complexity is not worth it unless this scaling shows up high in the; // profiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:475,Energy Efficiency,reduce,reduce,475,// Various bonus percentages. These are multiplied by Threshold to get the; // bonus values.; // SingleBBBonus: This bonus is applied if the callee has a single reachable; // basic block at the given callsite context. This is speculatively applied; // and withdrawn if more than one basic block is seen.; //; // LstCallToStaticBonus: This large bonus is applied to ensure the inlining; // of the last call to a static function as inlining such functions is; // guaranteed to reduce code size.; //; // These bonus percentages may be set to 0 based on properties of the caller; // and the callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:68,Availability,avail,available,68,// Use the OptMinSizeThreshold or OptSizeThreshold knob if they are available; // and reduce the threshold if the caller has the necessary attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:86,Energy Efficiency,reduce,reduce,86,// Use the OptMinSizeThreshold or OptSizeThreshold knob if they are available; // and reduce the threshold if the caller has the necessary attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:137,Availability,reliab,reliably,137,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:348,Availability,avail,available,348,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:63,Testability,log,logic,63,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:50,Usability,simpl,simplify,50,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:22,Deployability,update,update,22,"// FIXME: This should update the threshold only if it exceeds the; // current threshold, but AutoFDO + ThinLTO currently relies on this; // behavior to prevent inlining of hot callsites during ThinLTO; // compile phase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:142,Deployability,update,update,142,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:161,Deployability,update,updateThreshold,161,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:192,Integrability,depend,depends,192,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:207,Testability,log,logic,207,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:23,Usability,simpl,simplified,23,// First try to handle simplified comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,Usability,simpl,simplify,65,"// If the comparison is an equality comparison with null, we can simplify it; // if we know the value (argument) can't be null",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:101,Usability,simpl,simplified,101,// Implicit null checks act as unconditional branches and their comparisons; // should be treated as simplified and free of cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Testability,log,logic,39,"// Otherwise, fall back to the generic logic for simplifying and handling; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:49,Usability,simpl,simplifying,49,"// Otherwise, fall back to the generic logic for simplifying and handling; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Availability,redundant,redundant,131,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:26,Performance,load,loaded,26,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:110,Performance,load,load,110,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Safety,redund,redundant,131,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:37,Performance,load,loads,37,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:64,Performance,load,loads,64,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:167,Performance,load,loads,167,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:104,Usability,simpl,simplify,104,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:211,Usability,simpl,simplified,211,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:173,Performance,perform,performed,173,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:33,Testability,log,logic,33,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:150,Usability,simpl,simplifications,150,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,Safety,abort,aborts,8,// This aborts the entire analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:50,Usability,simpl,simplify,50,"// When we have a concrete function, first try to simplify it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:24,Safety,abort,abort,24,"// This flag will fully abort the analysis, so don't bother with anything; // else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:171,Safety,predict,predictable,171,"// We model unconditional branches as essentially free -- they really; // shouldn't exist at all, but handling them makes the behavior of the; // inliner more regular and predictable. Interestingly, conditional branches; // which will fold away are also free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:51,Usability,simpl,simplified,51,// Condition is either all 1s or all 0s. SI can be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:653,Performance,optimiz,optimization,653,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:94,Testability,test,test,94,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:305,Testability,test,test,305,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:550,Usability,simpl,simplifycfg,550,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:406,Safety,safe,safely,406,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this; // indirect jump would jump from the inlined copy of the function into the; // original function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions with; // indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:373,Testability,log,logic,373,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this; // indirect jump would jump from the inlined copy of the function into the; // original function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions with; // indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:101,Usability,resume,resume,101,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a cleanupret instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a catchret instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:231,Safety,abort,aborts,231,"/// Analyze a basic block for its contribution to the inline cost.; ///; /// This method walks the analyzer over every instruction in the given basic; /// block and accounts for their cost during inlining at this callsite. It; /// aborts early if the threshold has been exceeded or an impossible to inline; /// construct has been detected. It returns false if inlining is no longer; /// viable, and true if inlining remains viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:330,Safety,detect,detected,330,"/// Analyze a basic block for its contribution to the inline cost.; ///; /// This method walks the analyzer over every instruction in the given basic; /// block and accounts for their cost during inlining at this callsite. It; /// aborts early if the threshold has been exceeded or an impossible to inline; /// construct has been detected. It returns false if inlining is no longer; /// viable, and true if inlining remains viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:95,Usability,simpl,simplify,95,"// FIXME: Currently, the number of instructions in a function regardless of; // our ability to simplify them during inline to constants or dead code,; // are actually used by the vector bonus heuristic. As long as that's true,; // we have to special case debug intrinsics here to prevent differences in; // inlining due to debug symbols. Eventually, the number of unsimplified; // instructions shouldn't factor into the cost computation, but until then,; // hack around it here.; // Similarly, skip pseudo-probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:181,Testability,log,logic,181,"// If the instruction simplified to a constant, there is no cost to this; // instruction. Visit the instructions using our InstVisitor to account for; // all of the per-instruction logic. The visit tree returns true if we; // consumed the instruction in any way, and false if the instruction's base; // cost should count against inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:22,Usability,simpl,simplified,22,"// If the instruction simplified to a constant, there is no cost to this; // instruction. Visit the instructions using our InstVisitor to account for; // all of the per-instruction logic. The visit tree returns true if we; // consumed the instruction in any way, and false if the instruction's base; // cost should count against inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:33,Safety,detect,detected,33,"// If the visit this instruction detected an uninlinable pattern, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:66,Safety,abort,abort,66,"// If the visit this instruction detected an uninlinable pattern, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:90,Energy Efficiency,allocate,allocate,90,// If the caller is a recursive function then we don't want to inline; // functions which allocate a lot of stack space because it would increase; // the caller stack usage dramatically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:388,Integrability,rout,routine,388,"/// Analyze a call site for potential inlining.; ///; /// Returns true if inlining this call is viable, and false if it is not; /// viable. It computes the cost and adjusts the threshold based on numerous; /// factors and heuristics. If this method returns false but the computed cost; /// is below the computed threshold, then inlining was forcibly disabled by; /// some artifact of the routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:16,Usability,simpl,simplified,16,// Populate our simplified values by mapping from function arguments to call; // arguments with known important simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:112,Usability,simpl,simplifications,112,// Populate our simplified values by mapping from function arguments to call; // arguments with known important simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:507,Performance,optimiz,optimized,507,"// The worklist of live basic blocks in the callee *after* inlining. We avoid; // adding basic blocks of the callee which can be proven to be dead for this; // particular call site in order to get more accurate cost estimates. This; // requires a somewhat heavyweight iteration pattern: we need to walk the; // basic blocks in a breadth-first order as we insert live successors. To; // accomplish this, prioritizing for small iterations because we exit after; // crossing our threshold, we use a small-size optimized SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:72,Safety,avoid,avoid,72,"// The worklist of live basic blocks in the callee *after* inlining. We avoid; // adding basic blocks of the callee which can be proven to be dead for this; // particular call site in order to get more accurate cost estimates. This; // requires a somewhat heavyweight iteration pattern: we need to walk the; // basic blocks in a breadth-first order as we insert live successors. To; // accomplish this, prioritizing for small iterations because we exit after; // crossing our threshold, we use a small-size optimized SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:27,Performance,cache,cache,27,"// Note that we *must not* cache the size, this loop grows the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:405,Modifiability,variab,variable,405,"// Disallow inlining a blockaddress with uses other than strictly callbr.; // A blockaddress only has defined behavior for an indirect branch in the; // same function, and we do not currently support inlining indirect; // branches. But, the inliner may not see an indirect branch that ends up; // being dead code at a particular call site. If the blockaddress escapes; // the function, e.g., via a global variable, inlining may lead to an; // invalid cross-function reference.; // FIXME: pr/39560: continue relaxing this overt restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:91,Usability,simpl,simplified,91,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:122,Usability,simpl,simplified,122,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Testability,Test,Test,4,/// Test that there are no attribute conflicts between Caller and Callee; /// that prevent inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:83,Performance,cache,caches,83,"// Note that CalleeTLI must be a copy not a reference. The legacy pass manager; // caches the most recently created TLI in the TargetLibraryInfoWrapperPass; // object, and always returns the same object (which is overwritten on each; // GetTLI call). Therefore we copy the first result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Performance,load,loads,32,// We approximate the number of loads and stores needed by dividing the; // size of the byval type by the target's pointer size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:316,Availability,avail,available,316,"// If it generates more than 8 stores it is likely to be expanded as an; // inline memcpy so we take that as an upper bound. Otherwise we assume; // one load and one store per word copied.; // FIXME: The maxStoresPerMemcpy setting from the target should be used; // here instead of a magic number of 8, but it's not available via; // DataLayout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:153,Performance,load,load,153,"// If it generates more than 8 stores it is likely to be expanded as an; // inline memcpy so we take that as an upper bound. Otherwise we assume; // one load and one store per word copied.; // FIXME: The maxStoresPerMemcpy setting from the target should be used; // here instead of a magic number of 8, but it's not available via; // DataLayout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:44,Usability,simpl,simply,44,"// No details on how the decision was made, simply return always or never.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:24,Security,expose,expose,24,// Disallow calls which expose returns-twice to a function not previously; // attributed as such.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:110,Performance,optimiz,optimization,110,"// This field is the threshold to use for a callee by default. This is; // derived from one or more of:; // * optimization or size-optimization levels,; // * a value passed to createFunctionInliningPass function, or; // * the -inline-threshold flag.; // If the -inline-threshold flag is explicitly specified, that is used; // irrespective of anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Performance,optimiz,optimization,131,"// This field is the threshold to use for a callee by default. This is; // derived from one or more of:; // * optimization or size-optimization levels,; // * a value passed to createFunctionInliningPass function, or; // * the -inline-threshold flag.; // If the -inline-threshold flag is explicitly specified, that is used; // irrespective of anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:234,Performance,optimiz,optimization,234,"// If the -locally-hot-callsite-threshold is explicitly specified, use it to; // populate LocallyHotCallSiteThreshold. Later, we populate; // Params.LocallyHotCallSiteThreshold from -locally-hot-callsite-threshold if; // we know that optimization level is O3 (in the getInlineParams variant that; // takes the opt and size levels).; // FIXME: Remove this check (and make the assignment unconditional) after; // addressing size regression issues at O2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:134,Energy Efficiency,reduce,reduce,134,"// We prioritize call sites in the dictionary order of the following; // priorities:; //; // 1. Those call sites that are expected to reduce the caller size when; // inlined. Within them, we prioritize those call sites with bigger; // reduction.; //; // 2. Those call sites that have gone through the cost-benefit analysis.; // Currently, they are limited to hot call sites. Within them, we; // prioritize those call sites with higher benefit-to-cost ratios.; //; // 3. Remaining call sites are prioritized according to their costs.; // We add back StaticBonusApplied to determine whether we expect the caller; // to shrink (even if we don't delete the callee).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:10,Energy Efficiency,reduce,reduces,10,"// If one reduces the caller size while the other doesn't, then return; // true iff P1 reduces the caller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:87,Energy Efficiency,reduce,reduces,87,"// If one reduces the caller size while the other doesn't, then return; // true iff P1 reduces the caller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:16,Energy Efficiency,reduce,reduce,16,"// If they both reduce the caller size, pick the one with the smaller; // cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:158,Deployability,update,update,158,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:353,Deployability,update,updated,353,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:415,Usability,simpl,simplicity,415,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:451,Usability,learn,learning,451,"//===- InlineSizeEstimatorAnalysis.cpp - IR to native size from ML model --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements feature and label extraction for offline supervised learning; // of a IR to native size model.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:115,Availability,avail,available,115,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:341,Availability,avail,available,341,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:176,Performance,perform,performance,176,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:567,Energy Efficiency,efficient,efficiently,567,"//===-- InstructionPrecedenceTracking.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:965,Performance,cache,cached,965,"//===-- InstructionPrecedenceTracking.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:42,Performance,cache,cache,42,"// If there is a bug connected to invalid cache, turn on ExpensiveAsserts to; // catch this situation as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:34,Performance,cache,cached,34,// Bail if we don't have anything cached for this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:40,Performance,cache,cached,40,// Check that for every known block the cached value is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:33,Usability,clear,clearing,33,// The map should be valid after clearing (at least empty).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:161,Safety,avoid,avoid,161,"// If a block's instruction doesn't always pass the control to its successor; // instruction, mark the block as having implicit control flow. We use them; // to avoid wrong assumptions of sort ""if A is executed and B post-dominates; // A, then B is also executed"". This is not true is there is an implicit; // control flow instruction (e.g. a guard) between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:404,Integrability,rout,routines,404,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:838,Testability,log,logic,838,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:443,Usability,simpl,simpler,443,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:774,Usability,simpl,simplified,774,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:823,Usability,simpl,simplifies,823,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:871,Usability,simpl,simplified,871,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify comparison with true or false branch of select:; /// %sel = select i1 %cond, i32 %tv, i32 %fv; /// %cmp = icmp sle i32 %sel, %rhs; /// Compose new comparison by substituting %sel with either %tv or %fv; /// and see if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:234,Usability,simpl,simplifies,234,"/// Simplify comparison with true or false branch of select:; /// %sel = select i1 %cond, i32 %tv, i32 %fv; /// %cmp = icmp sle i32 %sel, %rhs; /// Compose new comparison by substituting %sel with either %tv or %fv; /// and see if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:8,Usability,simpl,simplified,8,// %cmp simplified to the select condition (%cond).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Usability,simpl,simplify,13,"// It didn't simplify. However, if composed comparison is equivalent; // to the select condition (%cond) then we can replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify comparison with true branch of select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify comparison with false branch of select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:105,Integrability,rout,routine,105,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:126,Testability,log,logical,126,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplified,59,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:134,Usability,simpl,simplifications,134,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:266,Safety,safe,safe,266,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:22,Usability,simpl,simplified,22,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:158,Usability,simpl,simplified,158,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Usability,simpl,simplified,21,"// If the true value simplified to true, then the result of the compare; // is equal to ""Cond || FCmp"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplified,31,"// Finally, if the false value simplified to true and the true value to; // false, then the result of the compare is equal to ""!Cond"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:48,Testability,test,test,48,// If we have a DominatorTree then do a precise test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a binary operator of form ""V op OtherOp"" where V is; /// ""(B0 opex B1)"" by distributing 'op' across 'opex' as; /// ""(B0 op OtherOp) opex (B1 op OtherOp)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplify,36,// Does the expanded pair of binops simplify to the existing binop?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Usability,simpl,simplifies,37,"// Otherwise, return ""L op' R"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify binops of form ""A op (B op' C)"" or the commuted variant by; /// distributing op over op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:12,Usability,simpl,simplifications,12,"/// Generic simplifications for associative binary operations.; /// Returns the simpler value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:80,Usability,simpl,simpler,80,"/// Generic simplifications for associative binary operations.; /// Returns the simpler value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""A op V"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""V op C"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""V op B"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""B op V"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:91,Usability,simpl,simplify,91,"/// In the case of a binary operation with a select instruction as an operand,; /// try to simplify the binop by seeing whether evaluating it on both branches; /// of the select results in the same value. Returns the common value if so,; /// otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplified,11,"// If they simplified to the same value, then return the common value.; // If they both failed to simplify then return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:98,Usability,simpl,simplify,98,"// If they simplified to the same value, then return the common value.; // If they both failed to simplify then return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If one branch simplified to undef, return the other one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplified,59,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Usability,simpl,simplified,125,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:18,Usability,simpl,simplified,18,"// Check that the simplified value has the form ""X op Y"" where ""op"" is the; // same as the original operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Usability,simpl,simplify,25,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:128,Usability,simpl,simplified,128,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:199,Usability,simpl,simplified,199,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Usability,simpl,simplify,66,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:345,Usability,simpl,simplify,345,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:525,Usability,simpl,simplified,525,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:88,Usability,simpl,simplify,88,"// Now that we have ""cmp select(Cond, TV, FV), RHS"", analyse it.; // Does ""cmp TV, RHS"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:22,Usability,simpl,simplify,22,"// Does ""cmp FV, RHS"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If both sides simplified to the same value, then use it as the result of; // the original comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:93,Usability,simpl,simplify,93,"/// In the case of a binary operation with an operand that is a PHI instruction,; /// try to simplify the binop by seeing whether evaluating it on the incoming; /// phi values yields the same result for every value. If so returns the common; /// value, otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplify,30,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Usability,simpl,simplified,43,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:63,Usability,simpl,simplify,63,"/// In the case of a comparison with a PHI instruction, try to simplify the; /// comparison by seeing whether comparing with all of the incoming phi values; /// yields the same result every time. If so returns the common result,; /// otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplify,30,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Usability,simpl,simplified,43,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:60,Integrability,wrap,wrapping,60,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:156,Usability,clear,clearing,156,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Add over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A + select(cond, B, C)"" means evaluating; // ""A+B"" and ""A+C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A+B"" and ""A+C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Add over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A + select(cond, B, C)"" means evaluating; // ""A+B"" and ""A+C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A+B"" and ""A+C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:103,Energy Efficiency,reduce,reduce,103,"/// Test if there is a dominating equivalence condition for the; /// two operands. If there is, try to reduce the binary operation; /// between the two operands.; /// Example: Op0 - Op1 --> 0 when Op0 == Op1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Testability,Test,Test,4,"/// Test if there is a dominating equivalence condition for the; /// two operands. If there is, try to reduce the binary operation; /// between the two operands.; /// Example: Op0 - Op1 --> 0 when Op0 == Op1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplifies,59,"// (X + Y) - Z -> X + (Y - Z) or Y + (X - Z) if everything simplifies.; // For example, (X + Y) - Y -> X; (Y + X) - Y -> X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// (X + Y) - Z; // See if ""V === Y - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""X + V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""Y + V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplifies,59,"// X - (Y + Z) -> (X - Y) - Z or (X - Z) - Y if everything simplifies.; // For example, X - (X + 1) -> -1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// X - (Y + Z); // See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:44,Usability,simpl,simplifies,44,"// Z - (X - Y) -> (Z - X) + Y if everything simplifies.; // For example, X - (X - Y) -> Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// Z - (X - Y); // See if ""V === Z - X"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V + Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,Usability,simpl,simplifies,53,// trunc(X) - trunc(Y) -> trunc(X - Y) if everything simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:33,Usability,simpl,simplifies,33,"// It does! Now see if ""trunc V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:23,Usability,simpl,simplified,23,"// It does, return the simplified ""trunc V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Sub over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A - select(cond, B, C)"" means evaluating; // ""A-B"" and ""A-C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A-B"" and ""A-C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Sub over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A - select(cond, B, C)"" means evaluating; // ""A-B"" and ""A-C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A-B"" and ""A-C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:105,Energy Efficiency,reduce,reduce,105,"// mul i1 nsw is a special-case because -1 * -1 is poison (+1 is not; // representable). All other cases reduce to 0, so just return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:46,Usability,simpl,simplifications,46,// Mul distributes over Add. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:113,Usability,simpl,simplification,113,"/// Given a predicate and two operands, return true if the comparison is true.; /// This is a helper for div/rem simplification where we return some other value; /// when we can prove a relationship between the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Energy Efficiency,adapt,adapt,61,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Modifiability,adapt,adapt,61,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Usability,simpl,simplify,26,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:87,Usability,simpl,simplify,87,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:89,Modifiability,extend,extended,89,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:107,Modifiability,variab,variables,107,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:58,Usability,simpl,simple,58,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variable,10,// Is the variable divisor magnitude always greater than the constant; // dividend magnitude?; // |Y| > |C| --> Y < -abs(C) or Y > abs(C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variable,10,// Is the variable dividend magnitude always less than the constant; // divisor magnitude?; // |X| < |C| --> X > -abs(C) and X < abs(C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:69,Availability,fault,faults,69,// X / 0 -> poison; // X % 0 -> poison; // We don't need to preserve faults!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:214,Usability,simpl,simplifiable,214,"// X / 0 -> poison; // X % 0 -> poison; // If the divisor is known to be zero, just return poison. This can happen in; // some cases where its provable indirectly the denominator is zero but it's; // not trivially simplifiable (i.e known zero through a phi node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Usability,simpl,simplifications,14,/// These are simplifications common to SDiv and UDiv.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:98,Energy Efficiency,power,power,98,"// udiv exact (mul nsw X, C), C --> X; // sdiv exact (mul nuw X, C), C --> X; // where C is not a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Usability,simpl,simplifications,14,/// These are simplifications common to SRem and URem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:81,Performance,scalab,scalable,81,// Shifting by the bitwidth or more is poison. This covers scalars and; // fixed/scalable vectors with splat constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Modifiability,extend,extended,39,// X shift by 0 -> X; // Shift-by-sign-extended bool must be shift-by-0 because shift-by-all-ones; // would be poison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:211,Performance,optimiz,optimization,211,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:307,Performance,optimiz,optimizers,307,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:155,Usability,Simpl,SimplifyDemandedBits,155,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:334,Usability,simpl,simple,334,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:198,Performance,optimiz,optimizer,198,"// The transforms below here are expected to be handled more generally with; // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's; // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,; // these are candidates for removal.; // X < Y && Y != 0 --> X < Y; // X < Y || Y != 0 --> Y != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:80,Usability,simpl,simplifyAndOrOfICmpsWithLimitConst,80,"// The transforms below here are expected to be handled more generally with; // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's; // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,; // these are candidates for removal.; // X < Y && Y != 0 --> X < Y; // X < Y || Y != 0 --> Y != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Testability,Test,Test,4,"/// Test if a pair of compares with a shared operand and 2 constants has an; /// empty set intersection, full set union, or if one compare is a superset of; /// the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify and/or of icmp with ctpop intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Usability,simpl,simplification,61,"// If we looked through casts, we can only handle a constant simplification; // because we are not allowed to create a cast instruction here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:109,Usability,simpl,simplifies,109,"// and (icmp eq a, b), x implies (a==b) inside x.; // or (icmp ne a, b), x implies (a==b) inside x.; // If x simplifies to true/false, we can simplify the and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:142,Usability,simpl,simplify,142,"// and (icmp eq a, b), x implies (a==b) inside x.; // or (icmp ne a, b), x implies (a==b) inside x.; // If x simplifies to true/false, we can simplify the and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplify,56,"// If we have and (icmp ne a, b), x and for a==b we can simplify x to false,; // then we can drop the icmp, as x will already be false in the case where; // the icmp is false. Similar for or and true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Testability,log,logic,20,"/// Given a bitwise logic op, check if the operands are add/sub with a common; /// source value and inverted constant (identity: C - X -> ~(X + ~C)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Energy Efficiency,power,power,24,// -A & A = A if A is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:63,Energy Efficiency,power,power-of-,63,// This is a similar pattern used for checking if a value is a power-of-2:; // (A - 1) & A --> 0 (if A is a power-of-2 or 0),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Energy Efficiency,power,power-of-,108,// This is a similar pattern used for checking if a value is a power-of-2:; // (A - 1) & A --> 0 (if A is a power-of-2 or 0),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Energy Efficiency,power,power,61,"// (x << N) & ((x << M) - 1) --> 0, where x is known to be a power of 2 and; // M <= N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:5,Availability,mask,mask,5,// A mask that only clears known zeros of a shifted value is a no-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,clear,clears,20,// A mask that only clears known zeros of a shifted value is a no-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Availability,mask,mask,43,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:83,Availability,Mask,Mask,83,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Usability,clear,clear,52,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Availability,mask,mask,43,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Availability,Mask,Mask,84,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Usability,clear,clear,52,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,Energy Efficiency,power,power,53,// Use getActiveBits() to make use of the additional power of two knowledge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Usability,simpl,simplifications,45,// And distributes over Or. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:46,Usability,simpl,simplifications,46,// And distributes over Xor. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:131,Availability,mask,mask,131,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:276,Availability,Mask,Mask,276,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:294,Availability,Mask,Mask,294,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:357,Availability,Mask,Mask,357,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:380,Availability,Mask,Mask,380,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:471,Performance,optimiz,optimize,471,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:431,Usability,Simpl,SimplifyDemandedBits,431,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Availability,mask,mask,10,"// If the mask is extracting all bits from X or Y as is, we can skip; // this AND op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Testability,Log,LogicalAnd,39,// TODO: Many of these folds could use LogicalAnd/LogicalOr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:50,Testability,Log,LogicalOr,50,// TODO: Many of these folds could use LogicalAnd/LogicalOr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:23,Testability,Log,Logical,23,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,log,logic,66,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:123,Testability,Log,LogicalAnd,123,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:116,Availability,redundant,redundant,116,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:116,Safety,redund,redundant,116,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:50,Usability,simpl,simpler,50,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Usability,simpl,simplifications,45,// Or distributes over And. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:174,Safety,safe,safe,174,// (~A | B) ^ (A & B) --> ~A -- There are 8 commuted variants.; // The 'not' op must contain a complete -1 operand (no undef elements for; // vector) for the transform to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Xor over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A ^ select(cond, B, C)"" means evaluating; // ""A^B"" and ""A^C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A^B"" and ""A^C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Xor over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A ^ select(cond, B, C)"" means evaluating; // ""A^B"" and ""A^C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A^B"" and ""A^C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:269,Performance,load,loaded,269,"// For allocas, we consider only static ones (dynamic; // allocas might be transformed into calls to malloc not simultaneously; // live with the compared-to allocation). For globals, we exclude symbols; // that might be resolve lazily to symbols in another dynamically-loaded; // library (and, thus, could be malloc'ed by the implementation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:529,Energy Efficiency,reduce,reduce,529,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variables,10,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:117,Modifiability,variab,variables,117,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:1375,Deployability,update,update,1375,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Performance,optimiz,optimization,17,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:1434,Performance,optimiz,optimization,1434,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:117,Integrability,wrap,wrapping,117,// We can only handle unsigned relational comparisons because 'inbounds' on; // a GEP only protects against unsigned wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:316,Performance,load,loads,316,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:519,Performance,optimiz,optimize,519,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:239,Safety,hazard,hazards,239,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Performance,optimiz,optimizations,11,// Various optimizations for (in)equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:208,Energy Efficiency,allocate,allocated,208,"// If one side of the equality comparison must come from a noalias call; // (meaning a system memory allocation function), and the other side must; // come from a pointer that cannot overlap with dynamically-allocated; // memory within the lifetime of the current function (allocas, byval; // arguments, globals), then determine the comparison result here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:201,Safety,safe,safely,201,"// Is the set of underlying objects all things which must be disjoint from; // noalias calls. We assume that indexing from such disjoint storage; // into the heap is undefined, and thus offsets can be safely ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Modifiability,variab,variable,45,"// Comparison against value stored in global variable. Given the; // pointer does not escape, its value cannot be guessed and stored; // separately in a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:160,Modifiability,variab,variable,160,"// Comparison against value stored in global variable. Given the; // pointer does not escape, its value cannot be guessed and stored; // separately in a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Energy Efficiency,reduce,reduced,43,// A boolean compared to true/false can be reduced in 14 out of the 20; // (10 predicates * 2 constants) possible combinations. The other; // 6 cases require a 'not' of the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Testability,log,logic,25,/// SLE follows the same logic as SGE with the LHS and RHS swapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Performance,optimiz,optimized,26,"// Sign-bit checks can be optimized to true/false after unsigned; // floating-point casts:; // icmp slt (bitcast (uitofp X)), 0 --> false; // icmp sgt (bitcast (uitofp X)), -1 --> true",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:126,Safety,avoid,avoid,126,/// TODO: A large part of this logic is duplicated in InstCombine's; /// foldICmpBinOp(). We should be able to share that and avoid the code; /// duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Testability,log,logic,31,/// TODO: A large part of this logic is duplicated in InstCombine's; /// foldICmpBinOp(). We should be able to share that and avoid the code; /// duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Energy Efficiency,power,power-of-,14,// If C2 is a power-of-2 and C is not:; // (C2 << X) == C --> false; // (C2 << X) != C --> true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:82,Safety,unsafe,unsafe,82,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Safety,safe,safe,125,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:58,Usability,simpl,simplification,58,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Energy Efficiency,power,power-of-,13,// If C is a power-of-2:; // (C << X) >u 0x8000 --> false; // (C << X) <=u 0x8000 --> true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,simpl,simplify,4,/// simplify integer comparisons where at least one operand of the compare; /// matches an integer min/max idiom.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,test,tested,66,"// Equivalent to ""A EqP B"". This may be the same as the condition tested; // in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// Otherwise, see if ""A EqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Testability,test,tested,73,"// Equivalent to ""A InvEqP B"". This may be the same as the condition; // tested in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// Otherwise, see if ""A InvEqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,test,tested,66,"// Equivalent to ""A EqP B"". This may be the same as the condition tested; // in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// Otherwise, see if ""A EqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Testability,test,tested,73,"// Equivalent to ""A InvEqP B"". This may be the same as the condition; // tested in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// Otherwise, see if ""A InvEqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Usability,simpl,simplify,65,"// If both operands have range metadata, use the metadata; // to simplify the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Modifiability,extend,extended,65,"// Turn icmp (zext X), Cst into a compare of X and Cst if Cst is extended; // too. If not, then try to deduce the result of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Modifiability,extend,extended,13,// If the re-extended constant didn't change any of the elements then; // this is effectively also a case of comparing two zero-extended; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:128,Modifiability,extend,extended,128,// If the re-extended constant didn't change any of the elements then; // this is effectively also a case of comparing two zero-extended; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Modifiability,extend,extended,65,"// Turn icmp (sext X), Cst into a compare of X and Cst if Cst is extended; // too. If not, then try to deduce the result of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Modifiability,extend,extended,13,// If the re-extended constant didn't change then this is effectively; // also a case of comparing two sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Modifiability,extend,extended,108,// If the re-extended constant didn't change then this is effectively; // also a case of comparing two sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Availability,avail,available,110,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Energy Efficiency,power,powerful,52,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Usability,Simpl,Simplify,3,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:97,Modifiability,variab,variable,97,"// Fold (un)ordered comparison if we can determine there are no NaNs.; //; // This catches the 2 variable input case, constants are handled below as a; // class-like compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:48,Safety,Avoid,Avoid,48,// Lazily compute the possible classes for LHS. Avoid computing it twice if; // RHS is a 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:81,Performance,perform,perform,81,// Fold out compares that express a class test.; //; // FIXME: Should be able to perform folds without context; // instruction. Always pass in the context function?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:42,Testability,test,test,42,// Fold out compares that express a class test.; //; // FIXME: Should be able to perform folds without context; // instruction. Always pass in the context function?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Testability,test,test,110,"// TODO: Need version fcmpToClassTest which returns implied class when the; // compare isn't a complete class test. e.g. > 1.0 implies fcPositive, but; // isn't implementable as a class call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Usability,simpl,simplification,25,"// For vector types, the simplification must hold per-lane, so forbid; // potentially cross-lane operations like shufflevector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:9,Usability,simpl,simplify,9,// Don't simplify freeze.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Safety,avoid,avoid,125,"// General InstSimplify functions may refine the result, e.g. by returning; // a constant for a potentially poison value. To avoid this, implement only; // a few non-refining but profitable transforms here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:111,Integrability,wrap,wraps,111,"// x - x -> 0, x ^ x -> 0. This is non-refining, because x is non-poison; // by assumption and this case never wraps, so nowrap flags can be; // ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:204,Safety,safe,safe,204,"// If we are substituting an absorber constant into a binop and extra; // poison can't leak if we remove the select -- because both operands of; // the binop are based on the same value -- then it may be safe to replace; // the value with the absorber constant. Examples:; // (Op == 0) ? 0 : (Op & -Op) --> Op & -Op; // (Op == 0) ? 0 : (Op * (binop Op, C)) --> Op * (binop Op, C); // (Op == -1) ? -1 : (Op | (binop C, Op) --> Op | (binop C, Op)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:423,Integrability,contract,contract,423,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Usability,simpl,simplification,7,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:300,Usability,simpl,simplifies,300,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer comparison where one operand of the compare is a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:309,Energy Efficiency,reduce,reduces,309,"// (X > Y) ? X : max(X, Y) --> max(X, Y); // (X >= Y) ? X : max(X, Y) --> max(X, Y); // (X < Y) ? X : min(X, Y) --> min(X, Y); // (X <= Y) ? X : min(X, Y) --> min(X, Y); //; // The equivalence allows a vector select (shuffle) of max/min and Y. Ex:; // (X > Y) ? X : (Z ? max(X, Y) : Y); // If Z is true, this reduces as above, and if Z is false:; // (X > Y) ? X : Y --> max(X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Testability,test,test,26,/// An alternative way to test if a bit is set or not uses sgt/slt instead of; /// eq/ne.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer equality comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,Test,Test,3,// Test for a bogus zero-shift-guard-op around funnel-shift or rotate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:72,Safety,avoid,avoid,72,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:295,Safety,safe,safety,295,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,Test,Test,3,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:49,Testability,test,test,49,// Check for other compares that behave like bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:157,Usability,simpl,simplifying,157,"// If we have a scalar equality comparison, then we know the value in one of; // the arms of the select. See if substituting this value into the arm and; // simplifying the result yields the same value as the other arm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is a; /// floating-point comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Safety,safe,safe,21,"// This transform is safe if we do not have (do not care about) -0.0 or if; // at least one operand is known to not be -0.0. Otherwise, the select can; // change the sign of a zero operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Testability,log,logical-and,30,// Match patterns that end in logical-and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Testability,log,logical-or,30,// Match patterns that end in logical-or.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:38,Testability,log,logical-and,38,"// select i1 X, i1 X, i1 false --> X (logical-and)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Testability,log,logical-or,37,"// select i1 X, i1 true, i1 X --> X (logical-or)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:135,Safety,safe,safe,135,"// If the elements match (undef or not), that value is the result. If only; // one element is undef, choose the defined element as the safe result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:38,Performance,perform,performs,38,"// All-zero GEP is a no-op, unless it performs a vector splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Safety,safe,safe,37,// The following transforms are only safe if the ptrtoint cast; // doesn't truncate the pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid creating inttoptr of zero here: While LLVMs treatment of; // inttoptr is generally conservative, this particular case is folded to; // a null pointer, which will have incorrect provenance.; // gep (gep V, C), (sub 0, V) -> C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Safety,risk,risk,59,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:113,Usability,simpl,simplify,113,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:69,Modifiability,variab,variable,69,"// extractelt x, (insertelt y, elt, n), n -> elt; // If the possibly-variable indices are trivially known to be equal; // (because they are the same operand) then use the value that was; // inserted directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Performance,perform,perform,61,"// WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE; // here, because the PHI we may succeed simplifying to was not; // def-reachable from the original PHI!; // If all of the PHI's incoming values are the same then replace the PHI node; // with the common value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,Usability,simpl,simplifying,118,"// WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE; // here, because the PHI we may succeed simplifying to was not; // def-reachable from the original PHI!; // If all of the PHI's incoming values are the same then replace the PHI node; // with the common value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,Availability,mask,mask,187,"/// For the given destination element of a shuffle, peek through shuffles to; /// match a root vector source operand that contains that element in the same; /// vector lane (ie, the same mask index), so we can eliminate the shuffle(s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,Availability,mask,mask,19,// Bail out if any mask value is undefined. That kind of shuffle may be; // simplified further based on demanded bits or other folds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:76,Usability,simpl,simplified,76,// Bail out if any mask value is undefined. That kind of shuffle may be; // simplified further based on demanded bits or other folds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Availability,mask,mask,7,// The mask value chooses which source operand we need to look at next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Availability,mask,mask,24,"// Canonicalization: If mask does not select elements from an input vector,; // replace that input vector with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:112,Availability,mask,mask,112,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Integrability,depend,depends,84,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:160,Performance,scalab,scalable,160,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:139,Availability,mask,mask,139,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:111,Integrability,depend,depends,111,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,Performance,scalab,scalable,187,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:233,Availability,mask,mask,233,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:306,Availability,mask,mask,306,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:195,Deployability,update,updated,195,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:278,Integrability,depend,depends,278,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:354,Performance,scalab,scalable,354,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Availability,mask,mask,25,// Match a splat shuffle mask of the insert index allowing undef elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Availability,mask,mask,11,// Shuffle mask poisons become poison constant result elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,mask,mask,59,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:32,Integrability,depend,depend,32,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Performance,scalab,scalable,108,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Availability,mask,mask,35,// Don't fold a shuffle with undef mask elements. This may get folded in a; // better way using demanded bits or other analysis.; // TODO: Should we allow this?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:171,Usability,simpl,simple,171,"// Check if every element of this shuffle can be mapped back to the; // corresponding element of a single root vector. If so, we don't need this; // shuffle. This handles simple identity shuffles as well as chains of; // shuffles that may widen/narrow and/or move elements across lanes and back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,Usability,simpl,simplify,118,"// Note that recursion is limited for each vector element, so if any element; // exceeds the limit, this will fail to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:42,Usability,simpl,simple,42,"// If it is not a fixed vector, but not a simple NaN either, return a; // canonical NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Performance,scalab,scalable,39,"// If we known this is a NaN, and it's scalable vector, we must have a splat; // on our hands. Grab that before splatting a QNaN constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Performance,Perform,Perform,4,/// Perform folds that are common to any floating-point operation. This implies; /// transforms based on poison/undef/NaN because the operation itself makes no; /// difference to the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:102,Usability,simpl,simplify,102,"// fadd X, -0 ==> X; // With strict/constrained FP, we have these possible edge cases that do; // not simplify to Op0:; // fadd SNaN, -0.0 --> QNaN; // fadd +0.0, -0.0 --> -0.0 (but only with round toward negative)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Usability,simpl,simplifications,13,// Now apply simplifications that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Safety,safe,safe,25,"// These cases should be safe, even with strictfp.; // ldexp(0.0, x) -> 0.0; // ldexp(-0.0, x) -> -0.0; // ldexp(inf, x) -> inf; // ldexp(-inf, x) -> -inf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Energy Efficiency,power,power,35,// ctpop(X) -> 1 iff X is non-zero power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Testability,log,log,7,// exp(log(x)) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,log,log,3,// log(exp(x)) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Usability,Simpl,Simple,3,"// Simple case, m(m(X,Y), X) => m(X, Y); // m(m(X,Y), Y) => m(X, Y); // For minimum/maximum, X is NaN => m(NaN, Y) == NaN and m(NaN, NaN) == NaN.; // For minimum/maximum, Y is NaN => m(X, NaN) == NaN and m(NaN, NaN) == NaN.; // For minnum/maxnum, X is NaN => m(NaN, Y) == Y and m(Y, Y) == Y.; // For minnum/maxnum, Y is NaN => m(X, NaN) == X and m(X, NaN) == X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:29,Usability,simpl,simplifications,29,// NOTE: We can't apply this simplifications based on the value of Op1; // because we need to preserve provenance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,Availability,mask,mask,19,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Availability,mask,mask,61,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:75,Modifiability,extend,extended,75,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:18,Availability,mask,masking,18,// See if we only masking off bits we know are already zero due to; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Testability,test,tests,10,"// If all tests are made, it doesn't matter what the value is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Usability,simpl,simplify,84,// Most of the intrinsics with no operands have some kind of side effect.; // Don't simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros or undef, the ""passthru"" argument is the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplified,30,"// musttail calls can only be simplified if they are also DCEd.; // As we can't guarantee this here, don't simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:107,Usability,simpl,simplify,107,"// musttail calls can only be simplified if they are also DCEd.; // As we can't guarantee this here, don't simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Performance,load,load,24,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:109,Testability,log,logic,109,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:28,Usability,simpl,simplified,28,"/// See if we can compute a simplified version of this instruction.; /// If not, this returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:6,Usability,simpl,simplifications,6,// No simplifications for Alloca and it can't be constant folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Safety,detect,detecting,110,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:157,Safety,safe,safe,157,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:55,Usability,simpl,simplify,55,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:159,Integrability,rout,routines,159,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:585,Integrability,rout,routine,585,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:32,Usability,simpl,simplification,32,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:144,Usability,simpl,simplification,144,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:191,Usability,simpl,simplified,191,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:212,Usability,Simpl,SimpleV,212,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:295,Usability,simpl,simply,295,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:369,Usability,simpl,simplify,369,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:463,Usability,simpl,simplified,463,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:623,Usability,simpl,simplifies,623,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:664,Usability,simpl,simplified,664,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Usability,simpl,simplification,73,"// If we have an explicit value to collapse to, do that round of the; // simplification loop by hand initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Testability,test,test,21,"// Note that we must test the size on each iteration, the worklist can grow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:27,Usability,simpl,simplifies,27,// See if this instruction simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:89,Usability,simpl,simplifications,89,// Stash away all the uses of the old instruction so we can check them for; // recursive simplifications after a RAUW. This is cheaper than checking all; // uses of To on the recursive step in most cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp:49,Energy Efficiency,allocate,allocate,49,"// Just like in the no inference case, this will allocate an appropriately; // sized buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:204,Deployability,release,releaseMemory,204,//===----------------------------------------------------------------------===//; // IntervalPartition Implementation; //===----------------------------------------------------------------------===//; // releaseMemory - Reset state back to before function was analyzed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:3,Deployability,update,updatePredecessors,3,"// updatePredecessors - Interval generation only sets the successor fields of; // the interval data structures. After interval generation is complete,; // run through all of the intervals and propagate successor info as; // predecessor info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:36,Energy Efficiency,reduce,reduced,36,// IntervalPartition ctor - Build a reduced interval partition from an; // existing interval graph. This takes an additional boolean parameter to; // distinguish it from a copy constructor. Always pass in false for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:6,Security,hash,hash,6,"// To hash intrinsics, we use the opcode, and types like the other; // instructions, but also, the Intrinsic ID, and the Name of the; // intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:19,Performance,perform,performing,19,// Check if we are performing the same sort of operation on the same types; // but not on the same values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:136,Testability,assert,assert,136,"// Setting the first and last instruction data pointers for the candidate. If; // we got through the entire for loop without hitting an assert, we know; // that both of these instructions are not nullptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:342,Deployability,update,update,342,"// We are given two unsigned integers representing the global values of; // the operands in different IRSimilarityCandidates and a current mapping; // between the two.; //; // Source Operand GVN: 1; // Target Operand GVN: 2; // CurrentMapping: {1: {1, 2}}; //; // Since we have mapping, and the target operand is contained in the set, we; // update it to:; // CurrentMapping: {1: {2}}; // and can return true. But, if the mapping was; // CurrentMapping: {1: {3}}; // we would return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:50,Integrability,bridg,bridge,50,"// We're going to use the larger candidates as a ""bridge"" to create the; // canonical number for the target candidate since we have idetified two; // candidates as subsequences of larger sequences, and therefore must be; // structurally similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:45,Performance,perform,perform,45,"/// From the list of IRSimilarityCandidates, perform a comparison between each; /// IRSimilarityCandidate to determine if there are overlapping; /// IRInstructionData, or if they do not have the same structure.; ///; /// \param [in] CandsForRepSubstring - The vector containing the; /// IRSimilarityCandidates.; /// \param [out] StructuralGroups - the mapping of unsigned integers to vector; /// of IRSimilarityCandidates where each of the IRSimilarityCandidates in the; /// vector are structurally similar to one another.; /// \param [in] IndexToIncludedCand - Mapping of index of the an instruction in; /// a circuit to the IRSimilarityCandidates that include this instruction.; /// \param [in] CandToOverallGroup - Mapping of IRSimilarityCandidate to a; /// number representing the structural group assigned to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:430,Modifiability,variab,variables,430,"//===- llvm/Analysis/IVDescriptors.cpp - IndVar Descriptors -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file ""describes"" induction and recurrence variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:111,Availability,mask,mask,111,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:210,Availability,mask,mask,210,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:140,Deployability,update,updated,140,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:65,Deployability,update,update,65,"// Matches either I & 2^x-1 or 2^x-1 & I. If we find a match, we update RT; // with a new integer type of the corresponding bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:130,Energy Efficiency,power,power,130,"// Use the demanded bits analysis to determine the bits that are live out; // of the exit instruction, rounding up to the nearest power of two. If the; // use of demanded bits results in a smaller bit width, we know the value; // must be positive (i.e., IsSigned = false), because if this were not the; // case, the sign bit would have been demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:95,Modifiability,extend,extended,95,"// Make sure at least one sign bit is included in the result, so it; // will get properly sign-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:212,Performance,load,loads,212,// The minimum width used by the recurrence is found by checking for; // casts on its operands. The minimum width is used by the vectorizer; // when finding the widest type for in-loop reductions without any; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:125,Safety,unsafe,unsafe,125,// Check if a given Phi node can be recognized as an ordered reduction for; // vectorizing floating point operations without unsafe math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:13,Modifiability,variab,variables,13,// Reduction variables are only found in the loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:189,Modifiability,variab,variables,189,"// ExitInstruction is the single value which is used outside the loop.; // We only allow for a single reduction value to be used outside the loop.; // This includes users of the reduction, variables (which form a cycle; // which ends in the phi node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:3,Modifiability,Variab,Variable,3,// Variable to keep last visited store instruction. By the end of the; // algorithm this variable will be either empty or having intermediate; // reduction value stored in invariant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:89,Modifiability,variab,variable,89,// Variable to keep last visited store instruction. By the end of the; // algorithm this variable will be either empty or having intermediate; // reduction value stored in invariant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:150,Modifiability,variab,variables,150,// We start with the PHI node and scan for all of the users of this; // instruction. All users must be instructions that can be used as reduction; // variables (such as ADD). We must have a single out-of-block user. The cycle; // must include the original PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:193,Performance,perform,performed,193,"// Return early if the recurrence kind does not match the type of Phi. If the; // recurrence kind is arithmetic, we attempt to look through AND operations; // resulting from the type promotion performed by InstCombine. Vector; // operations are not limited to the legal integer widths, so we may be able; // to evaluate the reduction in the narrower width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:126,Safety,safe,safe,126,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:176,Safety,safe,safe,176,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:243,Safety,safe,safe,243,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:271,Safety,safe,safe,271,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:320,Safety,safe,safe,320,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:486,Safety,safe,safe,486,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:726,Safety,safe,safe,726,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:106,Modifiability,variab,variable,106,// No Users.; // If the instruction has no users then this is a broken chain and can't be; // a reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:100,Modifiability,variab,variable,100,"// Reductions of instructions such as Div, and Sub is only possible if the; // LHS is the reduction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:3,Deployability,Update,Update,3,// Update this reduction kind if we matched a new instruction.; // TODO: Can we eliminate the need for a 2nd InstDesc by keeping 'Kind'; // state accurate while processing the worklist?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:13,Modifiability,variab,variable,13,// Reduction variable chain can only be stored somewhere but it; // can't be used as an address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:1055,Modifiability,extend,extend,1055,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:1256,Modifiability,rewrite,rewrite,1256,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:875,Performance,perform,perform,875,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:809,Usability,simpl,simple,809,"// Collect cast instructions and the minimum width used by the recurrence.; // If the starting value is not the same as the phi node and the computed; // recurrence type is equal to the recurrence type, the recurrence expression; // will be represented in a narrower or wider type. If there are any cast; // instructions that will be unnecessary, collect them in CastsFromRecurTy.; // Note that the 'and' instruction was already included in this list.; //; // TODO: A better way to represent this may be to tag in some way all the; // instructions that are a part of the reduction. The vectorizer cost; // model could then apply the recurrence type to these instructions,; // without needing a white list of instructions to ignore.; // This may also be useful for the inloop reductions, if it can be; // kept simple enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:308,Modifiability,variab,variable,308,// We found a reduction var if we have reached the original phi node and we; // only have a single instruction with out-of-loop users.; // The ExitInstruction(Instruction which is allowed to have out-of-loop users); // is saved as part of the RecurrenceDescriptor.; // Save the description of this reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:803,Usability,simpl,simply,803,"// We are looking for loops that do something like this:; // int r = 0;; // for (int i = 0; i < n; i++) {; // if (src[i] > 3); // r = 3;; // }; // where the reduction value (r) only has two states, in this example 0 or 3.; // The generated LLVM IR for this type of loop will be like this:; // for.body:; // %r = phi i32 [ %spec.select, %for.body ], [ 0, %entry ]; // ...; // %cmp = icmp sgt i32 %5, 3; // %spec.select = select i1 %cmp, i32 3, i32 %r; // ...; // In general we can support vectorization of loops where 'r' flips between; // any two non-constants, provided they are loop invariant. The only thing; // we actually care about at the end of the loop is whether or not any lane; // in the selected vector is different from the start value. The final; // across-vector reduction after the loop simply involves choosing the start; // value if nothing changed (0 in the example above) or the other selected; // value (3 in the example above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:259,Modifiability,extend,extending,259,// Ensure every user of the phi node (recursively) is dominated by the; // previous value. The dominance requirement ensures the loop vectorizer will; // not need to vectorize the initial value prior to the first iteration of the; // loop.; // TODO: Consider extending this sinking to handle memory instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:10,Integrability,depend,dependence,10,// Cyclic dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:10,Availability,down,down,10,"// Search down from the Phi to the LoopExitInstr, looking for instructions; // with a single user of the correct type for the reduction.; // Note that we check that the type of the operand is correct for each item in; // the chain, including the last (the loop exit value). This can come up from; // sub, which would otherwise be treated as an add reduction. MinMax also need; // to check for a pair of icmp/select, for which we use getNextInstruction and; // isCorrectOpcode functions to step the right number of instruction, and; // check the icmp/select pair.; // FIXME: We also do not attempt to look through Select's yet, which might; // be part of the reduction chain, or attempt to looks through And's to find a; // smaller bitwidth. Subs are also currently not allowed (which are usually; // treated as part of a add reduction) as they are expected to generally be; // more expensive than out-of-loop reductions, and need to be costed more; // carefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:56,Testability,test,test,56,"// The loop exit instruction we check first (as a quick test) but add last. We; // check the opcode is correct (and dont allow them to be Subs) and that they; // have expected to have the expected number of uses. They will have one use; // from the phi and one from a LCSSA value, no matter the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:36,Modifiability,variab,variables,36,// Here we only handle FP induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,Availability,redundant,redundant,142,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:53,Deployability,update,update-chain,53,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:441,Deployability,update,update-chain,441,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:217,Modifiability,rewrite,rewriter,217,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,Safety,redund,redundant,142,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:386,Modifiability,extend,extended,386,"// Find any cast instructions that participate in the def-use chain of; // PhiScev in the loop.; // FORNOW/TODO: We currently expect the def-use chain to include only; // two-operand instructions, where one of the operands is an invariant.; // createAddRecFromPHIWithCasts() currently does not support anything more; // involved than that, so we keep the search simple. This can be; // extended/generalized as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:362,Usability,simpl,simple,362,"// Find any cast instructions that participate in the def-use chain of; // PhiScev in the loop.; // FORNOW/TODO: We currently expect the def-use chain to include only; // two-operand instructions, where one of the operands is an invariant.; // createAddRecFromPHIWithCasts() currently does not support anything more; // involved than that, so we keep the search simple. This can be; // extended/generalized as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:41,Modifiability,variab,variables,41,// Handle integer and pointer inductions variables.; // Now we handle also FP induction but not trying to make a; // recurrent expression from the PHI node in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:66,Deployability,update,update,66,// Record any Cast instructions that participate in the induction update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:49,Modifiability,variab,variables,49,// We only handle integer and pointer inductions variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:137,Testability,assert,assert,137,"// This function assumes that InductionPhi is called only on Phi nodes; // present inside loop headers. Check for the same, and throw an assert if; // the current Phi is not present inside the loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:25,Modifiability,variab,variables,25,// This allows induction variables w/non-constant steps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:31,Modifiability,Variab,Variable,31,"//===- IVUsers.cpp - Induction Variable Users -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:483,Modifiability,variab,variables,483,"//===- IVUsers.cpp - Induction Variable Users -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:20,Testability,Test,Test,20,"/// isInteresting - Test whether the given expression is ""interesting"" when; /// used by the given expression, within the context of analyzing the; /// given loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:15,Usability,simpl,simple,15,// Keep things simple. Don't touch loop-variant strides unless they're; // only used outside the loop and we can simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:113,Usability,simpl,simplify,113,// Keep things simple. Don't touch loop-variant strides unless they're; // only used outside the loop and we can simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:37,Energy Efficiency,reduce,reduced,37,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:117,Safety,safe,safe,117,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:171,Safety,safe,safe,171,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:232,Safety,safe,safe,232,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:79,Safety,avoid,avoid,79,"// LSR is not APInt clean, do not touch integers bigger than 64-bits.; // Also avoid creating IVs of non-native types. For example, we don't want a; // 64-bit IV in 32-bit code just because the loop has one 64-bit cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:162,Integrability,depend,depend,162,"// Descend recursively, but not into PHI nodes outside the current loop.; // It's important to see the entire expression outside the loop to get; // choices that depend on addressing mode use right, although we won't; // consider references outside the loop in all cases.; // If User is already in Processed, we don't want to recurse into it again,; // but do want to record a second reference in the same instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:40,Energy Efficiency,reduce,reduce,40,"// Okay, we found a user that we cannot reduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:121,Integrability,wrap,wrapping,121,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:36,Usability,simpl,simplifies,36,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:30,Modifiability,variab,variables,30,"// Find all uses of induction variables in this loop, and categorize; // them by stride. Start by finding all of the PHI nodes in the header for; // this loop. If they are induction variables, inspect their uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:182,Modifiability,variab,variables,182,"// Find all uses of induction variables in this loop, and categorize; // them by stride. Start by finding all of the PHI nodes in the header for; // this loop. If they are induction variables, inspect their uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:540,Performance,optimiz,optimizations,540,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:994,Performance,optimiz,optimizing,994,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:984,Safety,safe,safety,984,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:848,Testability,test,test,848,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Walk down the graph until we run out of edges or find a path to TargetC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:521,Availability,down,downward,521,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:24,Deployability,update,updates,24,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:370,Deployability,update,updates,370,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:2626,Deployability,Update,Updates,2626,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3093,Deployability,update,update,3093,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:357,Integrability,rout,routine,357,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3015,Integrability,rout,routine,3015,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,Safety,detect,detect,59,"// At this point we leverage the postorder list of SCCs to detect when the; // insertion of an edge changes the SCC structure in any way.; //; // First and foremost, we can eliminate the need for any changes when the; // edge is toward the beginning of the postorder sequence because all edges; // flow in that direction already. Thus adding a new one cannot form a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:27,Deployability,update,update,27,// Use a generic helper to update the postorder sequence of SCCs and return; // a range of any SCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:156,Integrability,rout,routine,156,// Use a generic helper to update the postorder sequence of SCCs and return; // a range of any SCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:83,Deployability,update,updates,83,"// Before merging, check that the RefSCC remains valid after all the; // postorder updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:43,Deployability,update,update,43,// Erase the merged SCCs from the list and update the indices of the; // remaining SCCs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:339,Safety,detect,detect,339,"// Force the target node to be in the old SCC. This also enables us to take; // a very significant short-cut in the standard Tarjan walk to re-form SCCs; // below: whenever we build an edge that reaches the target node, we know; // that the target node eventually connects back to all other nodes in our; // walk. As a consequence, we can detect and handle participants in that; // cycle without walking all the edges that form this connection, and instead; // by relying on the fundamental guarantee coming into this operation (all; // nodes are reachable from the target due to previously forming an SCC).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Scan down the stack and DFS across the call edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Cleared,3,"// Cleared the DFS early, start another round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:46,Usability,clear,clear,46,// Form a new SCC out of these nodes and then clear them off our pending; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,"// Update the mapping from SCC* to index to use the new SCC*s, and remove the; // old SCC from the mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:27,Deployability,update,update,27,// Use a generic helper to update the postorder sequence of RefSCCs and return; // a range of any RefSCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:162,Integrability,rout,routine,162,// Use a generic helper to update the postorder sequence of RefSCCs and return; // a range of any RefSCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:34,Testability,test,tests,34,"// Build a set, so we can do fast tests for whether a RefSCC will end up as; // part of the merged RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:26,Deployability,update,update,26,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:80,Deployability,update,update,80,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:146,Safety,avoid,avoid,146,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:91,Deployability,Update,Update,91,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:157,Safety,avoid,avoid,157,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update this node and keep scanning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:219,Energy Efficiency,efficient,efficiently,219,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:202,Integrability,rout,routine,202,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Clear,3,// Clear out the low link field as we won't need it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:80,Usability,clear,clear,80,// We've already marked the nodes internally with the RefSCC number so; // just clear them off the stack and continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Clear,3,// Clear out all the SCC's node's low-link fields now that we're done; // using them as side-storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:53,Usability,clear,clear,53,"// Now that we've moved things into the new RefSCCs, clear out our current; // one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:25,Deployability,update,update,25,"// Already an edge, just update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update various call graph maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update lib functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:152,Security,Validat,Validate,152,"// This node must be the only member of its SCC as it has no callers, and; // that SCC must be the only member of a RefSCC as it has no references.; // Validate these properties first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,Availability,down,down,59,"// Finally clear out all the data structures from the node down through the; // components. postorder_ref_scc_iterator will skip empty RefSCCs, so no need; // to adjust LazyCallGraph data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:11,Usability,clear,clear,11,"// Finally clear out all the data structures from the node down through the; // components. postorder_ref_scc_iterator will skip empty RefSCCs, so no need; // to adjust LazyCallGraph data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:44,Energy Efficiency,allocate,allocated,44,// Nothing to delete as all the objects are allocated in stable bump pointer; // allocators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:99,Testability,Assert,Asserts,99,// Gets the Edge::Kind from one function to another by looking at the function's; // instructions. Asserts if there is no edge.; // Useful for determining what type of edge should exist between functions when; // the edge hasn't been created yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:6,Deployability,release,release,6,"// In release builds, assume that if there are no direct calls to the new; // function, then there is a ref edge. In debug builds, keep track of; // references to assert that there is actually a ref edge if there is no call; // edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:163,Testability,assert,assert,163,"// In release builds, assume that if there are no direct calls to the new; // function, then there is a ref edge. In debug builds, keep track of; // references to assert that there is actually a ref edge if there is no call; // edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:24,Deployability,update,update,24,"// Walk the node map to update their graph pointers. While this iterates in; // an unstable order, the order has no effect, so it remains correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Scan down the stack and DFS across the call edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:46,Usability,clear,clear,46,// Form a new SCC out of these nodes and then clear them off our pending; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:121,Deployability,update,updates,121,/// Build the internal SCCs for a RefSCC from a sequence of nodes.; ///; /// Appends the SCCs to the provided vector and updates the map with their; /// indices. Both the vector and map must be empty when passed into this; /// routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:227,Integrability,rout,routine,227,/// Build the internal SCCs for a RefSCC from a sequence of nodes.; ///; /// Appends the SCCs to the provided vector and updates the map with their; /// indices. Both the vector and map must be empty when passed into this; /// routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:43,Usability,clear,clear,43,"// This node will go into the next RefSCC, clear out its DFS and low link; // as we scan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:405,Integrability,interface,interface,405,"//===- LazyValueInfo.cpp - Value constraint analysis ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for lazy computation of value constraint; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:900,Modifiability,enhance,enhancement,900,"/// Combine two sets of facts about the same value into a single set of; /// facts. Note that this method is not suitable for merging facts along; /// different paths in a CFG; that's what the mergeIn function is for. This; /// is for merging facts gathered about the same value at the same location; /// through two independent means.; /// Notes:; /// * This method does not promise to return the most precise possible lattice; /// value implied by A and B. It is allowed to return any lattice element; /// which is at least as strong as *either* A or B (unless our facts; /// conflict, see below).; /// * Due to unreachable code, the intersection of two lattice values could be; /// contradictory. If this happens, we return some valid lattice value so as; /// not confuse the rest of LVI. Ideally, we'd always return Undefined, but; /// we do not make this guarantee. TODO: This would be a useful enhancement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:68,Integrability,depend,depending,68,// Note: An empty range is implicitly converted to unknown or undef depending; // on MayIncludeUndef internally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:28,Deployability,update,updates,28,/// A callback value handle updates the cache when values are erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:40,Performance,cache,cache,40,/// A callback value handle updates the cache when values are erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Performance,cache,cache,16,/// This is the cache kept by LazyValueInfo which; /// maintains information about queries across the clients' queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:169,Energy Efficiency,reduce,reduce,169,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Performance,cache,cached,23,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:247,Performance,cache,cached,247,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Performance,Cache,Cached,4,/// Cached information per basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// Set of value handles used to erase values from the cache on deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:54,Energy Efficiency,reduce,reduce,54,// Insert over-defined values into their own cache to reduce memory; // overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:45,Performance,cache,cache,45,// Insert over-defined values into their own cache to reduce memory; // overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Performance,cache,cache,22,/// clear - Empty the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Usability,clear,clear,4,/// clear - Empty the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:15,Performance,cache,cache,15,/// Inform the cache that a given value has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Deployability,Update,Updates,4,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Performance,cache,cache,16,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Performance,cache,cache,173,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:200,Deployability,update,update,200,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:266,Performance,cache,cache,266,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:391,Performance,cache,cached,391,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:237,Usability,clear,clear,237,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:367,Usability,simpl,simple,367,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:21,Performance,perform,perform,21,"// Use a worklist to perform a depth-first search of OldSucc's successors.; // NOTE: We do not need a visited list since any blocks we have already; // visited will have had their overdefined markers cleared already, and we; // thus won't loop to their successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:200,Usability,clear,cleared,200,"// Use a worklist to perform a depth-first search of OldSucc's successors.; // NOTE: We do not need a visited list since any blocks we have already; // visited will have had their overdefined markers cleared already, and we; // thus won't loop to their successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,Security,access,accessible,20,// Skip blocks only accessible through NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Deployability,update,update,55,"// If we removed anything, then we potentially need to update; // blocks successors too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:68,Deployability,update,update,68,// namespace; // The actual implementation of the lazy analysis and update. Note that the; // inheritance from LazyValueInfoCache is intended to be temporary while; // splitting the code and then transitioning to a has-a relationship.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:94,Modifiability,inherit,inheritance,94,// namespace; // The actual implementation of the lazy analysis and update. Note that the; // inheritance from LazyValueInfoCache is intended to be temporary while; // splitting the code and then transitioning to a has-a relationship.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Performance,Cache,Cached,4,/// Cached results from previous queries,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Performance,cache,cache,22,///< A pointer to the cache of @llvm.assume calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,/// This is the query interface to determine the lattice value for the; /// specified Value* at the context instruction (if specified) or at the; /// start of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,"/// This is the query interface to determine the lattice value for the; /// specified Value* at the specified instruction using only information; /// from assumes/guards and range metadata. Unlike getValueInBlock(), no; /// recursive query is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:243,Performance,perform,performed,243,"/// This is the query interface to determine the lattice value for the; /// specified Value* at the specified instruction using only information; /// from assumes/guards and range metadata. Unlike getValueInBlock(), no; /// recursive query is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,/// This is the query interface to determine the lattice; /// value for the specified Value* that is true on the specified edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:99,Performance,cache,cache,99,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Deployability,update,update,16,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Integrability,interface,interface,23,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:47,Performance,cache,cache,47,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:122,Performance,cache,cache,122,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:313,Performance,cache,cached,313,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:538,Performance,cache,cache,538,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:568,Performance,throttle,throttle,568,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:3,Safety,Abort,Abort,3,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:161,Safety,avoid,avoid,161,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:42,Performance,Cache,Cache,42,// Hold off inserting this value into the Cache in case we have to return; // false and come back later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:183,Modifiability,extend,extend,183,"// If this value is a nonnull pointer, record it's range and bailout. Note; // that for all other pointer typed values, we terminate the search at the; // definition. We could easily extend this to look through geps, bitcasts,; // and the like to prove non-nullness, but it's not clear that's worth it; // compile time wise. The context-insensitive value walk done inside; // isKnownNonZero gets most of the profitable cases at much less expense.; // This does mean that we have a sensitivity to where the defining; // instruction is placed, even if it could legally be hoisted much higher.; // That is unfortunate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:280,Usability,clear,clear,280,"// If this value is a nonnull pointer, record it's range and bailout. Note; // that for all other pointer typed values, we terminate the search at the; // definition. We could easily extend this to look through geps, bitcasts,; // and the like to prove non-nullness, but it's not clear that's worth it; // compile time wise. The context-insensitive value walk done inside; // isKnownNonZero gets most of the profitable cases at much less expense.; // This does mean that we have a sensitivity to where the defining; // instruction is placed, even if it could legally be hoisted much higher.; // That is unfortunate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:105,Performance,cache,cached,105,"// Note that we can provide PN as the context value to getEdgeValue, even; // though the results will be cached, because PN is the value being used as; // the cache key in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:159,Performance,cache,cache,159,"// Note that we can provide PN as the context value to getEdgeValue, even; // though the results will be cached, because PN is the value being used as; // the cache key in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:50,Safety,Avoid,Avoid,50,// Is this a min specifically of our two inputs? (Avoid the risk of; // ValueTracking getting smarter looking back past our immediate inputs.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:60,Safety,risk,risk,60,// Is this a min specifically of our two inputs? (Avoid the risk of; // ValueTracking getting smarter looking back past our immediate inputs.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Usability,simpl,simplification,55,// Handle extractvalue of insertvalue to allow further simplification; // based on replaced with.overflow intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Availability,Mask,Mask,13,// If (Val & Mask) == C then all the masked bits are known and we can; // compute a value range based on that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:37,Availability,mask,masked,37,// If (Val & Mask) == C then all the masked bits are known and we can; // compute a value range based on that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Availability,Mask,Mask,13,// If (Val & Mask) != 0 then the value must be larger than the lowest set; // bit of Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:85,Availability,Mask,Mask,85,// If (Val & Mask) != 0 then the value must be larger than the lowest set; // bit of Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Usability,simpl,simplified,23,"// Check if Usr can be simplified to an integer constant when the value of one; // of its operands Op is an integer constant OpConstVal. If so, return it as an; // lattice value range with a single element or otherwise return an overdefined; // lattice value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Usability,simpl,simplified,23,// Check if Usr can be simplified to a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:45,Safety,avoid,avoid,45,// Check with isOperationFoldable() first to avoid linearly iterating; // over the operands unnecessarily which can be expensive for; // instructions with many operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,Integrability,inject,injective,376,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:95,Performance,perform,perform,95,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,Security,inject,injective,376,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:183,Performance,cache,cached,183,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:242,Performance,cache,cached,242,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:560,Performance,cache,cached,560,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:110,Usability,simpl,simplify,110,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,Energy Efficiency,allocate,allocated,20,"// If the cache was allocated, free it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:10,Performance,cache,cache,10,"// If the cache was allocated, free it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:113,Integrability,depend,dependencies,113,// We need to invalidate if we have either failed to preserve this analyses; // result directly or if any of its dependencies have been invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:364,Safety,avoid,avoiding,364,"/// Returns true if we can statically tell that this value will never be a; /// ""useful"" constant. In practice, this means we've got something like an; /// alloca or a malloc call for which a comparison against a constant can; /// only be guarding dead code. Note that we are potentially giving up some; /// precision in dead code (a constant result) in favour of avoiding a; /// expensive search for a easily answered common query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:927,Modifiability,extend,extending,927,"// Note: The following bit of code is somewhat distinct from the rest of LVI;; // LVI as a whole tries to compute a lattice value which is conservatively; // correct at a given location. In this case, we have a predicate which we; // weren't able to prove about the merged result, and we're pushing that; // predicate back along each incoming edge to see if we can prove it; // separately for each input. As a motivating example, consider:; // bb1:; // %v1 = ... ; constantrange<1, 5>; // br label %merge; // bb2:; // %v2 = ... ; constantrange<10, 20>; // br label %merge; // merge:; // %phi = phi [%v1, %v2] ; constantrange<1,20>; // %pred = icmp eq i32 %phi, 8; // We can't tell from the lattice value for '%phi' that '%pred' is false; // along each path, but by checking the predicate over each input separately,; // we can.; // We limit the search to one step backwards from the current BB and value.; // We could consider extending this to search further backwards through the; // CFG and/or value graph, but there are non-obvious compile time vs quality; // tradeoffs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:51,Safety,avoid,avoid,51,// Function entry or an unreachable block. Bail to avoid confusing; // analysis below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:209,Performance,cache,cached,209,"// This function prints the LVI analysis for the instruction I at the beginning; // of various basic blocks. It relies on calculated values that are stored in; // the LazyValueInfoCache, and in the absence of cached values, recalculate the; // LazyValueInfo for `I`, and print that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Availability,redundant,redundant,173,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:108,Safety,avoid,avoid,108,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Safety,redund,redundant,173,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:36,Availability,error,errors,36,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1251,Performance,Optimiz,Optimization,1251,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1349,Performance,optimiz,optimization,1349,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1427,Performance,optimiz,optimization,1427,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:58,Integrability,message,message,58,"/// A check failed, so printout out the condition and the message.; ///; /// This provides a nice place to put a breakpoint if you want to see why; /// something is not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:68,Integrability,Message,Message-only,68,/// A check failed (with values to print).; ///; /// This calls the Message-only version so that the above is easier to set; /// a breakpoint on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:89,Availability,error,error,89,"// end anonymous namespace; // Check - We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:95,Integrability,message,message,95,"// end anonymous namespace; // Check - We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:48,Integrability,depend,dependence,48,"// If both arguments are readonly, they have no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:159,Modifiability,variab,variable,159,// Check for buffer overflows and misalignment.; // Only handles memory references that read/write something simple like an; // alloca instruction or a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:109,Usability,simpl,simple,109,// Check for buffer overflows and misalignment.; // Only handles memory references that read/write something simple like an; // alloca instruction or a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:14,Security,access,access,14,"// OK, so the access is to a constant offset from Ptr. Check that Ptr is; // something we can handle and if so extract the size of this base object; // along with its alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:111,Security,access,accesses,111,// If the global may be defined differently in another compilation unit; // then don't warn about funky memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Security,Access,Accesses,3,// Accesses from before the start or after the end of the object are not; // defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Security,Access,Accesses,3,// Accesses that say that the memory is more aligned than it is are not; // defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:413,Performance,optimiz,optimized,413,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:267,Testability,log,logic,267,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:42,Usability,simpl,simple,42,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:304,Usability,simpl,simplify,304,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Safety,Detect,Detect,3,// Detect self-referential values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:25,Usability,Simpl,SimplifyInstruction,25,"// As a last resort, try SimplifyInstruction or constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:256,Availability,error,errors,256,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:106,Integrability,interface,interfaces,106,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:273,Integrability,message,messages,273,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:36,Availability,error,errors,36,"/// lintModule - Check a module for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:53,Integrability,message,messages,53,"/// lintModule - Check a module for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:7,Performance,Load,Loads,7,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:25,Performance,load,load,25,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:427,Performance,load,load,427,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:401,Usability,simpl,simple,401,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:37,Energy Efficiency,allocate,allocated,37,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:93,Performance,load,load,93,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:4,Testability,Test,Test,4,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:86,Usability,simpl,simple,86,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:157,Energy Efficiency,allocate,allocated,157,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:23,Safety,safe,safe,23,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:194,Security,access,accessed,194,"// As we recursed through GEPs to get here, we've incrementally checked; // that each step advanced by a multiple of the alignment. If our base is; // properly aligned, then the original offset accessed must also be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:9,Modifiability,refactor,refactor,9,/// TODO refactor this function to be able to search independently for; /// Dereferencability and Alignment requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:73,Security,access,accessing,73,"// TODO: It may be okay to round to align, but that would imply that; // accessing slightly out of bounds was legal, and we're currently; // inconsistent about that. For the moment, be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:194,Security,access,accessed,194,"// As we recursed through GEPs to get here, we've incrementally; // checked that each step advanced by a multiple of the alignment. If; // our base is properly aligned, then the original offset accessed; // must also be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:24,Performance,scalab,scalable,24,"// For unsized types or scalable vectors we don't know exactly how many bytes; // are dereferenced, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:198,Modifiability,variab,variable,198,"// When dereferenceability information is provided by a dereferenceable; // attribute, we know exactly how many bytes are dereferenceable. If we can; // determine the exact offset to the attributed variable, we can use that; // information here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:277,Performance,load,load,277,"/// Test if A and B will obviously have the same value.; ///; /// This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// \code; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; /// \endcode; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:4,Testability,Test,Test,4,"/// Test if A and B will obviously have the same value.; ///; /// This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// \code; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; /// \endcode; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:3,Testability,Test,Test,3,// Test if the values are trivially equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:3,Testability,Test,Test,3,"// Test if the values come from identical arithmetic instructions.; // Use isIdenticalToWhenDefined instead of isIdenticalTo because; // this function is only used when one address use dominates the; // other, which means that they'll always either have the same; // value or one of them will have an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:88,Safety,safe,safe,88,"// If given a uniform (i.e. non-varying) address, see if we can prove the; // access is safe within the loop w/o needing predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:78,Security,access,access,78,"// If given a uniform (i.e. non-varying) address, see if we can prove the; // access is safe within the loop w/o needing predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:50,Security,access,access,50,"// Otherwise, check to see if we have a repeating access pattern where we can; // prove that all accesses are well aligned and dereferenceable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:97,Security,access,accesses,97,"// Otherwise, check to see if we have a repeating access pattern where we can; // prove that all accesses are well aligned and dereferenceable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:28,Security,access,accesses,28,// TODO: Handle overlapping accesses.; // We should be computing AccessSize as (TC - 1) * Step + EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:65,Security,Access,AccessSize,65,// TODO: Handle overlapping accesses.; // We should be computing AccessSize as (TC - 1) * Step + EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:21,Security,access,access,21,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:37,Security,access,access,37,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:226,Security,access,accessing,226,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:60,Security,access,access,60,"// For the moment, restrict ourselves to the case where the access size is a; // multiple of the requested alignment and the base is aligned.; // TODO: generalize if a case found which warrants",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:25,Performance,load,load,25,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:120,Performance,perform,performs,120,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:195,Performance,load,load,195,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:270,Performance,load,load,270,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:519,Performance,load,load,519,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:187,Safety,safe,safe,187,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:262,Safety,safe,safe,262,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:506,Safety,safe,safe,506,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:420,Security,access,accessed,420,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:135,Performance,load,loaded,135,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:185,Performance,load,load,185,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:266,Performance,load,load,266,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:311,Performance,load,load,311,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:19,Performance,load,loads,19,"// Ignore volatile loads. The execution of a volatile load cannot; // be used to prove an address is backed by regular memory; it can,; // for example, point to an MMIO register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:54,Performance,load,load,54,"// Ignore volatile loads. The execution of a volatile load cannot; // be used to prove an address is backed by regular memory; it can,; // for example, point to an MMIO register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:43,Performance,load,loads,43,// Ignore volatile stores (see comment for loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,Availability,redundant,redundant,252,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:262,Performance,load,loads,262,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,Safety,redund,redundant,252,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:13,Performance,load,load,13,// Don't CSE load that is volatile or anything stronger than unordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:16,Performance,load,load,16,"// Check if the load and the store have the same base, constant offsets and; // non-overlapping access ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:96,Security,access,access,96,"// Check if the load and the store have the same base, constant offsets and; // non-overlapping access ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:49,Availability,avail,available,49,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:16,Performance,load,load,16,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:33,Performance,load,loaded,33,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:90,Performance,load,load,90,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:48,Availability,avail,available,48,"// If this is a store through Ptr, the value is available!; // (This is true even if the store is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:52,Performance,load,load,52,// Don't forward from (non-atomic) memset to atomic load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:51,Testability,test,test,51,// Restore ScanFrom to expected value in case next test succeeds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:17,Availability,avail,available,17,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:39,Performance,load,load,39,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:119,Security,access,access,119,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:166,Usability,simpl,simple,166,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:72,Performance,load,loaded,72,"// If we have alias analysis and it says the store won't modify the; // loaded value, ignore the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:60,Performance,load,load,60,"// If alias analysis claims that it really won't modify the load,; // ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:18,Availability,avail,available,18,"// Try to find an available value first, and delay expensive alias analysis; // queries until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:18,Availability,avail,available,18,"// If we found an available value, ensure that the instructions in between; // did not modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp:32,Performance,perform,perform,32,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp:408,Performance,perform,perform,408,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:422,Integrability,depend,dependence,422,"//===- LoopAccessAnalysis.cpp - Loop Access Analysis Implementation --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the loop memory dependence that was originally; // developed for the loop vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:37,Security,Access,Access,37,"//===- LoopAccessAnalysis.cpp - Loop Access Analysis Implementation --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the loop memory dependence that was originally; // developed for the loop vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Integrability,depend,dependences,15,/// We collect dependences up to this threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:80,Security,access,accesses,80,/// This enables versioning on the strides of symbolically striding memory; /// accesses in code like the following.; /// for (i = 0; i < N; ++i); /// A[i * Stride1] += B[i * Stride2] ...; ///; /// Will be roughly translated to; /// if (Stride1 == 1 && Stride2 == 1) {; /// for (i = 0; i < N; i+=4); /// A[i:i+3] += ...; /// } else; /// ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Performance,load,load,20,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Safety,detect,detection,45,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Testability,test,testing,105,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Testability,assert,assert,14,// Note: This assert is both overly strong and overly weak. The actual; // invariant here is that StrideSCEV should be loop invariant. The only; // such invariant strides we happen to speculate right now are unknowns; // and thus this is a reasonable proxy of the actual invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Security,access,access,45,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Security,access,access,86,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:111,Security,access,access,111,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:514,Security,access,access,514,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:148,Integrability,depend,depending,148,"// If either group contains multiple different pointers, bail out.; // TODO: Support multiple pointers by using the minimum or maximum pointer,; // depending on src & sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:24,Security,access,accessed,24,"// If either pointer is accessed multiple times, there may not be a clear; // src/sink relation. Bail out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:68,Usability,clear,clear,68,"// If either pointer is accessed multiple times, there may not be a clear; // src/sink relation. Bail out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:18,Security,access,accessed,18,"// If the sink is accessed before src, swap src/sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:139,Modifiability,extend,extended,139,// Only matching constant steps matching the AllocSize are supported at the; // moment. This simplifies the difference computation. Can be extended in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Usability,simpl,simplifies,93,// Only matching constant steps matching the AllocSize are supported at the; // moment. This simplifies the difference computation. Can be extended in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:17,Availability,down,down,17,"// When counting down, the dependence distance needs to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Integrability,depend,dependence,27,"// When counting down, the dependence distance needs to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:116,Safety,avoid,avoid,116,"// If the start values for both Src and Sink also vary according to an outer; // loop, then it's probably better to avoid creating diff checks because; // they may not be hoisted. We should instead let llvm::addRuntimeChecks; // do the expanded full range overlap checks, which can be hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Deployability,Update,Update,3,// Update the low bound expression if we've found a new min value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Deployability,Update,Update,3,// Update the high bound expression if we've found a new max value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:767,Deployability,update,update,767,"// We build the groups from dependency candidates equivalence classes; // because:; // - We know that pointers in the same equivalence class share; // the same underlying object and therefore there is a chance; // that we can compare pointers; // - We wouldn't be able to merge two pointers for which we need; // to emit a memcheck. The classes in DepCands are already; // conveniently built such that no two pointers in the same; // class need checking against each other.; // We use the following (greedy) algorithm to construct the groups; // For every pointer in the equivalence class:; // For each existing group:; // - if the difference between this pointer and the min/max bounds; // of the group is a constant, then make the pointer part of the; // group and update the min/max bounds of that group as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:28,Integrability,depend,dependency,28,"// We build the groups from dependency candidates equivalence classes; // because:; // - We know that pointers in the same equivalence class share; // the same underlying object and therefore there is a chance; // that we can compare pointers; // - We wouldn't be able to merge two pointers for which we need; // to emit a memcheck. The classes in DepCands are already; // conveniently built such that no two pointers in the same; // class need checking against each other.; // We use the following (greedy) algorithm to construct the groups; // For every pointer in the equivalence class:; // For each existing group:; // - if the difference between this pointer and the min/max bounds; // of the group is a constant, then make the pointer part of the; // group and update the min/max bounds of that group as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:560,Integrability,depend,dependence,560,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:1044,Integrability,depend,dependency,1044,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:115,Performance,perform,perform,115,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:638,Performance,perform,perform,638,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:295,Safety,safe,safe,295,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:282,Security,access,accesses,282,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:756,Security,access,accesses,756,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:138,Security,access,accesses,138,"// Go through all equivalence classes, get the ""pointer check groups""; // and add them to the overall solution. We use the order in which accesses; // appear in 'Pointers' to enforce determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:204,Integrability,depend,dependent,204,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:266,Performance,perform,performed,266,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:47,Security,access,accesses,47,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Performance,perform,perform,9,"// Don't perform more than a certain amount of comparisons.; // This should limit the cost of grouping the pointers to something; // reasonable. If we do end up hitting this threshold, the algorithm; // will create separate groups for all remaining pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependency,53,// Only need to check pointers between two different dependency sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,Integrability,depend,dependence,130,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Security,access,accesses,20,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:18,Security,access,access,18,/// Read or write access location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:19,Integrability,depend,dependences,19,// We're analyzing dependences across loop iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Performance,load,load,15,/// Register a load and whether it is only read from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:202,Integrability,depend,dependence,202,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:58,Security,Access,Access,58,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:137,Security,Access,Access,137,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:171,Security,access,access,171,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:95,Integrability,depend,dependent,95,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Security,access,accesses,25,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Security,access,accesses,105,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:82,Integrability,depend,dependency,82,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:192,Integrability,depend,dependency,192,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:74,Performance,perform,perform,74,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:141,Usability,clear,cleared,141,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Integrability,depend,dependence,23,/// We decided that no dependence analysis would be used. Reset the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:52,Security,access,accesses,52,"/// Adjust the MemoryLocation so that it represents accesses to this; /// location across all iterations, rather than a single one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Security,access,accessed,7,"// The accessed location varies within the loop, but remains within the; // underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:19,Usability,simpl,simplicity,19,"// For the sake of simplicity, drop the whole scope list if any scope is; // iteration-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Integrability,depend,dependency,105,/// Go over all memory access and check whether runtime pointer checks; /// are needed and build sets of dependency check candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Security,access,access,23,/// Go over all memory access and check whether runtime pointer checks; /// are needed and build sets of dependency check candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,accesses,15,/// Map of all accesses. Values are the types used to access memory pointed to; /// by the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:54,Security,access,access,54,/// Map of all accesses. Values are the types used to access memory pointed to; /// by the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:41,Integrability,depend,dependence,41,/// List of accesses that need a further dependence check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Security,access,accesses,12,/// List of accesses that need a further dependence check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Security,access,access,42,/// An alias set tracker to partition the access set by underlying object and; //intrinsic property (such as TBAA metadata).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:24,Integrability,depend,dependent,24,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:158,Integrability,depend,dependence,158,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:34,Security,access,accesses,34,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:263,Integrability,depend,dependency,263,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:417,Integrability,depend,dependent,417,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Performance,Perform,Perform,93,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:427,Security,access,accesses,427,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:363,Usability,clear,cleared,363,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,Integrability,wrap,wrap,43,/// Check whether a pointer address cannot wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,Security,access,accesses,112,// SCEV does not look through non-header PHIs inside the loop. Such phis; // can be analyzed by adding separate accesses for each incoming pointer; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:357,Integrability,depend,depends,357,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:208,Performance,load,load,208,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:484,Safety,safe,safety,484,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:36,Modifiability,extend,extend,36,// Find the pointer type we need to extend to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Integrability,depend,dependency,31,// When we run after a failing dependency check we have to make sure; // we don't have wrapping pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:87,Integrability,wrap,wrapping,87,// When we run after a failing dependency check we have to make sure; // we don't have wrapping pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Integrability,wrap,wrap,8,// Skip wrap checking when translating pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:67,Integrability,wrap,wrap,67,"// If there's only one option for Ptr, look it up after bounds and wrap; // checking, because assumptions might have been added to PSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:17,Integrability,depend,dependence,17,// The id of the dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Integrability,depend,dependence,27,// Each access has its own dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Security,access,access,8,// Each access has its own dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,access,33,// We assign a consecutive id to access from different alias sets.; // Accesses between different groups doesn't need to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:71,Security,Access,Accesses,71,// We assign a consecutive id to access from different alias sets.; // Accesses between different groups doesn't need to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependence,53,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Security,access,access,31,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:74,Security,Access,Accesses,74,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:40,Security,access,accesses,40,"// First, count how many write and read accesses are in the alias set. Also; // collect MemAccessInfos for later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:353,Integrability,depend,dependence,353,"// Note that this function computes CanDoRT and MayNeedRTCheck; // independently. For example CanDoRT=false, MayNeedRTCheck=false means that; // we have a pointer for which we couldn't find the bounds but we don't; // actually need to emit any checks so it does not matter.; //; // We need runtime checks for this alias set, if there are at least 2; // dependence sets (in which case RunningDepId > 2) or if we need to re-try; // any bound checks (because in that case the number of dependence sets is; // incomplete).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:483,Integrability,depend,dependence,483,"// Note that this function computes CanDoRT and MayNeedRTCheck; // independently. For example CanDoRT=false, MayNeedRTCheck=false means that; // we have a pointer for which we couldn't find the bounds but we don't; // actually need to emit any checks so it does not matter.; //; // We need runtime checks for this alias set, if there are at least 2; // dependence sets (in which case RunningDepId > 2) or if we need to re-try; // any bound checks (because in that case the number of dependence sets is; // incomplete).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Performance,perform,perform,14,"// We need to perform run-time alias checks, but some pointers had bounds; // that couldn't be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,Security,access,accesses,43,"// Reset the CanDoSetRt flag and retry all accesses that have failed.; // We know that we need these checks, so we can now be more aggressive; // and add further checks if required (overflow checks).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependency,53,// Only need to check pointers between two different dependency sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,Integrability,depend,dependence,130,"// We process the set twice: first we process read-write pointers, last we; // process read-only pointers. This allows us to skip dependence tests for; // read-only pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:141,Testability,test,tests,141,"// We process the set twice: first we process read-write pointers, last we; // process read-only pointers. This allows us to skip dependence tests for; // read-only pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:195,Integrability,depend,dependencies,195,"// The AliasSetTracker has nicely partitioned our pointers by metadata; // compatibility and potential for underlying-object overlap. As a result, we; // only need to check for potential pointer dependencies within each alias; // set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// Map of pointers to last access encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,Security,access,access,10,// Set of access to check after all writes have been processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Security,access,access,23,"// For a single memory access in AliasSetTracker, Accesses may contain; // both read and write, and they both need to be handled for CheckDeps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Security,Access,Accesses,50,"// For a single memory access in AliasSetTracker, Accesses may contain; // both read and write, and they both need to be handled for CheckDeps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Security,access,access,31,"// If we're using the deferred access set, then it contains only; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:259,Integrability,depend,dependence,259,"// If this is a write - check other reads and writes for conflicts. If; // this is a read only check other writes for conflicts (but only if; // there is no other write to the ptr - this is an optimization to; // catch ""a[i] = a[i] + "" without having to do a dependence check).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:193,Performance,optimiz,optimization,193,"// If this is a write - check other reads and writes for conflicts. If; // this is a read only check other writes for conflicts (but only if; // there is no other write to the ptr - this is an optimization to; // catch ""a[i] = a[i] + "" without having to do a dependence check).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:60,Integrability,wrap,wrapping,60,"/// Return true if an AddRec pointer \p Ptr is unsigned non-wrapping,; /// i.e. monotonically increasing/decreasing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:47,Integrability,wrap,wrapping,47,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:104,Integrability,wrap,wrapping,104,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:144,Integrability,wrap,wrapping,144,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:267,Integrability,wrap,wrapping,267,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:123,Modifiability,variab,variable,123,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:41,Integrability,wrap,wrapping,41,// The index in GEP is signed. It is non-wrapping if it's derived from a NSW; // AddRec using a NSW operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,Security,access,access,22,/// Check whether the access through \p Ptr has a constant stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Security,access,access,7,// The access function must stride over the innermost loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Security,access,access,11,// Strided access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:36,Integrability,wrap,wrap,36,"// The address calculation must not wrap. Otherwise, a dependence could be; // inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:55,Integrability,depend,dependence,55,"// The address calculation must not wrap. Otherwise, a dependence could be; // inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:76,Integrability,wrap,wrap,76,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:161,Integrability,depend,dependent,161,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:154,Security,access,access,154,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:127,Integrability,wrap,wrap,127,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:44,Security,access,access,44,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Security,access,access,86,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:143,Integrability,depend,dependences,143,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Performance,load,loads,6,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Performance,load,load,93,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:225,Performance,load,load,225,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:428,Performance,load,load,428,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:526,Performance,load,load,526,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:592,Performance,load,load,592,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Performance,load,load,50,// Compute the smallest VF at which the store and load would be misaligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:63,Performance,load,load,63,// If the number of vector iteration between the store and the load are; // small we could incur conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Integrability,depend,dependence-distance,12,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:315,Integrability,depend,dependence,315,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:64,Security,access,accesses,64,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:374,Security,access,accesses,374,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:160,Integrability,depend,dependence,160,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:380,Integrability,Depend,Dependence,380,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:488,Integrability,depend,dependence,488,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:580,Integrability,depend,dependence,580,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:120,Security,access,accesses,120,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:364,Testability,Test,Test,364,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:391,Testability,Test,Testing,391,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:668,Testability,test,test,668,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Integrability,depend,dependence,7,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:64,Modifiability,extend,extend,64,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:191,Modifiability,extend,extend,191,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Integrability,depend,dependence,14,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:150,Security,access,accesses,150,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:353,Security,access,accesses,353,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:276,Deployability,A/B,A/BPtr,276,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Integrability,depend,dependence,11,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Integrability,depend,dependence,86,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:164,Integrability,depend,dependence,164,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:332,Integrability,depend,dependence,332,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:260,Modifiability,variab,variables,260,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:82,Integrability,depend,dependence,82,"// If the induction step is negative we have to invert source and sink of the; // dependence when measuring the distance between them. We should not swap; // AIsWrite with BIsWrite, as their uses expect them in program order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Security,access,accesses,9,// Needs accesses where the addresses of the accessed underlying objects do; // not change within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Security,access,accessed,45,// Needs accesses where the addresses of the accessed underlying objects do; // not change within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:137,Integrability,wrap,wrap,137,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Security,access,accesses,8,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Integrability,depend,dependence,11,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:85,Integrability,depend,dependence,85,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:59,Security,access,access,59,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:28,Security,access,accesses,28,// Attempt to prove strided accesses independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:40,Integrability,depend,dependencies,40,// Negative distances are not plausible dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Deployability,update,update,23,"// There is no need to update MaxSafeVectorWidthInBits after call to; // couldPreventStoreLoadForward, even if it changed MinDepDistBytes,; // since a forward dependency will allow vectorization using any width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:159,Integrability,depend,dependency,159,"// There is no need to update MaxSafeVectorWidthInBits after call to; // couldPreventStoreLoadForward, even if it changed MinDepDistBytes,; // since a forward dependency will allow vectorization using any width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:1103,Safety,safe,safe,1103,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:491,Security,access,accesses,491,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,Integrability,depend,dependence,66,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Unsafe,Unsafe,3,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:506,Integrability,depend,dependence,506,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:403,Safety,unsafe,unsafe,403,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:431,Safety,safe,safe,431,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:501,Safety,safe,safe,501,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:472,Security,access,accesses,472,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:556,Security,access,accesses,556,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Deployability,update,update,31,// Sanity check that we didn't update MinDepDistBytes when calling; // couldPreventStoreLoadForward,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that we didn't update MinDepDistBytes when calling; // couldPreventStoreLoadForward,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Deployability,update,update,6,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:44,Deployability,update,update,44,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:110,Integrability,depend,dependency,110,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// Get the relevant memory access set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Security,access,accesses,9,// Check accesses within this set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,access,15,// Check every access pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Performance,load,loads,9,"// Check loads only against next equivalent class, but stores also against; // other stores in the same equivalence class - to the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,accessing,15,// Check every accessing instruction pair in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Security,access,accesses,12,"// Scan all accesses of another equivalence class, but only the next; // accesses of the same equivalent class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:73,Security,access,accesses,73,"// Scan all accesses of another equivalence class, but only the next; // accesses of the same equivalent class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,Integrability,depend,dependences,10,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:63,Integrability,depend,dependences,63,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:136,Integrability,depend,dependence,136,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:129,Safety,unsafe,unsafe,129,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:13,Performance,Load,Load,13,// Holds the Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,accesses,27,// Holds all the different accesses in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Performance,load,loads,33,// Scan the BB and collect legal loads and stores. Also detect any; // convergent instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:56,Safety,detect,detect,56,// Scan the BB and collect legal loads and stores. Also detect any; // convergent instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Avoid,Avoid,3,// Avoid hitting recordAnalysis multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:171,Safety,safe,safe,171,"// Many math library functions read the rounding mode. We will only; // vectorize a loop if it contains known function calls that don't set; // the flag. Therefore, it is safe to ignore this read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:16,Performance,load,load,16,"// If this is a load, save it. If this instruction can read from memory; // but is not a load, then we quit. Notice that we don't handle function; // calls that read or write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:89,Performance,load,load,89,"// If this is a load, save it. If this instruction can read from memory; // but is not a load, then we quit. Notice that we don't handle function; // calls that read or write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,Safety,safe,safely,66,"// If the function has an explicit vectorized counterpart, we can safely; // assume that it can be vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:30,Safety,Abort,Abort,30,// Save 'store' instructions. Abort if other instructions write to memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:39,Performance,load,loads,39,"// Now we have two lists that hold the loads and the stores.; // Next, we find the pointers that they use.; // Check if we see any stores. If there are no stores, then we don't; // care if the pointers are *restrict*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:128,Security,access,accessed,128,"// Holds the analyzed pointers. We don't want to call getUnderlyingObjects; // multiple times on the same object. If the ptr is accessed twice, once; // for read and once for write, it will only appear once (on the write; // list). This is okay, since we are going to check for conflicts between; // writes and between reads and writes, but not between reads and reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Integrability,depend,dependency,42,"// The TBAA metadata could have a control dependency on the predication; // condition, so we cannot rely on it when determining whether or not we; // need runtime pointer checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:29,Integrability,depend,dependency,29,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Performance,load,load,50,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,Safety,unsafe,unsafe,22,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Integrability,depend,dependency,42,"// The TBAA metadata could have a control dependency on the predication; // condition, so we cannot rely on it when determining whether or not we; // need runtime pointer checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,Safety,safe,safe,112,// If we write (or read-write) to a single destination and there are no; // other reads in this loop then is it safe to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Integrability,depend,dependence,9,// Build dependence sets and check whether we need a runtime pointer bounds; // check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:13,Integrability,depend,dependency,13,// Clear the dependency checks. We assume they are not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear the dependency checks. We assume they are not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:32,Integrability,depend,dependence,32,// Emit remark for first unsafe dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Safety,unsafe,unsafe,25,// Emit remark for first unsafe dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:32,Security,access,access,32,"/// Get the stride of a pointer access in a loop. Looks for symbolic; /// strides ""a[i*stride]"". Returns the symbolic stride, or null otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// The size of the pointer access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Security,access,access,25,// Strip off the size of access multiplication if we are still analyzing the; // pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:317,Security,expose,exposes,317,"// Note: getStrideFromPointer is a *profitability* heuristic. We; // could broaden the scope of values returned here - to anything; // which happens to be loop invariant and contributes to the; // computation of an interesting IV - but we chose not to as we; // don't have a cost model here, and broadening the scope exposes; // far too many unprofitable cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:768,Availability,avail,available,768,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:564,Integrability,depend,dependences,564,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:122,Performance,optimiz,optimize,122,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Avoid,Avoid,3,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:555,Security,access,accesses,555,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:636,Testability,test,test,636,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:122,Modifiability,extend,extend,122,"// Match the types so we can compare the stride and the BETakenCount.; // The Stride can be positive/negative, so we sign extend Stride;; // The backedgeTakenCount is non-negative, so we zero extend BETakenCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:192,Modifiability,extend,extend,192,"// Match the types so we can compare the stride and the BETakenCount.; // The Stride can be positive/negative, so we sign extend Stride;; // The backedgeTakenCount is non-negative, so we zero extend BETakenCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Security,access,accesses,20,// List the pair of accesses need run-time checks to prove independence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Integrability,depend,depend,33,// Check whether the analyses we depend on became invalid for any reason.; // Skip checking TargetLibraryAnalysis as it is immutable and can't become; // invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:337,Integrability,depend,dependencies,337,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:472,Integrability,depend,dependencies,472,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:536,Testability,log,logic,536,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:82,Usability,clear,clear,82,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:383,Usability,clear,clear,383,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:166,Performance,cache,cache,166,"// Note that the LoopInfo may be stale at this point, however the loop; // objects themselves remain the only viable keys that could be in the; // analysis manager's cache. So we just walk the keys and forcibly clear; // those results. Note that the order doesn't matter here as this will just; // directly destroy the results without calling methods on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:211,Usability,clear,clear,211,"// Note that the LoopInfo may be stale at this point, however the loop; // objects themselves remain the only viable keys that could be in the; // analysis manager's cache. So we just walk the keys and forcibly clear; // those results. Note that the order doesn't matter here as this will just; // directly destroy the results without calling methods on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:175,Availability,reliab,reliably,175,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:111,Usability,clear,clear,111,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:230,Usability,clear,clear,230,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:60,Performance,cache,cached,60,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:298,Performance,cache,cache,298,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:190,Testability,log,logic,190,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:36,Performance,Cache,Cache,36,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:487,Performance,cache,cache,487,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:587,Performance,Optimiz,Optimizations,587,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:819,Performance,cache,cache,819,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:188,Modifiability,config,configurable,188,"// In this analysis two array references are considered to exhibit temporal; // reuse if they access either the same memory location, or a memory location; // with distance smaller than a configurable threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:94,Security,access,access,94,"// In this analysis two array references are considered to exhibit temporal; // reuse if they access either the same memory location, or a memory location; // with distance smaller than a configurable threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:68,Performance,cache,cache,68,// the difference between the last subscripts must be less than the cache line; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:13,Integrability,depend,dependence,13,// Check the dependence distance at every loop level. There is temporal reuse; // if the distance at the given loop's depth is small (|d| <= MaxDistance) and; // it is zero at every other loop level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:167,Security,access,accessing,167,"// If the indexed reference is not 'consecutive' the cost is proportional to; // the trip count and the depth of the dimension which the subject loop; // subscript is accessing. We try to estimate this by multiplying the cost; // by the trip counts of loops corresponding to the inner dimensions. For; // example, given the indexed reference 'A[i][j][k]', and assuming the; // i-loop is in the innermost position, the cost would be equal to the; // iterations of the i-loop multiplied by iterations of the j-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:67,Security,access,access,67,// Attempt to determine whether we have a single dimensional array access.; // before giving up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:20,Security,access,accessed,20,"// The array may be accessed in reverse, for example:; // for (i = N; i > 0; i--); // A[i] = 0;; // In this case, reconstruct the access function using the absolute value; // of the step recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:130,Security,access,access,130,"// The array may be accessed in reverse, for example:; // for (i = N; i > 0; i--); // A[i] = 0;; // In this case, reconstruct the access function using the absolute value; // of the step recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:98,Modifiability,variab,variable,98,// The indexed reference is loop invariant if none of the coefficients use; // the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:99,Modifiability,variab,variable,99,// The indexed reference is 'consecutive' if the only coefficient that uses; // the loop induction variable is the last one...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:45,Performance,cache,cache,45,// ...and the access stride is less than the cache line size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:14,Security,access,access,14,// ...and the access stride is less than the cache line size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:299,Modifiability,extend,extended,299,"// FIXME: This assumes that all values are signed integers which may; // be incorrect in unusual codes and incorrectly use sext instead of zext.; // for (uint32_t i = 0; i < 512; ++i) {; // uint8_t trunc = i;; // A[trunc] = 42;; // }; // This consecutively iterates twice over A. If `trunc` is sign-extended,; // we would conclude that this may iterate backwards over the array.; // However, LoopCacheAnalysis is heuristic anyway and transformations must; // not result in wrong optimizations if the heuristic was incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:479,Performance,optimiz,optimizations,479,"// FIXME: This assumes that all values are signed integers which may; // be incorrect in unusual codes and incorrectly use sext instead of zext.; // for (uint32_t i = 0; i < 512; ++i) {; // uint8_t trunc = i;; // A[trunc] = 42;; // }; // This consecutively iterates twice over A. If `trunc` is sign-extended,; // we would conclude that this may iterate backwards over the array.; // However, LoopCacheAnalysis is heuristic anyway and transformations must; // not result in wrong optimizations if the heuristic was incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:85,Performance,Cache,CacheCost,85,//===----------------------------------------------------------------------===//; // CacheCost implementation; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:351,Integrability,depend,depending,351,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:460,Performance,cache,cache,460,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:37,Security,access,access,37,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:144,Security,access,access,144,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:268,Security,access,access,268,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:470,Security,access,access,470,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Testability,Test,Test,3,// Test if the value is already loop-invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:131,Integrability,depend,dependent,131,// There is possibility of hoisting this instruction above some arbitrary; // condition. Any metadata defined on it can be control dependent on this; // condition. Conservatively strip it here so that we don't give any wrong; // information to the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:248,Performance,optimiz,optimizer,248,// There is possibility of hoisting this instruction above some arbitrary; // condition. Any metadata defined on it can be control dependent on this; // condition. Conservatively strip it here so that we don't give any wrong; // information to the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:49,Modifiability,variab,variable,49,/// Return the final value of the loop induction variable if found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:74,Performance,optimiz,optimizations,74,"// Tokens can't be used in PHI nodes and live-out tokens prevent loop; // optimizations, so for the purposes of considered LCSSA form, we; // can ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Integrability,Rout,Routines,3,// Routines that reform the loop CFG and split edges often fail on indirectbr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:7,Performance,scalab,scalable,7,// For scalable 'contains' check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:158,Integrability,depend,dependencies,158,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:110,Performance,optimiz,optimization,110,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:292,Security,access,access,292,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:256,Integrability,rout,routine,256,// The memory instruction can refer to the loop identifier metadata; // directly or indirectly through another list metadata (in case of; // nested parallel loops). The loop identifier metadata refers to; // itself so we can check both cases with the same routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:32,Deployability,Update,Update,32,"// end anonymous namespace; /// Update the parent loop for all blocks that are directly contained within the; /// original ""unloop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Performance,Perform,Perform,3,"// Perform a post order CFG traversal of all blocks within this loop,; // propagating the nearest loop from successors to predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:97,Performance,cache,cached,97,// Each irreducible loop within the unloop induces a round of iteration using; // the DFS result cached by Traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:4,Deployability,Update,Update,4,/// Update the parent loop for all subloops directly nested within unloop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:218,Deployability,update,update,218,"/// Return the nearest parent loop among this block's successors. If a successor; /// is a subloop header, consider its parent to be the nearest parent of the; /// subloop's exits.; ///; /// For subloop blocks, simply update SubloopParents and return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:211,Usability,simpl,simply,211,"/// Return the nearest parent loop among this block's successors. If a successor; /// is a subloop header, consider its parent to be the nearest parent of the; /// subloop's exits.; ///; /// For subloop blocks, simply update SubloopParents and return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:54,Usability,simpl,simplify,54,// First handle the special case of no parent loop to simplify the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Deployability,Update,Update,3,// Update the parent loop for all blocks within the loop. Blocks within; // subloops will not change parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:19,Safety,avoid,avoid,19,"// Add metadata to avoid reapplying a transformation, such as; // llvm.loop.unroll.disable and llvm.loop.isvectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:203,Performance,perform,perform,203,"// LoopInfoWrapperPass is a FunctionPass, but verifying every loop in the; // function each time verifyAnalysis is called is very expensive. The; // -verify-loop-info option can enable this. In order to perform some; // checking by default, LoopPass has been taught to call verifyLoop manually; // during loop pass sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:170,Modifiability,variab,variable,170,"// Determine whether instructions in a basic block are one of:; // - the inner loop guard comparison; // - the outer loop latch comparison; // - the outer loop induction variable increment; // - a phi node, a cast or a branch",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:82,Safety,unsafe,unsafe,82,// Check the code surrounding the inner loop for instructions that are deemed; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:82,Safety,unsafe,unsafe,82,// Check the code surrounding the inner loop for instructions that are deemed; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:22,Safety,avoid,avoid,22,// Visited is used to avoid running into an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:441,Performance,optimiz,optimization,441,"//===- LoopPass.cpp - Loop Pass and Loop Pass Manager ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements LoopPass and LPPassManager. All loop optimization; // and transformation passes are derived from LoopPass. LPPassManager is; // responsible for managing LoopPasses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:50,Performance,queue,queue,50,// Insert loop into loop nest (LoopInfo) and loop queue (LQ).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:26,Performance,queue,queue,26,// Insert L into the loop queue after the parent loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:45,Performance,queue,queue,45,"// If this loop appears elsewhere within the queue, we also need to remove it; // there. However, we have to be careful to not remove the back of the queue; // as that is assumed to match the current loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:150,Performance,queue,queue,150,"// If this loop appears elsewhere within the queue, we also need to remove it; // there. However, we have to be careful to not remove the back of the queue; // as that is assumed to match the current loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:43,Performance,queue,queue,43,// Add this loop back onto the back of the queue to preserve our invariants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the function, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:11,Modifiability,inherit,inherited,11,// Collect inherited analysis from Module level pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:21,Performance,queue,queue,21,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:213,Performance,optimiz,optimizing,213,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:65,Usability,clear,clear,65,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:277,Usability,clear,clear,277,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:3,Deployability,Update,Update,3,"// Update the size of the function, emit a remark, and update the; // size of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:55,Deployability,update,update,55,"// Update the size of the function, emit a remark, and update the; // size of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:28,Deployability,release,release,28,"// If the loop was deleted, release all the loop passes. This frees up; // some memory, and avoids trouble with the pass manager trying to call; // verifyAnalysis on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:92,Safety,avoid,avoids,92,"// If the loop was deleted, release all the loop passes. This frees up; // some memory, and avoids trouble with the pass manager trying to call; // verifyAnalysis on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:21,Performance,queue,queue,21,// Pop the loop from queue after running all passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:72,Availability,avail,available,72,"// Check if this pass is suitable for the current LPPassManager, if; // available. This pass P is not suitable for a LPPassManager if P; // is not preserving higher level analysis info used by other; // LPPassManager passes. In such case, pop LPPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:17,Performance,Optimiz,OptimizeNone,17,// Check for the OptimizeNone attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:42,Performance,queue,queue,42,// FIXME: Delete loop from pass manager's queue?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:563,Performance,optimiz,optimizations,563,"//===- LoopUnrollAnalyzer.cpp - Unrolling Effect Estimation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:446,Safety,predict,predicting,446,"//===- LoopUnrollAnalyzer.cpp - Unrolling Effect Estimation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify instruction \param I using its SCEV expression.; ///; /// The idea is that some AddRec expressions become constants, which then; /// could trigger folding of other instructions. However, that only happens; /// for expressions whose start value is also constant, which isn't always the; /// case. In another common and important case the start value is just some; /// address (i.e. SCEVUnknown) - in this case we compute the offset and save; /// it along with the base address instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify binary operator I.; ///; /// TODO: Probably it's worth to hoist the code for estimating the; /// simplifications effects to a separate class, since we have a very similar; /// code in InlineCost already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:117,Usability,simpl,simplifications,117,"/// Try to simplify binary operator I.; ///; /// TODO: Probably it's worth to hoist the code for estimating the; /// simplifications effects to a separate class, since we have a very similar; /// code in InlineCost already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:16,Performance,load,load,16,/// Try to fold load I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:28,Performance,load,loads,28,// We're only interested in loads that can be completely folded to a; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:26,Performance,load,load,26,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:151,Performance,load,loads,151,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:133,Usability,simpl,simplify,133,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:91,Performance,perform,perform,91,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:103,Performance,optimiz,optimization,103,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:56,Security,access,accesses,56,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:91,Performance,perform,perform,91,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:103,Performance,optimiz,optimization,103,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:56,Security,access,accesses,56,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,/// Try to simplify cast instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:36,Usability,Simpl,SimplifiedValues,36,"// The cast can be invalid, because SimplifiedValues contains results of SCEV; // analysis, which operates on integers (and, e.g., might convert i8* null to; // i32 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,/// Try to simplify cmp instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:23,Usability,simpl,simplified,23,// First try to handle simplified comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:451,Energy Efficiency,allocate,allocate,451,"//===- MemoryBuiltins.cpp - Identify calls to memory builtins -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions identifies calls to builtin functions that allocate; // or free memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Energy Efficiency,allocate,allocates,3,// allocates; never returns null,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Energy Efficiency,allocate,allocates,3,// allocates; may return null,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:74,Usability,Simpl,SimplifyLibCalls,74,"// clang-format off; // FIXME: certain users need more information. E.g., SimplifyLibCalls needs to; // know which functions are nounwind, noalias, nocapture parameters, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:9,Performance,perform,perform,9,"// Don't perform a slow TLI lookup, if this function doesn't return a pointer; // and thus can't be an allocation function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:34,Availability,avail,available,34,// Make sure that the function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:54,Energy Efficiency,allocate,allocated,54,"// Because allocsize only tells us how many bytes are allocated, we're not; // really allowed to assume anything, so we use MallocLike.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a functions is a call or invoke to a library function that; /// reallocates memory (e.g., realloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:32,Integrability,depend,dependent,32,"// Note: Removability is highly dependent on the source language. For; // example, recent C++ requires direct calls to the global allocation; // [basic.stc.dynamic.allocation] to be observable unless part of a new; // expression [expr.new paragraph 13].; // Historically we've treated the C family allocation routines and operator; // new as removable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:309,Integrability,rout,routines,309,"// Note: Removability is highly dependent on the source language. For; // example, recent C++ requires direct calls to the global allocation; // [basic.stc.dynamic.allocation] to be observable unless part of a new; // expression [expr.new paragraph 13].; // Historically we've treated the C family allocation routines and operator; // new as removable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:279,Integrability,depend,depending,279,"/// When we're compiling N-bit code, and the user uses parameters that are; /// greater than N bits (e.g. uint64_t on a 32-bit build), we can run into; /// trouble with APInt size issues. This function handles resizing + overflow; /// checks for us. Check and zext or trunc \p I depending on IntTyBits and; /// I's value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:92,Performance,perform,performed,92,"// Get the index type for this address space, results and intermediate; // computations are performed at that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:249,Modifiability,variab,variables,249,"/// Compute the size of the object pointed by Ptr. Returns true and the; /// object size in Size if successful, and false otherwise.; /// If RoundToAlign is true, then Size is rounded up to the alignment of; /// allocas, byval arguments, and global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:46,Availability,failure,failure,46,// FIXME: Does it make sense to just return a failure value if the size won't; // fit in the output and `!MustSucceed`?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:62,Security,access,access,62,"// If we've outside the end of the object, then we can always access; // exactly 0 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Performance,Cache,Cache,3,"// Cache the result for later visits. If we happened to visit this during; // the above recursion, we would consider it unknown until now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:10,Availability,error,error,10,// Is the error status of posix_memalign correctly checked? If not it; // would be incorrect to assume it succeeds and load doesn't see the; // previous value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:119,Performance,load,load,119,// Is the error status of posix_memalign correctly checked? If not it; // would be incorrect to assume it succeeds and load doesn't see the; // previous value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:167,Integrability,depend,dependency,167,"// Erase everything that was computed in this iteration from the cache, so; // that no dangling references are left behind. We could be a bit smarter if; // we kept a dependency graph. It's probably not worth the complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:65,Performance,cache,cache,65,"// Erase everything that was computed in this iteration from the cache, so; // that no dangling references are left behind. We could be a bit smarter if; // we kept a dependency graph. It's probably not worth the complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:40,Performance,cache,cached,40,// non-computable results can be safely cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:33,Safety,safe,safely,33,// non-computable results can be safely cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:9,Performance,cache,cache,9,// Check cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:15,Performance,Cache,CacheIt,15,// Don't reuse CacheIt since it may be invalid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:28,Performance,cache,cache,28,// Insert right away in the cache to handle recursive PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:503,Integrability,depend,depends,503,"//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an analysis that determines, for a given memory; // operation, what preceding memory operations it depends on. It builds on; // alias analysis information, and tries to provide a lazy, caching interface to; // a common kind of alias information query.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:597,Integrability,interface,interface,597,"//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an analysis that determines, for a given memory; // operation, what preceding memory operations it depends on. It builds on; // alias analysis information, and tries to provide a lazy, caching interface to; // a common kind of alias information query.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Integrability,depend,dependencies,41,/// Private helper for finding the local dependencies of a call site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,Integrability,depend,dependencies,49,"// Walk backwards through the block, looking for dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:32,Integrability,depend,dependences,32,// Debug intrinsics don't cause dependences and should not affect Limit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:100,Testability,test,testcases,100,// Limit the amount of scanning we do so we don't end up with quadratic; // running time on extreme testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Security,access,accessed,51,"// If this inst is a memory op, get the pointer it accessed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:5,Usability,simpl,simple,5,// A simple instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,Availability,redundant,redundant,86,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,Safety,redund,redundant,86,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Integrability,depend,dependency,122,// If we could not obtain a pointer for the instruction and the instruction; // touches memory then assume that this is a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Integrability,depend,dependency,29,"// Non-local invariant group dependency indicates there is non local Def; // (it only returns nonLocal if it finds nonLocal def), which is better than; // local clobber and everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:90,Availability,down,down,90,// Take the ptr operand after all casts and geps 0. This way we can search; // cast graph down only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Safety,safe,safe,15,"// It's is not safe to walk the use list of global value, because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside; // of current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:3,Performance,Queue,Queue,3,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:56,Performance,load,load,56,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,queue,queue,51,// Bitcast or gep with zeros are using Ptr. Add to queue to check it's; // users. U = bitcast Ptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:13,Performance,load,load,13,// If we hit load/store with the same invariant.group metadata (and the; // same pointer operand) we can assume that value pointed by pointer; // operand didn't change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:71,Integrability,depend,dependency,71,"// Def(U) can't be returned here because it is non-local. If local; // dependency won't be found then return nonLocal counting that the; // user will call getNonLocalPointerDependency, which will return cached; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:203,Performance,cache,cached,203,"// Def(U) can't be returned here because it is non-local. If local; // dependency won't be found then return nonLocal counting that the; // user will call getNonLocalPointerDependency, which will return cached; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:248,Performance,load,loaded,248,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,Safety,safe,safely,49,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:479,Deployability,release,release,479,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:677,Deployability,release,release,677,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:861,Deployability,release,release,861,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1354,Deployability,release,release,1354,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:890,Integrability,synchroniz,synchronization,890,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:732,Performance,load,load,732,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1128,Performance,load,load,1128,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1279,Performance,optimiz,optimization,1279,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1450,Performance,load,load,1450,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:750,Safety,unsafe,unsafe,750,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1268,Safety,detect,detect,1268,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,Security,access,accesses,34,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:198,Security,access,access,198,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:522,Security,access,access,522,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1409,Security,access,accesses,1409,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:313,Testability,test,testing,313,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1678,Testability,log,logic,1678,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:171,Usability,simpl,simple,171,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:259,Usability,simpl,simple,259,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:603,Usability,intuit,intuition,603,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Performance,Load,Load,42,"// True for volatile instruction.; // For Load/Store return true if atomic ordering is stronger than AO,; // for other instruction just true if it can read or write to memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:55,Integrability,depend,dependencies,55,"// Walk backwards through the basic block, looking for dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:44,Integrability,depend,dependencies,44,// Debug intrinsics don't (and can't) cause dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:100,Testability,test,testcases,100,// Limit the amount of scanning we do so we don't end up with quadratic; // running time on extreme testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Integrability,depend,depend,10,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:87,Integrability,depend,depends,87,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:192,Integrability,depend,depend,192,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,load,loads,20,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:82,Performance,load,load,82,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:119,Performance,load,load,119,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:173,Performance,load,loads,173,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:212,Performance,load,load,212,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:266,Performance,load,load,266,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:312,Security,access,accessing,312,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:143,Safety,safe,safely,143,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Security,access,access,18,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:113,Security,access,accesses,113,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:178,Security,access,accesses,178,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Performance,load,loads,10,// Atomic loads have complications involved.; // A Monotonic (or higher) load is OK if the query inst is itself not; // atomic.; // FIXME: This is overly conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:73,Performance,load,load,73,// Atomic loads have complications involved.; // A Monotonic (or higher) load is OK if the query inst is itself not; // atomic.; // FIXME: This is overly conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,load,loads,16,// Must aliased loads are defs of each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:32,Integrability,depend,depend,32,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:67,Integrability,depend,dependence,67,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,load,loads,20,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Performance,load,loads,22,// Stores don't alias loads from read-only memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Integrability,depend,depend,10,// Stores depend on may/must aliased loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,load,loads,37,// Stores depend on may/must aliased loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:146,Deployability,release,release,146,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:200,Deployability,release,release,200,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:340,Deployability,release,release,340,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:377,Deployability,Release,Release,377,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:99,Performance,load,load,99,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:440,Safety,safe,safe,440,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:333,Usability,simpl,simple,333,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Security,access,access,18,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:113,Security,access,accesses,113,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:169,Security,access,accesses,169,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:136,Integrability,depend,dependence,136,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:173,Performance,optimiz,optimized,173,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:213,Performance,load,load,213,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:53,Security,access,accessed,53,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:159,Security,access,access,159,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:77,Integrability,depend,dependency,77,"// If we found a select instruction for MemLoc pointer, return it as Def; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:5,Deployability,release,release,5,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:201,Integrability,depend,dependency,201,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:117,Performance,load,loads,117,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:220,Performance,load,loads,220,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:76,Performance,load,load,76,"// If the call is known to never store to the pointer, and if this is a; // load query, we can safely ignore it (scan past it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:95,Safety,safe,safely,95,"// If the call is known to never store to the pointer, and if this is a; // load query, we can safely ignore it (scan past it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Integrability,depend,dependence,35,"// Otherwise, there is a potential dependence. Return a clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,cache,cached,15,// Check for a cached result,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:68,Integrability,depend,depends,68,"// If the cached entry is non-dirty, just return it. Note that this depends; // on MemDepResult's default constructing to 'dirty'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Performance,cache,cached,10,"// If the cached entry is non-dirty, just return it. Note that this depends; // on MemDepResult's default constructing to 'dirty'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cache,64,/// This method is used when -debug is specified to verify that cache arrays; /// are properly kept sorted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cached,64,"// This is the set of blocks that need to be recomputed. In the cached case,; // this can happen due to instructions being deleted etc. In the uncached; // case, this starts out as the set of predecessors we care about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,cache,cache,19,"// Okay, we have a cache entry. If we know it is not dirty, just return it; // with no computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:12,Performance,cache,cache,12,// Sort the cache so that we can do fast binary search lookups below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Deployability,update,update,41,// Iterate while we still have blocks to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:83,Performance,cache,cache,83,"// Do a binary search to see if we already have an entry for this block in; // the cache set. If so, find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:43,Deployability,update,update,43,"// Otherwise, remember this slot so we can update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Integrability,depend,dependency,38,// Find out if this block has a local dependency for QueryInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // a clobber, otherwise it is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Deployability,update,update,42,"// If we had a dirty entry for the block, update it. Otherwise, just add; // a new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Integrability,depend,dependency,22,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the association!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:73,Deployability,update,update,73,// Keep the ReverseNonLocalDeps map up to date so we can efficiently; // update this when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Energy Efficiency,efficient,efficiently,57,// Keep the ReverseNonLocalDeps map up to date so we can efficiently; // update this when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,load,load,51,"// If the block *is* completely transparent to the load, we need to check; // the predecessors of this block. Add them to our worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,Performance,cache,cached,21,// Check if there is cached Def with invariant.group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:8,Integrability,rout,routine,8,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:236,Security,access,accesses,236,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:168,Availability,avail,available,168,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:79,Performance,cache,cached,79,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:101,Performance,Cache,Cache,101,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:149,Performance,cache,cache,149,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:231,Performance,cache,cache,231,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:83,Performance,cache,cache,83,"// Do a binary search to see if we already have an entry for this block in; // the cache set. If so, find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,Integrability,depend,dependency,60,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:144,Integrability,depend,dependency,144,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cached,7,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Performance,load,load,35,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:93,Performance,load,load,93,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Performance,load,load,122,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:84,Integrability,depend,dependency,84,"// If we have a cached entry, and it is non-dirty, use it as the value for; // this dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,cache,cached,16,"// If we have a cached entry, and it is non-dirty, use it as the value for; // this dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cache,64,"// Otherwise, we have to scan for the value. If we have a dirty cache; // entry, start scanning from its position, otherwise we scan from the end; // of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:48,Deployability,update,update,48,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,Cache,Cache,37,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,Integrability,depend,dependency,26,// Scan the block for the dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:9,Performance,cache,cache,9,// Don't cache results for invariant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,load,load,37,// Don't cache results for invariant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Deployability,update,update,42,"// If we had a dirty entry for the block, update it. Otherwise, just add; // a new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Integrability,depend,dependency,22,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the reverse association because we just added it; // to Cache!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:155,Performance,Cache,Cache,155,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the reverse association because we just added it; // to Cache!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:76,Deployability,update,update,76,// Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently; // update MemDep when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,Energy Efficiency,efficient,efficiently,60,// Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently; // update MemDep when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Performance,cache,cache,29,"/// Sort the NonLocalDepInfo cache, given a certain number of elements in the; /// array that are already properly ordered.; ///; /// This is optimized for the case when only a few entries are added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:142,Performance,optimiz,optimized,142,"/// Sort the NonLocalDepInfo cache, given a certain number of elements in the; /// array that are already properly ordered.; ///; /// This is optimized for the case when only a few entries are added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:14,Integrability,depend,dependency,14,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:414,Integrability,depend,dependence,414,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:553,Integrability,depend,dependence,553,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:634,Integrability,depend,dependence,634,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:4,Performance,Perform,Perform,4,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,cache,cached,15,// Look up the cached info for Pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:79,Performance,Cache,CacheKey,79,"// Set up a temporary NLPI value. If the map doesn't yet have an entry for; // CacheKey, this value will be inserted as the associated value. Otherwise,; // it'll be ignored, and we'll have to check to see if the cached size and; // aa tags are consistent with the current query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:213,Performance,cache,cached,213,"// Set up a temporary NLPI value. If the map doesn't yet have an entry for; // CacheKey, this value will be inserted as the associated value. Otherwise,; // it'll be ignored, and we'll have to check to see if the cached size and; // aa tags are consistent with the current query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,Cache,CacheKey,20,"// Get the NLPI for CacheKey, inserting one into the map if it doesn't; // already have one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:24,Performance,cache,cache,24,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:45,Performance,Cache,CacheKey,45,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:104,Performance,cache,cache,104,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:153,Performance,load,loads,153,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:40,Performance,cache,cached,40,// The query's Size is greater than the cached one. Throw out the; // cached data and proceed with the query at the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:70,Performance,cache,cached,70,// The query's Size is greater than the cached one. Throw out the; // cached data and proceed with the query at the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:157,Performance,cache,cache,157,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Usability,clear,cleared,16,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,cache,cached,38,// This query's Size is less than the cached one. Conservatively restart; // the query using the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,cache,cached,51,"// If the query's AATags are inconsistent with the cached one,; // conservatively throw out the cached data and restart the query with; // no tag if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:96,Performance,cache,cached,96,"// If the query's AATags are inconsistent with the cached one,; // conservatively throw out the cached data and restart the query with; // no tag if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:157,Performance,cache,cache,157,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Usability,clear,cleared,16,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,cache,cached,20,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:139,Performance,cache,cached,139,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:172,Performance,load,loads,172,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:218,Performance,load,loads,218,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,cache,cached,19,"// We have a fully cached result for this query then we can just return the; // cached results and populate the visited set. However, we have to verify; // that we don't already have conflicting results for these blocks. Check; // to ensure that if a block in the results set is in the visited set that; // it was for the same pointer query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:80,Performance,cache,cached,80,"// We have a fully cached result for this query then we can just return the; // cached results and populate the visited set. However, we have to verify; // that we don't already have conflicting results for these blocks. Check; // to ensure that if a block in the results set is in the visited set that; // it was for the same pointer query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:150,Performance,cache,cached,150,"// We have a pointer mismatch in a block. Just return false, saying; // that something was clobbered in this result. We could also do a; // non-fully cached query, but there is little point in doing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:366,Deployability,update,update,366,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:66,Performance,cache,cache,66,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:170,Performance,cache,cache,170,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:264,Performance,cache,cache,264,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:314,Performance,load,loads,314,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:333,Performance,cache,cache,333,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:377,Performance,Cache,CacheInfo,377,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:65,Performance,cache,cached,65,"// Keep track of the entries that we know are sorted. Previously cached; // entries will all be sorted. The entries we add we only sort on demand (we; // don't insert every element into its sorted position). We know that we; // won't get any reuse from currently inserted values, because we don't; // revisit blocks after we insert info for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:102,Integrability,rout,routines,102,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:136,Performance,cache,cache,136,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:178,Performance,cache,cache,178,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:27,Performance,Cache,Cache,27,"// Since we bail out, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:232,Usability,Clear,Clear,232,"// Since we bail out, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Integrability,depend,dependency,15,// Analyze the dependency of *Pointer in FromBB. See if we already have; // been here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:11,Integrability,depend,dependency,11,"// Get the dependency info for Pointer in BB. If we have cached; // information, we will use it, otherwise we compute it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Performance,cache,cached,57,"// Get the dependency info for Pointer in BB. If we have cached; // information, we will use it, otherwise we compute it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:109,Availability,failure,failure,109,"// If we have seen this block before, but it was with a different; // pointer then we have a phi translation failure and we have to treat; // this as a clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:255,Integrability,rout,routines,255,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Performance,cache,cache,35,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:130,Performance,cache,cache,130,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:285,Performance,cache,cache,285,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:331,Performance,cache,cache,331,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Availability,failure,failure,122,"// Check to see if we have already visited this pred block with another; // pointer. If so, we can't do this lookup. This failure can occur; // with PHI translation when a critical edge exists and the PHI node in; // the successor translates to a pointer value different than the; // pointer the block was first analyzed with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:169,Availability,failure,failure,169,"// Otherwise, the block was previously analyzed with a different; // pointer. We can't represent the result of this case, so we just; // treat this as a phi translation failure.; // Make sure to clean up the Visited map before continuing on to; // PredTranslationFailure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:69,Safety,avoid,avoid,69,// Actually process results here; this need to be a separate loop to avoid; // calling getNonLocalPointerDepFromBB for blocks we don't want to return; // any results for. (getNonLocalPointerDepFromBB will modify our; // datastructures in ways the code after the PredTranslationFailure label; // doesn't expect.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:44,Availability,avail,available,44,"// If PHI translation was unable to find an available pointer in this; // predecessor, then we have to assume that the pointer is clobbered in; // that predecessor. We can still do PRE of the load, which would insert; // a computation of the pointer in this predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:192,Performance,load,load,192,"// If PHI translation was unable to find an available pointer in this; // predecessor, then we have to assume that the pointer is clobbered in; // that predecessor. We can still do PRE of the load, which would insert; // a computation of the pointer in this predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:310,Performance,cache,cached,310,"// FIXME: it is entirely possible that PHI translating will end up with; // the same value. Consider PHI translating something like:; // X = phi [x, bb1], [y, bb2]. PHI translating for bb1 doesn't *need*; // to recurse here, pedantically speaking.; // If getNonLocalPointerDepFromBB fails here, that means the cached; // result conflicted with the Visited list; we have to conservatively; // assume it is unknown, but this also does not block PRE of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:454,Performance,load,load,454,"// FIXME: it is entirely possible that PHI translating will end up with; // the same value. Consider PHI translating something like:; // X = phi [x, bb1], [y, bb2]. PHI translating for bb1 doesn't *need*; // to recurse here, pedantically speaking.; // If getNonLocalPointerDepFromBB fails here, that means the cached; // result conflicted with the Visited list; we have to conservatively; // assume it is unknown, but this also does not block PRE of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,Availability,failure,failure,34,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:336,Availability,failure,failure,336,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:47,Performance,cache,cache,47,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Performance,Cache,CacheKey,57,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:280,Performance,cache,cached,280,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,Cache,CacheInfo,15,// Refresh the CacheInfo/Cache pointer so that it isn't invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,Cache,Cache,25,// Refresh the CacheInfo/Cache pointer so that it isn't invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,Cache,Cache,38,"// Since we did phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"" Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:242,Usability,Clear,Clear,242,"// Since we did phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"" Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,Availability,failure,failure,26,"// The following code is ""failure""; we can't produce a sane translation; // for the given block. It assumes that we haven't modified any of; // our datastructures while processing the current block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,Cache,CacheInfo,15,// Refresh the CacheInfo/Cache pointer if it got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,Cache,Cache,25,// Refresh the CacheInfo/Cache pointer if it got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Performance,Cache,Cache,41,"// Since we failed phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:246,Usability,Clear,Clear,246,"// Since we failed phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:61,Deployability,update,update,61,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:24,Performance,load,loads,24,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,cache,cached,38,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:68,Performance,cache,cached,68,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:31,Integrability,depend,dependence,31,// Go ahead and report unknown dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:55,Performance,cache,cache,55,"// Okay, we're done now. If we added new values to the cache, re-sort it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,Cache,CachedNonLocalPointerInfo,19,"/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,cache,cache,25,// Most of the time this cache is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:48,Deployability,update,update,48,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,Cache,Cache,37,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:9,Performance,load,load,9,// Flush load info for the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:30,Integrability,depend,dependencies,30,"// Walk through the Non-local dependencies, removing this one as the value; // for any cached queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:87,Performance,cache,cached,87,"// Walk through the Non-local dependencies, removing this one as the value; // for any cached queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Integrability,depend,dependence,29,"// If we have a cached local dependence query for this instruction, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,cache,cached,16,"// If we have a cached local dependence query for this instruction, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,Integrability,depend,dependency,21,// Remove this local dependency info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Integrability,depend,dependencies,25,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Performance,cache,cached,18,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:137,Performance,load,load,137,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:71,Performance,load,load,71,"// Otherwise, if the instructions is in the map directly, it must be a load.; // Remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:36,Integrability,depend,depend,36,// Loop over all of the things that depend on the instruction we're removing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Integrability,depend,depending,57,// RemInst can't be the terminator if it has local stuff depending on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Integrability,depend,depend,41,// Make sure to remember that new things depend on NewDepInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Safety,avoid,avoid,51,"// Add new reverse deps after scanning the set, to avoid invalidating the; // 'ReverseDeps' reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Safety,avoid,avoid,51,"// Add new reverse deps after scanning the set, to avoid invalidating 'Set'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is not valid for any specific block anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:3,Deployability,Update,Update,3,// Update any entries for RemInst to use the instruction after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:131,Testability,assert,asserting,131,/// Verify that the specified instruction does not occur in our internal data; /// structures.; ///; /// This function verifies by asserting in debug builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:33,Integrability,depend,depend,33,// Check whether the analyses we depend on became invalid for any reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp:159,Safety,abort,aborts,159,"// memset_chk writes at most Len bytes, memcpy_chk reads/writes at most; // Len bytes. They may read/write less, if Len exceeds the specified max; // size and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:27,Security,access,access,27,// Upper bound on lifetime access density (accesses per byte per lifetime sec); // for marking an allocation cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:43,Security,access,accesses,43,// Upper bound on lifetime access density (accesses per byte per lifetime sec); // for marking an allocation cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:119,Safety,avoid,avoid,119,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:70,Security,access,accesses,70,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:35,Security,access,accesses,35,// Lower bound on average lifetime accesses density (total life time access; // density / alloc count) for marking an allocation hot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:69,Security,access,access,69,// Lower bound on average lifetime accesses density (total life time access; // density / alloc count) for marking an allocation hot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:7,Security,access,access,7,"// The access densities are multiplied by 100 to hold 2 decimal places of; // precision, so need to divide by 100.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:7,Security,access,access,7,"// The access densities are multiplied by 100 to hold 2 decimal places of; // precision, so need to divide by 100.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:44,Deployability,update,update,44,"// If this is the first stack frame, add or update alloc node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:3,Deployability,Update,Update,3,// Update existing caller node if it exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:160,Usability,simpl,simpler,160,// Recursive helper to trim contexts and create metadata nodes.; // Caller should have pushed Node's loc to MIBCallStack. Doing this in the; // caller makes it simpler to handle the many early returns in this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:365,Performance,optimiz,optimizer,365,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:128,Testability,assert,assert,128,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:197,Usability,simpl,simplify,197,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:78,Performance,optimiz,optimizers,78,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:185,Performance,load,load,185,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:233,Performance,load,loads,233,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:299,Performance,load,loads,299,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:367,Performance,load,load,367,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:381,Performance,load,loads,381,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:420,Performance,load,loads,420,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:523,Performance,load,loads,523,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:57,Testability,test,test,57,"// The MemoryAccess we actually got called with, used to test local domination",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:40,Performance,load,loads,40,"// If the memory can't be changed, then loads of the memory can't be; // clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:229,Performance,cache,cache,229,"/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing; /// inbetween `Start` and `ClobberAt` can clobbers `Start`.; ///; /// This is meant to be as simple and self-contained as possible. Because it; /// uses no cache, etc., it can be relatively expensive.; ///; /// \param Start The MemoryAccess that we want to walk from.; /// \param ClobberAt A clobber for Start.; /// \param StartLoc The MemoryLocation for Start.; /// \param MSSA The MemorySSA instance that Start and ClobberAt belong to.; /// \param Query The UpwardsMemoryQuery we used for our search.; /// \param AA The AliasAnalysis we used for our search.; /// \param AllowImpreciseClobber Always false, unless we do relaxed verify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:166,Usability,simpl,simple,166,"/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing; /// inbetween `Start` and `ClobberAt` can clobbers `Start`.; ///; /// This is meant to be as simple and self-contained as possible. Because it; /// uses no cache, etc., it can be relatively expensive.; ///; /// \param Start The MemoryAccess that we want to walk from.; /// \param ClobberAt A clobber for Start.; /// \param StartLoc The MemoryLocation for Start.; /// \param MSSA The MemorySSA instance that Start and ClobberAt belong to.; /// \param Query The UpwardsMemoryQuery we used for our search.; /// \param AA The AliasAnalysis we used for our search.; /// \param AllowImpreciseClobber Always false, unless we do relaxed verify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:84,Usability,learn,learn,84,// All we care about is that nothing from Start to ClobberAt clobbers Start.; // We learn nothing from revisiting nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:38,Performance,optimiz,optimization,38,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:260,Performance,optimiz,optimized,260,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:284,Performance,optimiz,optimized,284,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Security,access,access,167,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:232,Security,access,accesses,232,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:69,Integrability,wrap,wrapped,69,"/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up; /// in one class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:45,Performance,optimiz,optimize,45,"/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up; /// in one class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Performance,optimiz,optimization,7,// Phi optimization bookkeeping:; // List of DefPath to process during the current phi optimization walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:87,Performance,optimiz,optimization,87,// Phi optimization bookkeeping:; // List of DefPath to process during the current phi optimization walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:20,Security,Access,Access,20,"// List of visited <Access, Location> pairs; we can skip paths already; // visited with the same memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:59,Performance,optimiz,optimized,59,/// Find the nearest def or phi that `From` can legally be optimized to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:91,Deployability,update,update,91,/// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.; /// This will update Desc.Last as it walks. It will (optionally) also stop at; /// StopAt.; ///; /// This does not test for whether StopAt is a clobber,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:192,Testability,test,test,192,/// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.; /// This will update Desc.Last as it walks. It will (optionally) also stop at; /// StopAt.; ///; /// This does not test for whether StopAt is a clobber,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:200,Performance,cache,cache,200,"/// Represents a search that terminated after finding a clobber. This clobber; /// may or may not be present in the path of defs from LastNode..SearchStart,; /// since it may have been retrieved from cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:37,Performance,optimiz,optimizing,37,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:216,Performance,optimiz,optimization,216,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:11,Security,access,access,11,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:76,Usability,Pause,PausedSearches,76,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:79,Usability,Pause,PausedSearches,79,"// BFS vs DFS really doesn't make a difference here, so just do a DFS with; // PausedSearches as our stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:472,Availability,down,down,472,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:280,Performance,cache,cache,280,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:308,Performance,optimiz,optimization,308,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:525,Performance,cache,cache,525,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:588,Performance,cache,cache,588,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:649,Performance,cache,cache,649,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:75,Availability,failure,failure,75,"// If this wasn't a cache hit, we hit a clobber when walking. That's a; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:20,Performance,cache,cache,20,"// If this wasn't a cache hit, we hit a clobber when walking. That's a; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:48,Performance,optimiz,optimize,48,"// Otherwise, it's a valid thing to potentially optimize to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Performance,cache,cache,34,"/// The paths that we can legally cache back from, but that aren't; /// necessarily the result of the Phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:106,Performance,optimiz,optimization,106,"/// The paths that we can legally cache back from, but that aren't; /// necessarily the result of the Phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Testability,assert,assert,7,// The assert looks nicer if we don't need to do &N,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:11,Performance,optimiz,optimize,11,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Performance,optimiz,optimization,167,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:241,Performance,optimiz,optimize,241,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:344,Performance,optimiz,optimization,344,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:499,Performance,optimiz,optimize,499,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:303,Security,access,access,303,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,optimiz,optimization,27,"// Stores how many ""valid"" optimization nodes we had prior to calling; // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:75,Performance,optimiz,optimization,75,"// If a TerminatedPath doesn't dominate Target, then it wasn't a legal; // optimization for the prior phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:31,Availability,reliab,reliably,31,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:477,Availability,reliab,reliably,477,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:40,Performance,cache,cache,40,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:146,Performance,optimiz,optimize,146,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:204,Performance,cache,cache,204,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:265,Performance,cache,cache,265,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:386,Performance,optimiz,optimization,386,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:412,Performance,cache,cache,412,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:486,Performance,cache,cache,486,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:856,Performance,cache,cache,856,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:899,Performance,cache,cache,899,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1082,Performance,cache,cache,1082,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1120,Performance,cache,cached,1120,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1251,Performance,optimiz,optimization,1251,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:100,Performance,cache,cache,100,"// If there's nothing left to search, then all paths led to valid clobbers; // that we got from our cache; pick the nearest to the start, and allow; // the rest to be cached back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Performance,cache,cached,167,"// If there's nothing left to search, then all paths led to valid clobbers; // that we got from our cache; pick the nearest to the start, and allow; // the rest to be cached back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:74,Performance,optimiz,optimize,74,"// If any of the terminated paths don't dominate the phi we'll try to; // optimize, we need to figure out what they are and quit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:51,Performance,optimiz,optimizing,51,"/// Finds the nearest clobber for the given query, optimizing phis if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:142,Performance,cache,cache,142,"// This walker pretends uses don't exist. If we're handed one, silently grab; // its def. (This has the nice side-effect of ensuring we never cache uses)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:54,Performance,optimiz,optimization,54,// Fast path for the overly-common case (no crazy phi optimization; // necessary),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:237,Deployability,update,updated,237,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:209,Performance,Optimiz,Optimized,209,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:363,Performance,cache,cache,363,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:98,Security,access,access,98,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:175,Security,access,access,175,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:219,Security,access,access,219,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:57,Security,access,accesses,57,"/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no; /// longer does caching on its own, but the name has been retained for the; /// moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:22,Security,access,accessible,22,// This method is not accessible outside of this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:108,Security,access,accesses,108,"/// This is the standard SSA renaming algorithm.; ///; /// We walk the dominator tree in preorder, renaming accesses, and then filling; /// in phi nodes in our successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:35,Security,access,accesses,35,"/// This handles unreachable block accesses by deleting phi nodes in; /// unreachable blocks, and marking all other unreachable MemoryAccess's as; /// being uses of the live on entry definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:242,Energy Efficiency,reduce,reduce,242,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:153,Safety,safe,safe,153,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:298,Availability,down,down,298,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:435,Energy Efficiency,efficient,efficient,435,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:281,Performance,perform,performing,281,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:366,Performance,cache,cache,366,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:99,Security,access,access,99,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:138,Integrability,depend,depends,138,"// This is the lower bound of places on the stack to check. It is equal to; // the place the last stack walk ended.; // Note: Correctness depends on this being initialized to 0, which densemap; // does",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,Optimiz,Optimize,27,"// end namespace llvm; /// Optimize the uses in a given block This is basically the SSA renaming; /// algorithm, with one caveat: We are able to use a single stack for all; /// MemoryUses. This is because the set of *possible* reaching MemoryDefs is; /// the same for every MemoryUse. The *actual* clobbering MemoryDef is just; /// going to be some position in that stack of possible ones.; ///; /// We track the stack positions that each MemoryLocation needs; /// to check, and last ended at. This is because we only want to check the; /// things that changed since last time. The same MemoryLocation should; /// get clobbered by the same store (getModRefInfo does not use invariantness or; /// things like this, and if they start, we can modify MemoryLocOrCall to; /// include relevant data)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:10,Security,access,accesses,10,"/// If no accesses, nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:502,Performance,optimiz,optimization,502,"// If the lower bound was in something that no longer dominates us, we; // have to reset it.; // We can't simply track stack size, because the stack may have had; // pushes/pops in the meantime.; // XXX: This is non-optimal, but only is slower cases with heavily; // branching dominator trees. To get the optimal number of queries would; // be to make lowerbound and lastkill a per-loc stack, and pop it until; // the top of that stack dominates us. This does not seem worth it ATM.; // A much cheaper optimization would be to always explore the deepest; // branch of the dominator tree first. This will guarantee this resets on; // the smallest set of blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:106,Usability,simpl,simply,106,"// If the lower bound was in something that no longer dominates us, we; // have to reset it.; // We can't simply track stack size, because the stack may have had; // pushes/pops in the meantime.; // XXX: This is non-optimal, but only is slower cases with heavily; // branching dominator trees. To get the optimal number of queries would; // be to make lowerbound and lastkill a per-loc stack, and pop it until; // the top of that stack dominates us. This does not seem worth it ATM.; // A much cheaper optimization would be to always explore the deepest; // branch of the dominator tree first. This will guarantee this resets on; // the smallest set of blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:142,Deployability,update,updates,142,"// For phis, use the walker, see where we ended up, go there.; // The invariant.group handling in MemorySSA is ad-hoc and doesn't; // support updates, so don't use it to optimize uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:170,Performance,optimiz,optimize,170,"// For phis, use the walker, see where we ended up, go there.; // The invariant.group handling in MemorySSA is ad-hoc and doesn't; // support updates, so don't use it to optimize uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize uses to point to their actual clobbering definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Availability,down,down,34,// We perform a non-recursive top-down dominator tree walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:6,Performance,perform,perform,6,// We perform a non-recursive top-down dominator tree walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:16,Security,access,access,16,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:369,Usability,simpl,simply,369,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:31,Security,access,accesses,31,"// We maintain lists of memory accesses per-block, trading memory for time. We; // could just look up the memory access for every possible instruction in the; // stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:113,Security,access,access,113,"// We maintain lists of memory accesses per-block, trading memory for time. We; // could just look up the memory access for every possible instruction in the; // stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:86,Security,access,accesses,86,"// Go through each block, figure out where defs occur, and chain together all; // the accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:50,Integrability,rout,routines,50,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:93,Security,access,access,93,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:53,Performance,optimiz,optimized,53,"// Note that moving should implicitly invalidate the optimized state of a; // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:107,Performance,optimiz,optimized,107,"// Note that moving should implicitly invalidate the optimized state of a; // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:274,Deployability,update,updated,274,"// Move What before Where in the IR. The end result is that What will belong to; // the right lists and have the right Block set, but will not otherwise be; // correct. It will not have the right defining access, and if it is a def,; // things below it will not properly be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:205,Security,access,access,205,"// Move What before Where in the IR. The end result is that What will belong to; // the right lists and have the right Block set, but will not otherwise be; // correct. It will not have the right defining access, and if it is a def,; // things below it will not properly be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:3,Deployability,Update,Update,3,// Update lookup table entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:118,Performance,load,loads,118,// Return true if the instruction has ordering constraints.; // Note specifically that this only considers stores and loads; // because others are still considered ModRef by getModRefInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:41,Security,access,accesses,41,/// Helper function to create new memory accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:190,Deployability,pipeline,pipeline,190,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:38,Integrability,depend,dependency,38,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:229,Integrability,depend,dependencies,229,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:342,Integrability,depend,dependency,342,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:26,Deployability,pipeline,pipelines,26,"// Using a nonstandard AA pipelines might leave us with unexpected modref; // results for I, so add a check to not model instructions that may not read; // from or write to memory. This is necessary for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Energy Efficiency,reduce,reduced,34,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:10,Security,access,accesses,10,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:35,Energy Efficiency,power,power,35,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Security,Access,Access,7,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:55,Security,access,access,55,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:356,Performance,load,loads,356,"// The isOrdered check is used to ensure that volatiles end up as defs; // (atomics end up as ModRef right now anyway). Until we separate the; // ordering chain from the memory chain, this enables people to see at least; // some relative ordering to volatiles. Note that getClobberingMemoryAccess; // will still give an answer that bypasses other volatile loads. TODO:; // Separate memory aliasing and ordering into two different chains so that; // we can precisely represent both ""what memory will this read/write/is; // clobbered by"" and ""what instructions can I move this past"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,cache,cache,27,// Invalidate our walker's cache if necessary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:242,Security,access,access,242,"/// Properly remove \p MA from all of MemorySSA's lists.; ///; /// Because of the way the intrusive list and use lists work, it is important to; /// do removal in the right order.; /// ShouldDelete defaults to true, and will cause the memory access to also be; /// deleted, not just removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Security,access,access,7,"// The access list owns the reference, so we erase it from the non-owning list; // first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Performance,cache,cached,82,"// Previously, the verification used to also verify that the clobberingAccess; // cached by MemorySSA is the same as the clobberingAccess found at a later; // query to AA. This does not hold true in general due to the current fragility; // of BasicAA which has arbitrary caps on the things it analyzes before giving; // up. As a result, transformations that are correct, will lead to BasicAA; // returning different Alias answers before and after that transformation.; // Invalidating MemorySSA is not an option, as the results in BasicAA can be so; // random, in the worst case we'd need to rebuild MemorySSA from scratch after; // every transformation, which defeats the purpose of using it. For such an; // example, see test4 added in D51960.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:187,Security,access,access,187,"// If Pred has no unreachable predecessors, get last def looking at; // IDoms. If, while walkings IDoms, any of these has an unreachable; // predecessor, then the incoming def can be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:171,Deployability,update,update,171,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:377,Deployability,update,update,377,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:144,Performance,optimiz,optimized,144,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Security,access,access,82,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:233,Security,access,access,233,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:262,Security,access,access,262,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:333,Security,access,access,333,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:399,Security,access,access,399,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:280,Security,access,accesses,280,"/// Verify ordering: the order and existence of MemoryAccesses matches the; /// order and existence of memory affecting instructions.; /// Verify domination: each definition dominates all of its uses.; /// Verify def-uses: the immediate use information - walk all the memory; /// accesses and verifying that, for each use, it appears in the appropriate; /// def's use list",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:70,Security,access,access,70,"// Walk all the blocks, comparing what the lookups think and what the access; // lists think, as well as the order in the blocks vs the order in the access; // lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:149,Security,access,access,149,"// Walk all the blocks, comparing what the lookups think and what the access; // lists think, as well as the order in the blocks vs the order in the access; // lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:44,Security,access,accesses,44,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:74,Security,access,accesses,74,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:90,Security,access,access,90,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:21,Testability,assert,assert,21,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Performance,Perform,Perform,4,"/// Perform a local numbering on blocks so that instruction ordering can be; /// determined in constant time.; /// TODO: We currently just number in order. If we numbered by N, we could; /// allow at least N-1 sequences of insertBefore or insertAfter (and at least; /// log2(N) sequences of mixed before and after) without needing to invalidate; /// the numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:30,Security,access,accesses,30,"/// Determine, for two memory accesses in the same block,; /// whether \p Dominator dominates \p Dominatee.; /// \returns True if \p Dominator dominates \p Dominatee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:90,Security,access,access,90,"// When Dominatee is defined on function entry, it is not dominated by another; // memory access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Security,access,access,82,"// When Dominator is defined on function entry, it dominates the other memory; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:53,Deployability,release,release,53,// Cannot completely remove virtual function even in release mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:158,Security,access,access,158,/// Walk the use-def chains starting at \p StartingAccess and find; /// the MemoryAccess that actually clobbers Loc.; ///; /// \returns our clobbering memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:60,Security,access,access,60,"// If location is undefined, conservatively return starting access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:56,Performance,perform,perform,56,"// Conservatively, fences are always clobbers, so don't perform the walk if; // we hit a fence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:136,Security,access,access,136,"// Unlike the other function, do not walk to the def of a def, because we are; // handed something we already believe is the clobbering access.; // We never set SkipSelf to true in Q in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:148,Performance,load,loads,148,"// We consider bitcasts and zero GEPs to be the same pointer value. Start by; // stripping bitcasts and zero GEPs, then we will recursively look at loads; // and stores through bitcasts and zero GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:12,Safety,safe,safe,12,// It's not safe to walk the use list of a global value because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside of; // current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:3,Performance,Queue,Queue,3,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:56,Performance,load,load,56,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:214,Deployability,update,updates,214,"// FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case; // we will see all the instructions. It may not matter in practice. If it; // does, we will have to support MemorySSA construction and updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:33,Performance,queue,queue,33,// Add bitcasts and zero GEPs to queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:15,Performance,load,load,15,"// If we hit a load/store with an invariant.group metadata and the same; // pointer operand, we can assume that value pointed to by the pointer; // operand didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:25,Performance,optimiz,optimized,25,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:58,Performance,optimiz,optimized,58,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:110,Performance,optimiz,optimized,110,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:188,Security,access,access,188,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Deployability,Update,Updater,42,"//===-- MemorySSAUpdater.cpp - Memory SSA Updater--------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------===//; //; // This file implements the MemorySSAUpdater class.; //; //===----------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:49,Energy Efficiency,Efficient,Efficient,49,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:38,Usability,Simpl,Simple,38,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:118,Usability,simpl,simple,118,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:15,Performance,cache,cache,15,"// First, do a cache lookup. Without this cache, certain CFG structures; // (like a series of if statements) take exponential time to visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Performance,cache,cache,42,"// First, do a cache lookup. Without this cache, certain CFG structures; // (like a series of if statements) take exponential time to visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
