id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9387,Availability,avail,available,9387,"lectronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a disper",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9648,Availability,avail,available,9648," computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9920,Availability,avail,available,9920,"age of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dis",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:5846,Deployability,configurat,configuration,5846," component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6080,Deployability,configurat,configuration,6080, electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6320,Deployability,configurat,configuration,6320,ts of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and cor,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6682,Deployability,configurat,configuration,6682,tion energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6851,Deployability,configurat,configuration,6851,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7129,Deployability,configurat,configuration,7129,vel of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrup,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7327,Deployability,configurat,configuration,7327,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7725,Deployability,configurat,configuration,7725,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7877,Deployability,configurat,configuration,7877,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8133,Deployability,configurat,configuration,8133," configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corre",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8479,Deployability,configurat,configuration,8479,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11370,Deployability,configurat,configuration,11370,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14870,Deployability,update,updated,14870,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1063,Energy Efficiency,energy,energy,1063,"   . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; Th",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1090,Energy Efficiency,energy,energy,1090,"   . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; Th",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1625,Energy Efficiency,energy,energy,1625," Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1652,Energy Efficiency,energy,energy,1652," Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1911,Energy Efficiency,energy,energy,1911,"ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCS",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:1962,Energy Efficiency,energy,energy,1962,"ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCS",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:2111,Energy Efficiency,energy,energy,2111,"ir functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATIO",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:2456,Energy Efficiency,energy,energy,2456,"r the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] an",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:2483,Energy Efficiency,energy,energy,2483,"r the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] an",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3171,Energy Efficiency,energy,energy,3171,"). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3198,Energy Efficiency,energy,energy,3198,"). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3487,Energy Efficiency,energy,energy,3487,"oupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coup",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3514,Energy Efficiency,energy,energy,3514,"oupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coup",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3821,Energy Efficiency,energy,energy,3821,"nts of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximat",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:3848,Energy Efficiency,energy,energy,3848,"nts of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximat",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4145,Energy Efficiency,energy,energy,4145,"lation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4172,Energy Efficiency,energy,energy,4172,"lation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4463,Energy Efficiency,energy,energy,4463,"ation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶.",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4490,Energy Efficiency,energy,energy,4490,"ation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶.",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4800,Energy Efficiency,energy,energy,4800,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4827,Energy Efficiency,energy,energy,4827,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:5611,Energy Efficiency,energy,energy,5611,"ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; r",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:5638,Energy Efficiency,energy,energy,5638,"ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; r",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7260,Energy Efficiency,energy,energy,7260,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7287,Energy Efficiency,energy,energy,7287,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7499,Energy Efficiency,energy,energy,7499, -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of th,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7526,Energy Efficiency,energy,energy,7526, -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of th,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7658,Energy Efficiency,energy,energy,7658,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7685,Energy Efficiency,energy,energy,7685,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8414,Energy Efficiency,energy,energy,8414,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8441,Energy Efficiency,energy,energy,8441,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8614,Energy Efficiency,energy,energy,8614,"ERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. I",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8810,Energy Efficiency,energy,energy,8810,"IPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8905,Energy Efficiency,energy,energy,8905,"vel of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is avail",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9090,Energy Efficiency,energy,energy,9090,"rupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10047,Energy Efficiency,energy,energy,10047," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10074,Energy Efficiency,energy,energy,10074," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10191,Energy Efficiency,energy,energy,10191,"deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity i",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10507,Energy Efficiency,energy,energy,10507,"ol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any disper",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10809,Energy Efficiency,energy,energy,10809," the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:10850,Energy Efficiency,energy,energy,10850," the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11126,Energy Efficiency,energy,energy,11126,"T FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11308,Energy Efficiency,energy,energy,11308,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11335,Energy Efficiency,energy,energy,11335,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11452,Energy Efficiency,energy,energy,11452,"al electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contri",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11653,Energy Efficiency,energy,energy,11653,"Y. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quant",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11749,Energy Efficiency,energy,energy,11749,"o; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respe",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11861,Energy Efficiency,energy,energy,11861,"ty in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11888,Energy Efficiency,energy,energy,11888,"ty in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12008,Energy Efficiency,energy,energy,12008,"od is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12035,Energy Efficiency,energy,energy,12035,"od is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12153,Energy Efficiency,energy,energy,12153,"rlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 E",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12180,Energy Efficiency,energy,energy,12180,"rlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 E",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12296,Energy Efficiency,energy,energy,12296,"rrelation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components o",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12323,Energy Efficiency,energy,energy,12323,"rrelation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components o",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12481,Energy Efficiency,energy,energy,12481,"ock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12522,Energy Efficiency,energy,energy,12522,"ock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12596,Energy Efficiency,energy,energy,12596,"3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12637,Energy Efficiency,energy,energy,12637,"3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:12860,Energy Efficiency,energy,energy,12860,"CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); U",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13017,Energy Efficiency,energy,energy,13017," and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quanti",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13209,Energy Efficiency,energy,energy,13209," the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13566,Energy Efficiency,energy,energy,13566," ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14092,Energy Efficiency,energy,energy,14092,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14133,Energy Efficiency,energy,energy,14133,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14222,Energy Efficiency,energy,energy,14222,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14443,Energy Efficiency,energy,energy,14443,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14470,Energy Efficiency,energy,energy,14470,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:208,Modifiability,variab,variable,208,"﻿. PSI Variables by Alpha — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:250,Modifiability,variab,variable,250,"﻿. PSI Variables by Alpha — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:5846,Modifiability,config,configuration,5846," component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6080,Modifiability,config,configuration,6080, electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6320,Modifiability,config,configuration,6320,ts of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and cor,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6682,Modifiability,config,configuration,6682,tion energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:6851,Modifiability,config,configuration,6851,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7129,Modifiability,config,configuration,7129,vel of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrup,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7327,Modifiability,config,configuration,7327,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7725,Modifiability,config,configuration,7725,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:7877,Modifiability,config,configuration,7877,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8133,Modifiability,config,configuration,8133," configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corre",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8479,Modifiability,config,configuration,8479,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8714,Modifiability,variab,variable,8714,"tion interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:8857,Modifiability,variab,variable,8857,"IPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9161,Modifiability,variab,variable,9161,"rupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:11370,Modifiability,config,configuration,11370,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13638,Modifiability,variab,variables,13638,"SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:13731,Modifiability,variab,variables,13731,"SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:14325,Modifiability,variab,variable,14325,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9031,Performance,optimiz,optimizer,9031,"CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELAT",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9387,Availability,avail,available,9387,"lectronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a disper",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9648,Availability,avail,available,9648," computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9920,Availability,avail,available,9920,"age of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dis",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:5846,Deployability,configurat,configuration,5846," component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6080,Deployability,configurat,configuration,6080, electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6320,Deployability,configurat,configuration,6320,ts of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and cor,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6682,Deployability,configurat,configuration,6682,tion energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6851,Deployability,configurat,configuration,6851,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7129,Deployability,configurat,configuration,7129,vel of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrup,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7327,Deployability,configurat,configuration,7327,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7725,Deployability,configurat,configuration,7725,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7877,Deployability,configurat,configuration,7877,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8133,Deployability,configurat,configuration,8133," configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corre",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8479,Deployability,configurat,configuration,8479,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11370,Deployability,configurat,configuration,11370,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14870,Deployability,update,updated,14870,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1063,Energy Efficiency,energy,energy,1063,"   . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; Th",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1090,Energy Efficiency,energy,energy,1090,"   . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; Th",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1625,Energy Efficiency,energy,energy,1625," Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1652,Energy Efficiency,energy,energy,1652," Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1911,Energy Efficiency,energy,energy,1911,"ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCS",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:1962,Energy Efficiency,energy,energy,1962,"ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCS",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:2111,Energy Efficiency,energy,energy,2111,"ir functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATIO",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:2456,Energy Efficiency,energy,energy,2456,"r the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] an",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:2483,Energy Efficiency,energy,energy,2483,"r the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] an",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3171,Energy Efficiency,energy,energy,3171,"). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3198,Energy Efficiency,energy,energy,3198,"). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3487,Energy Efficiency,energy,energy,3487,"oupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coup",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3514,Energy Efficiency,energy,energy,3514,"oupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coup",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3821,Energy Efficiency,energy,energy,3821,"nts of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximat",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:3848,Energy Efficiency,energy,energy,3848,"nts of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximat",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4145,Energy Efficiency,energy,energy,4145,"lation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4172,Energy Efficiency,energy,energy,4172,"lation energy component [H]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4463,Energy Efficiency,energy,energy,4463,"ation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶.",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4490,Energy Efficiency,energy,energy,4490,"ation energy component [H]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶.",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4800,Energy Efficiency,energy,energy,4800,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:4827,Energy Efficiency,energy,energy,4827,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:5611,Energy Efficiency,energy,energy,5611,"ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; r",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:5638,Energy Efficiency,energy,energy,5638,"ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; r",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7260,Energy Efficiency,energy,energy,7260,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7287,Energy Efficiency,energy,energy,7287,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7499,Energy Efficiency,energy,energy,7499, -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of th,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7526,Energy Efficiency,energy,energy,7526, -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of th,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7658,Energy Efficiency,energy,energy,7658,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7685,Energy Efficiency,energy,energy,7685,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8414,Energy Efficiency,energy,energy,8414,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8441,Energy Efficiency,energy,energy,8441,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8614,Energy Efficiency,energy,energy,8614,"ERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. I",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8810,Energy Efficiency,energy,energy,8810,"IPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8905,Energy Efficiency,energy,energy,8905,"vel of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is avail",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9090,Energy Efficiency,energy,energy,9090,"rupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10047,Energy Efficiency,energy,energy,10047," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10074,Energy Efficiency,energy,energy,10074," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10191,Energy Efficiency,energy,energy,10191,"deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity i",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10507,Energy Efficiency,energy,energy,10507,"ol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any disper",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10809,Energy Efficiency,energy,energy,10809," the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:10850,Energy Efficiency,energy,energy,10850," the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORR",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11126,Energy Efficiency,energy,energy,11126,"T FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (3) or (1). Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11308,Energy Efficiency,energy,energy,11308,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11335,Energy Efficiency,energy,energy,11335,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11452,Energy Efficiency,energy,energy,11452,"al electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contri",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11653,Energy Efficiency,energy,energy,11653,"Y. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quant",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11749,Energy Efficiency,energy,energy,11749,"o; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respe",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11861,Energy Efficiency,energy,energy,11861,"ty in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11888,Energy Efficiency,energy,energy,11888,"ty in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12008,Energy Efficiency,energy,energy,12008,"od is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12035,Energy Efficiency,energy,energy,12035,"od is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12153,Energy Efficiency,energy,energy,12153,"rlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 E",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12180,Energy Efficiency,energy,energy,12180,"rlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 E",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12296,Energy Efficiency,energy,energy,12296,"rrelation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components o",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12323,Energy Efficiency,energy,energy,12323,"rrelation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components o",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12481,Energy Efficiency,energy,energy,12481,"ock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12522,Energy Efficiency,energy,energy,12522,"ock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12596,Energy Efficiency,energy,energy,12596,"3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12637,Energy Efficiency,energy,energy,12637,"3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:12860,Energy Efficiency,energy,energy,12860,"CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); U",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:13017,Energy Efficiency,energy,energy,13017," and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quanti",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:13209,Energy Efficiency,energy,energy,13209," the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:13566,Energy Efficiency,energy,energy,13566," ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14092,Energy Efficiency,energy,energy,14092,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14133,Energy Efficiency,energy,energy,14133,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14222,Energy Efficiency,energy,energy,14222,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14443,Energy Efficiency,energy,energy,14443,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14470,Energy Efficiency,energy,energy,14470,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:208,Modifiability,variab,variable,208,"﻿. PSI Variables by Alpha — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:250,Modifiability,variab,variable,250,"﻿. PSI Variables by Alpha — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. ACPF DIPOLE X¶. ACPF DIPOLE Y¶. ACPF DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged coupled-pair functional level of theory. ACPF QUADRUPOLE XX¶. ACPF QUADRUPOLE XY¶. ACPF QUADRUPOLE XZ¶. ACPF QUADRUPOLE YY¶. ACPF QUADRUPOLE YZ¶. ACPF QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged coupled-pair functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:5846,Modifiability,config,configuration,5846," component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6080,Modifiability,config,configuration,6080, electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6320,Modifiability,config,configuration,6320,ts of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and cor,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6682,Modifiability,config,configuration,6682,tion energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:6851,Modifiability,config,configuration,6851,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7129,Modifiability,config,configuration,7129,vel of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrup,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7327,Modifiability,config,configuration,7327,the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ ,MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7725,Modifiability,config,configuration,7725,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:7877,Modifiability,config,configuration,7877,"evel of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENE",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8133,Modifiability,config,configuration,8133," configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corre",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8479,Modifiability,config,configuration,8479,"RAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8714,Modifiability,variab,variable,8714,"tion interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQU",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:8857,Modifiability,variab,variable,8857,"IPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9161,Modifiability,variab,variable,9161,"rupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:11370,Modifiability,config,configuration,11370,". Quantity; in Eqs. (3) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (3) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (3) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; ) terms in Eq. (3). Quantity ; in Eq. (3). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy compone",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:13638,Modifiability,variab,variables,13638,"SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:13731,Modifiability,variab,variables,13731,"SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search t",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:14325,Modifiability,variab,variable,14325,"these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF DIPOLE X¶. SCF DIPOLE Y¶. SCF DIPOLE Z¶; The three components of the SCF dipole [Debye]. SCF QUADRUPOLE XX¶. SCF QUADRUPOLE XY¶. SCF QUADRUPOLE XZ¶. SCF QUADRUPOLE YY¶. SCF QUADRUPOLE YZ¶. SCF QUADRUPOLE ZZ¶; The six components of the SCF quadrupole [Debye Ang]. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY; variables less this quantity. Constructed from Eq. (3),; where this quantity is . (3); Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (3). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; WFN; Next topic; PSI Variables by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html:9031,Performance,optimiz,optimizer,9031,"CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELAT",MatchSource.WIKI,psi4manual/4.0b3/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b3/index.html:2919,Deployability,update,updated,2919,"ods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; ADC: Ab Initio Polarization Propagator; SAPT: Symmetry-Adapted Perturbation Theory; CEPA: Coupled-Pair Methods; CC: Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; CI: Configuration Interaction; Geometry Optimization; Evaluation of One-Electron Properties. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation; PsiPEP: Plans and Practices to Organize PSI4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that. Python Driver; basislist; input; pubchem; psiexceptions; frac; molutil; proc; dashparam; procutil; driver; optproc; physconst; wrappers; qmmm; basislistother; diatomic; functional; text; util; basislistdunning; aliases; qcdb. PsiMod: Linking C++ and Python; Appendices; Bibliography; Test Suite and Sample Inputs; Basis Sets by Element; Auxiliary Basis Sets; DFT Functionals; PSIOH Intermediate Files; Keywords by Alpha; Keywords by Module; PSI Variables by Alpha; PSI Variables by Module. Indices. Index; Module Index; Search Page. Next topic; Introduction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/index.html
https://psicode.org/psi4manual/4.0b3/index.html:2280,Integrability,wrap,wrappers,2280,"ods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; ADC: Ab Initio Polarization Propagator; SAPT: Symmetry-Adapted Perturbation Theory; CEPA: Coupled-Pair Methods; CC: Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; CI: Configuration Interaction; Geometry Optimization; Evaluation of One-Electron Properties. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation; PsiPEP: Plans and Practices to Organize PSI4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that. Python Driver; basislist; input; pubchem; psiexceptions; frac; molutil; proc; dashparam; procutil; driver; optproc; physconst; wrappers; qmmm; basislistother; diatomic; functional; text; util; basislistdunning; aliases; qcdb. PsiMod: Linking C++ and Python; Appendices; Bibliography; Test Suite and Sample Inputs; Basis Sets by Element; Auxiliary Basis Sets; DFT Functionals; PSIOH Intermediate Files; Keywords by Alpha; Keywords by Module; PSI Variables by Alpha; PSI Variables by Module. Indices. Index; Module Index; Search Page. Next topic; Introduction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/index.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2128,Availability,avail,available,2128,"tible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6837,Availability,down,down,6837,"cript will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8090,Availability,error,error,8090,"chitectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8103,Availability,error,error,8103,"chitectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8645,Availability,down,download,8645,"en at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usua",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8857,Availability,down,download,8857,"-with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9407,Availability,error,error,9407,"on).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9470,Availability,error,error,9470,"de does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system rou",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17393,Availability,failure,failure,17393,"; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefi",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:18026,Availability,avail,available,18026," ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20477,Availability,avail,available,20477,"g the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is e",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21238,Availability,avail,available,21238,"ries. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21574,Availability,avail,available,21574,"roblems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; betwe",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21872,Availability,fault,faulty,21872,"ibutions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1271,Deployability,install,installed,1271,"III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous architecture-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a d",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2098,Deployability,install,install,2098," or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-le",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2409,Deployability,install,installed,2409,"ur interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compi",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2624,Deployability,install,installing,2624,"detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following comman",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3766,Deployability,install,installed,3766,"given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuratio",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3971,Deployability,configurat,configuration,3971,"To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommen",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4017,Deployability,configurat,configuration,4017,"To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommen",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4138,Deployability,configurat,configuration,4138," >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4181,Deployability,configurat,configuration,4181,"ended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; so",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4404,Deployability,configurat,configuration,4404,"he distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4547,Deployability,install,install,4547,"tion, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, i",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4595,Deployability,install,install,4595,"s directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4644,Deployability,configurat,configuration,4644,"onf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compila",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4900,Deployability,install,installing,4900,"Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your syste",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6079,Deployability,install,installation,6079,"i; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most commo",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6645,Deployability,configurat,configuration,6645,"architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever direc",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7203,Deployability,configurat,configuration,7203,"lt --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --pr",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7368,Deployability,configurat,configuration,7368,"f these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7594,Deployability,install,installation,7594," to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8454,Deployability,install,install,8454,"place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran s",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9646,Deployability,configurat,configuration,9646,"e latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortra",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9881,Deployability,install,install,9881,"; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, which is necessary for C programs to link; Fortran-interface libraries such as BLAS and LAPACK. This option should; o",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14080,Deployability,install,installed,14080,"er — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14981,Deployability,install,installation,14981," compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —;",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:15026,Deployability,install,installation,15026,"alled and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_file",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:15192,Deployability,install,installation,15192,"ter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_filesystem-gcc-mt. --with-boost-python — Specify the boost python library or suffix to use. --with-boost-regex[=special-lib] —; Use",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17668,Deployability,install,installation,17668,"; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17727,Deployability,install,install,17727,"; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17770,Deployability,install,installed,17770,"ssible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to the",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:18161,Deployability,update,updated,18161,"ses after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:18604,Deployability,install,installed,18604,"uite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/use",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:18646,Deployability,install,installation,18646,"uite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/use",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:18713,Deployability,install,installed,18713,"es are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; exp",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20056,Deployability,install,installation,20056,"al /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose t",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21187,Deployability,install,installed,21187,"fy a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:22811,Deployability,install,installed,22811,"ccess, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack3",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24105,Deployability,install,installation,24105," libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK fro",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24157,Deployability,install,installed,24157,"e, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapac",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24657,Deployability,install,installation,24657,".1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24800,Deployability,install,install,24800,"L 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24814,Deployability,install,install,24814,"L 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24985,Deployability,install,installation,24985,"on notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Probl",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:25037,Deployability,install,installed,25037,"ou are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, neede",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26081,Deployability,update,updates,26081,"PACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use;",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26178,Deployability,update,update,26178,"y, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very lates",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26493,Deployability,update,updated,26493,"; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installa",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26709,Deployability,update,update,26709,"ke /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture-Specific Notes; VI. Common Problems with PSI Compilation. This Page. Show Source. Quick search. Enter search terms or a modu",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26803,Deployability,install,installed,26803,"le liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture-Specific Notes; VI. Common Problems with PSI Compilation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] »",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:27157,Deployability,upgrade,upgrade,27157,"s: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture-Specific Notes; VI. Common Problems with PSI Compilation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:27835,Deployability,update,updated,27835,"s: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture-Specific Notes; VI. Common Problems with PSI Compilation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21426,Energy Efficiency,efficient,efficient,21426,"nding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; diffe",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:650,Integrability,rout,routines,650,"﻿. Installation Instructions for PSI4 — PSI4 [beta3] documentation. Navigation. index. modules    . toc    ; PSI4 [beta3] » . Installation Instructions for PSI4¶. I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous architecture-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; archite",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:10480,Integrability,rout,routines,10480,"rror like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, which is necessary for C programs to link; Fortran-interface libraries such as BLAS and LAPACK. This option should; only be used by experts and even then should almost never be necessary.; Allowed values are:. lc : lower-case; lcu : lower-case with underscore (default); uc : upper-case; ucu : upper-case with underscore. --with-ld=linker — Use this option to specify a linker. The; default is ‘ld’. --with-ar=archiver — Use this option to specify an archiver. The; default is to look for ‘ar’ automatically. --with-ar-flags=flags — Use this option to specify additional archiver; flags. The default is ‘r’. --with-incdirs=direct",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:10831,Integrability,interface,interface,10831," of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol convention, which is necessary for C programs to link; Fortran-interface libraries such as BLAS and LAPACK. This option should; only be used by experts and even then should almost never be necessary.; Allowed values are:. lc : lower-case; lcu : lower-case with underscore (default); uc : upper-case; ucu : upper-case with underscore. --with-ld=linker — Use this option to specify a linker. The; default is ‘ld’. --with-ar=archiver — Use this option to specify an archiver. The; default is to look for ‘ar’ automatically. --with-ar-flags=flags — Use this option to specify additional archiver; flags. The default is ‘r’. --with-incdirs=directories — Use this option to specify extra; directories where to look for header files. Directories should be specified; prepended by -I, i.e. -Idir1 -Idir2, etc. If several directories are; specified, enclose the list with single right-quotes, e.g.,; --with-incdirs='-I/usr/local/include -I/home/psi4/include'. --with-libs=libraries — Use this option to specify extra; l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20419,Integrability,depend,depends,20419,"g the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is e",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20954,Integrability,rout,route,20954,"i4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib packag",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:22518,Integrability,depend,depends,22518,".net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26211,Integrability,depend,dependency,26211,"y, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very lates",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1301,Modifiability,config,config,1301,"III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous architecture-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a d",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1374,Modifiability,config,config,1374,"e-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1396,Modifiability,config,config,1396,"e-specific notes; VI. Common Problems with PSI Compilation. I. Compilation Prerequisites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1452,Modifiability,config,config,1452,"isites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g+",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1481,Modifiability,config,config,1481,". F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-de",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1512,Modifiability,config,config,1512," Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installatio",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1586,Modifiability,config,configure,1586," Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installatio",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2595,Modifiability,config,configuring,2595,"detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following comman",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2830,Modifiability,config,configure,2830,"ote: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:2953,Modifiability,config,configure,2953," higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3034,Modifiability,config,configure,3034,". fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3613,Modifiability,config,configure,3613,"given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuratio",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3944,Modifiability,config,configure,3944,"ause the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configur",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:3971,Modifiability,config,configuration,3971,"To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommen",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4017,Modifiability,config,configuration,4017,"To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommen",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4110,Modifiability,config,configure,4110," >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4138,Modifiability,config,configuration,4138," >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4181,Modifiability,config,configuration,4181,"ended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; so",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4286,Modifiability,config,configure,4286," by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from conf",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4307,Modifiability,config,configure,4307," by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from conf",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4362,Modifiability,config,configure,4362,"of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilati",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4376,Modifiability,config,configure,4376,"he distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4404,Modifiability,config,configuration,4404,"he distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4450,Modifiability,config,configure,4450,"he distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4483,Modifiability,config,configure,4483,"mpile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4644,Modifiability,config,configuration,4644,"onf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compila",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:5262,Modifiability,config,configure,5262,"In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:5285,Modifiability,config,configure,5285,"In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:5756,Modifiability,config,configure,5756,"Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the t",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6252,Modifiability,config,configure,6252," is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if y",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6431,Modifiability,config,configure,6431,"ctory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6577,Modifiability,config,configure,6577,"architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever direc",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6645,Modifiability,config,configuration,6645,"architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever direc",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6721,Modifiability,config,configure,6721,"cript will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6758,Modifiability,config,configure,6758,"cript will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6960,Modifiability,config,configure,6960,"cript will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:6981,Modifiability,config,configure,6981," most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7030,Modifiability,config,configure,7030," most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7058,Modifiability,config,configure,7058," directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an e",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7203,Modifiability,config,configuration,7203,"lt --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --pr",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7368,Modifiability,config,configuration,7368,"f these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7474,Modifiability,config,configure,7474,"ake it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:7802,Modifiability,config,configure,7802," so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the correspondi",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8198,Modifiability,config,configure,8198,"n options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If yo",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8257,Modifiability,config,configure,8257,". For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compil",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8616,Modifiability,config,configuring,8616," use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8940,Modifiability,config,configure,8940,"problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9113,Modifiability,config,configure,9113,"ivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order fo",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9156,Modifiability,config,configure,9156,"on 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9173,Modifiability,plugin,plugins,9173,"on 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9192,Modifiability,config,configure,9192,"../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distri",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9317,Modifiability,config,configure,9317,"PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9334,Modifiability,plugin,plugins,9334,"PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9459,Modifiability,config,configure,9459,"de does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system rou",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9552,Modifiability,config,configure,9552,"ot needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9646,Modifiability,config,configuration,9646,"e latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortra",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:9810,Modifiability,config,configure,9810,"ead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c. --with-f77symbol=value — This option allows manual assignment of the; FORTRAN77 symbol conven",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14158,Modifiability,variab,variable,14158,"er — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14361,Modifiability,variab,variable,14361,"; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Requir",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14418,Modifiability,variab,variable,14418,"set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serializ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14446,Modifiability,config,config,14446,"set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serializ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14581,Modifiability,config,config,14581,"aussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (defaul",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14622,Modifiability,variab,variable,14622,"ated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14647,Modifiability,config,configure,14647,"ated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14667,Modifiability,config,configure,14667,"ated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14691,Modifiability,config,configure,14691," yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:15137,Modifiability,config,configure,15137,"alled and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_file",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:19477,Modifiability,variab,variable,19477,"be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficie",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20223,Modifiability,variab,variable,20223,"; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Per",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:22386,Modifiability,config,configure,22386,".net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -l",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:22730,Modifiability,config,configure,22730,"ccess, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack3",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:23221,Modifiability,config,configure,23221,"he same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the following are installed in standard locations (e.g. /usr/local/lib):. ATLAS: libf77blas.a and libatlas.a, plus netlib’s liblapack.a; MKL 8: libmkl.so and libmkl_lapack64.a (with the corresponding; Intel compilers); Goto: libgoto.a and netlib’s liblapack.a; Cray SCSL (e.g. on SGI Altix): libscs.so (NB: No Fortran compiler; is necessary in this case, so --with-fc=no should work.); ESSL (e.g. on AIX systems): libessl.a. If configure cannot identify your BLAS and LAPACK libraries; automatically, you can specify them on the command-line using the; --with-blas and --with-lapack arguments described above. Here are a few; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CP",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24519,Modifiability,config,configure,24519,"s -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24597,Modifiability,config,configure,24597,"framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26576,Modifiability,config,config,26576,"necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26607,Modifiability,config,config,26607,".; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture-Specific Notes; VI. Common Pro",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:8184,Performance,optimiz,optimized,8184,"re any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to th",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:13850,Performance,optimiz,optimizations,13850,"g.,; --with-lapack='-llapack -lcblas -latlas'. --with-max-am-eri=integer — Specifies the maximum angular momentum; level for the primitive Gaussian basis functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:20911,Performance,perform,performance,20911,"i4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib packag",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24401,Performance,tune,tune,24401,"w; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24442,Performance,perform,performance,24442,"w; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:1564,Safety,detect,detected,1564," Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installatio",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:12457,Safety,detect,detected,12457,"rectories where to look for header files. Directories should be specified; prepended by -I, i.e. -Idir1 -Idir2, etc. If several directories are; specified, enclose the list with single right-quotes, e.g.,; --with-incdirs='-I/usr/local/include -I/home/psi4/include'. --with-libs=libraries — Use this option to specify extra; libraries which should be used during linking. Libraries should be; specified by their full names or in the usual -l notation, e.g.; -lm /usr/lib/libm.a. If several libraries are specified, enclose; the list with single right-quotes, e.g.,; --with-libs='-libm -lgcc_s'. --with-libdirs=directories — Use this option to specify extra; directories where to look for libraries. Directories should be specified; prepended by -L, e.g., -Ldir1 -Ldir2. If several directories are; specified, enclose the list with single right-quotes, e.g.,; --with-libdirs='-L/usr/local/lib -I/home/psi4/lib'. --with-blas=library — Use this option to specify a BLAS library.; (Many BLAS libraries can be detected automatically.); If your BLAS library has multiple components, enclose the file list; with single right-quotes, e.g.,; --with-blas='-lf77blas -latlas'. --with-lapack=library — Use this option to specify a LAPACK library.; (Many LAPACK libraries can be detected automatically.); If your LAPACK library has multiple components, enclose the file list; with single right-quotes, e.g.,; --with-lapack='-llapack -lcblas -latlas'. --with-max-am-eri=integer — Specifies the maximum angular momentum; level for the primitive Gaussian basis functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:12718,Safety,detect,detected,12718,"ude'. --with-libs=libraries — Use this option to specify extra; libraries which should be used during linking. Libraries should be; specified by their full names or in the usual -l notation, e.g.; -lm /usr/lib/libm.a. If several libraries are specified, enclose; the list with single right-quotes, e.g.,; --with-libs='-libm -lgcc_s'. --with-libdirs=directories — Use this option to specify extra; directories where to look for libraries. Directories should be specified; prepended by -L, e.g., -Ldir1 -Ldir2. If several directories are; specified, enclose the list with single right-quotes, e.g.,; --with-libdirs='-L/usr/local/lib -I/home/psi4/lib'. --with-blas=library — Use this option to specify a BLAS library.; (Many BLAS libraries can be detected automatically.); If your BLAS library has multiple components, enclose the file list; with single right-quotes, e.g.,; --with-blas='-lf77blas -latlas'. --with-lapack=library — Use this option to specify a LAPACK library.; (Many LAPACK libraries can be detected automatically.); If your LAPACK library has multiple components, enclose the file list; with single right-quotes, e.g.,; --with-lapack='-llapack -lcblas -latlas'. --with-max-am-eri=integer — Specifies the maximum angular momentum; level for the primitive Gaussian basis functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet ac",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:14007,Safety,detect,detected,14007," functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (bo",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:15768,Safety,detect,detection,15768,"build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_filesystem-gcc-mt. --with-boost-python — Specify the boost python library or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:15826,Safety,detect,detection,15826,"build the boost version 1.48.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.48.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; it if no. --with-boost-libdir=directory —; Force given directory for boost libraries. Note that this will override; library path detection, so use this parameter only if default library; detection fails and you know exactly where your boost libraries are; located. --with-boost-filesystem[=special-lib] —; Use the Filesystem library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-filesystem=boost_filesystem-gcc-mt. --with-boost-python — Specify the boost python library or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:24706,Safety,detect,detect,24706,"2 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PS",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:19059,Security,access,access,19059,"available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; gri",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21783,Security,access,access,21783,"ibutions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4520,Testability,test,tests,4520,"tion, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, i",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4535,Testability,test,tests,4535,"tion, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, i",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:4579,Testability,test,tests,4579,"s directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17143,Testability,test,test,17143,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17194,Testability,test,tests,17194,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17265,Testability,test,test,17265,"specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTe",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17322,Testability,test,test,17322,"_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17415,Testability,test,testing,17415,"; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefi",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17465,Testability,test,testing,17465,"rary for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17513,Testability,test,tests,17513,"rary for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17568,Testability,test,testsclean,17568,"ith-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 packa",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17602,Testability,test,test,17602,"ith-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 packa",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17647,Testability,test,testing,17647,"; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her p",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:19987,Testability,test,testing,19987," Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is le",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:5444,Usability,simpl,simple,5444,"./do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:17174,Usability,simpl,simply,17174,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:21486,Usability,simpl,simplest,21486,"libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; ",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:25318,Usability,simpl,simply,25318,"ottling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. T",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/installfile.html:26324,Usability,simpl,simple,26324," make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instruc",MatchSource.WIKI,psi4manual/4.0b3/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:2097,Deployability,update,updated,2097,"Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:440,Energy Efficiency,energy,energy,440,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:567,Energy Efficiency,energy,energy,567,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:603,Energy Efficiency,energy,energy,603,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:753,Energy Efficiency,energy,energy,753,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:929,Energy Efficiency,energy,energy,929,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:1052,Energy Efficiency,energy,energy,1052,"dex. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:1082,Energy Efficiency,energy,energy,1082,"dex. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:351,Performance,optimiz,optimize,351,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls-1.html:645,Security,validat,validated,645,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls-1.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:2097,Deployability,update,updated,2097,"Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:440,Energy Efficiency,energy,energy,440,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:567,Energy Efficiency,energy,energy,567,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:603,Energy Efficiency,energy,energy,603,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:753,Energy Efficiency,energy,energy,753,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:929,Energy Efficiency,energy,energy,929,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:1052,Energy Efficiency,energy,energy,1052,"dex. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:1082,Energy Efficiency,energy,energy,1082,"dex. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:351,Performance,optimiz,optimize,351,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/intercalls.html:645,Security,validat,validated,645,"﻿. Function Intercalls — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b3/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/intercalls.html
https://psicode.org/psi4manual/4.0b3/interfacing-1.html:971,Deployability,update,updated,971,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay PSI4 can drive the MRCC program of M. Kállay and J. Gauss; Interface to DFTD3 by S. Grimme PSI4 can drive the DFTD3 program of S. Grimme for DFT-D3 energies and gradients; MPI4Py; MADNESS; MATLAB for new dft functionals. Previous topic; Function Intercalls; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/interfacing-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/interfacing-1.html
https://psicode.org/psi4manual/4.0b3/interfacing.html:971,Deployability,update,updated,971,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay PSI4 can drive the MRCC program of M. Kállay and J. Gauss; Interface to DFTD3 by S. Grimme PSI4 can drive the DFTD3 program of S. Grimme for DFT-D3 energies and gradients; MPI4Py; MADNESS; MATLAB for new dft functionals. Previous topic; Function Intercalls; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/interfacing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/interfacing.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:1549,Availability,avail,available,1549,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:1611,Availability,avail,available,1611,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:4954,Availability,avail,available,4954,"lista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural O",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:7733,Availability,avail,available,7733,"C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; t",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:7877,Availability,avail,available,7877,"te Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS;",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:9428,Availability,reliab,reliability,9428,"; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or fu",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:10555,Deployability,update,updated,10555,"F; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:341,Energy Efficiency,efficient,efficiently,341,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:5022,Energy Efficiency,adapt,adapted,5022," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:9017,Energy Efficiency,energy,energy,9017,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:9086,Energy Efficiency,energy,energy,9086,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:492,Integrability,rout,routine,492,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:10028,Integrability,rout,routines,10028,"F; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:5022,Modifiability,adapt,adapted,5022," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:1384,Performance,optimiz,optimization,1384,"machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6192,Performance,optimiz,optimization,6192,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6221,Performance,optimiz,optimized,6221,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6277,Performance,optimiz,optimized,6277,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6505,Performance,optimiz,optimization,6505,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6534,Performance,optimiz,optimized,6534,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:6590,Performance,optimiz,optimized,6590,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:7432,Performance,perform,perform,7432,"ithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCS",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:8949,Performance,optimiz,optimization,8949,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:9040,Performance,perform,performed,9040,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:7142,Testability,test,tested,7142,"0). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RH",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction-1.html:475,Usability,simpl,simple,475,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html
https://psicode.org/psi4manual/4.0b3/introduction.html:1549,Availability,avail,available,1549,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:1611,Availability,avail,available,1611,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:4954,Availability,avail,available,4954,"lista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural O",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:7733,Availability,avail,available,7733,"C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; t",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:7877,Availability,avail,available,7877,"te Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS;",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:9428,Availability,reliab,reliability,9428,"; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or fu",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:10555,Deployability,update,updated,10555,"F; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:341,Energy Efficiency,efficient,efficiently,341,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:5022,Energy Efficiency,adapt,adapted,5022," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:9017,Energy Efficiency,energy,energy,9017,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:9086,Energy Efficiency,energy,energy,9086,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:492,Integrability,rout,routine,492,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:10028,Integrability,rout,routines,10028,"F; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:5022,Modifiability,adapt,adapted,5022," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:1384,Performance,optimiz,optimization,1384,"machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6192,Performance,optimiz,optimization,6192,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6221,Performance,optimiz,optimized,6221,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6277,Performance,optimiz,optimized,6277,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6505,Performance,optimiz,optimization,6505,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6534,Performance,optimiz,optimized,6534,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:6590,Performance,optimiz,optimized,6590,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:7432,Performance,perform,perform,7432,"ithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCS",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:8949,Performance,optimiz,optimization,8949,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:9040,Performance,perform,performed,9040,"readed. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. CEPA(n); Y; N; RHF; threaded [3]. ACPF/AQCC; Y; N; RHF; threaded [3]. OMP2; Y; Y; RHF/UHF/RKS/UKS; partially threaded. OMP3; Y; N; RHF/UHF/RKS/UKS; partially threaded. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta3. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) threading throu",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:7142,Testability,test,tested,7142,"0). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RH",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/introduction.html:475,Usability,simpl,simple,475,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4manual/4.0b3/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction.html
https://psicode.org/psi4manual/4.0b3/methods-1.html:222,Availability,avail,available,222,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html
https://psicode.org/psi4manual/4.0b3/methods-1.html:396,Availability,avail,available,396,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html
https://psicode.org/psi4manual/4.0b3/methods-1.html:332,Deployability,configurat,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html
https://psicode.org/psi4manual/4.0b3/methods-1.html:2564,Deployability,update,updated,2564,"/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html
https://psicode.org/psi4manual/4.0b3/methods-1.html:332,Modifiability,config,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html
https://psicode.org/psi4manual/4.0b3/methods.html:222,Availability,avail,available,222,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods.html
https://psicode.org/psi4manual/4.0b3/methods.html:396,Availability,avail,available,396,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods.html
https://psicode.org/psi4manual/4.0b3/methods.html:332,Deployability,configurat,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods.html
https://psicode.org/psi4manual/4.0b3/methods.html:2564,Deployability,update,updated,2564,"/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods.html
https://psicode.org/psi4manual/4.0b3/methods.html:332,Modifiability,config,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary O",MatchSource.WIKI,psi4manual/4.0b3/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:755,Availability,error,error,755,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1722,Availability,avail,available,1722,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2177,Availability,avail,available,2177,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2889,Deployability,update,updated,2889,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:915,Energy Efficiency,energy,energy,915,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1061,Energy Efficiency,energy,energy,1061,"entation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1105,Energy Efficiency,energy,energy,1105,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1206,Energy Efficiency,energy,energy,1206,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1230,Energy Efficiency,energy,energy,1230,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1278,Energy Efficiency,energy,energy,1278,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:364,Integrability,interface,interface,364,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1745,Integrability,interface,interface,1745,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2264,Integrability,interface,interface,2264,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1139,Performance,perform,perform,1139,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1308,Performance,perform,perform,1308,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1325,Performance,optimiz,optimization,1325,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2279,Performance,optimiz,optimize,2279,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2432,Performance,optimiz,optimize,2432,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:957,Usability,simpl,simply,957,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc-1.html:1238,Usability,simpl,simply,1238,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:755,Availability,error,error,755,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1722,Availability,avail,available,1722,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:2177,Availability,avail,available,2177,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:2889,Deployability,update,updated,2889,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:915,Energy Efficiency,energy,energy,915,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1061,Energy Efficiency,energy,energy,1061,"entation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1105,Energy Efficiency,energy,energy,1105,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1206,Energy Efficiency,energy,energy,1206,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1230,Energy Efficiency,energy,energy,1230,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1278,Energy Efficiency,energy,energy,1278,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:364,Integrability,interface,interface,364,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1745,Integrability,interface,interface,1745,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:2264,Integrability,interface,interface,2264,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1139,Performance,perform,perform,1139,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1308,Performance,perform,perform,1308,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1325,Performance,optimiz,optimization,1325,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:2279,Performance,optimiz,optimize,2279,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:2432,Performance,optimiz,optimize,2432,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:957,Usability,simpl,simply,957,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/mrcc.html:1238,Usability,simpl,simply,1238,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b3/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc.html
https://psicode.org/psi4manual/4.0b3/notes_c-1.html:846,Availability,toler,tolerance,846,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c-1.html
https://psicode.org/psi4manual/4.0b3/notes_c-1.html:1503,Deployability,update,updated,1503,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c-1.html
https://psicode.org/psi4manual/4.0b3/notes_c-1.html:404,Energy Efficiency,energy,energy,404,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c-1.html
https://psicode.org/psi4manual/4.0b3/notes_c-1.html:1068,Energy Efficiency,energy,energy,1068,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c-1.html
https://psicode.org/psi4manual/4.0b3/notes_c.html:846,Availability,toler,tolerance,846,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c.html
https://psicode.org/psi4manual/4.0b3/notes_c.html:1503,Deployability,update,updated,1503,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c.html
https://psicode.org/psi4manual/4.0b3/notes_c.html:404,Energy Efficiency,energy,energy,404,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c.html
https://psicode.org/psi4manual/4.0b3/notes_c.html:1068,Energy Efficiency,energy,energy,1068,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_c.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:1923,Deployability,update,updated,1923,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:349,Energy Efficiency,energy,energy,349,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:904,Energy Efficiency,energy,energy,904,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:1134,Energy Efficiency,energy,energy,1134,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:1269,Integrability,wrap,wrapped,1269,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:1545,Integrability,wrap,wrapped,1545,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py-1.html:847,Performance,optimiz,optimize,847,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py-1.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:1923,Deployability,update,updated,1923,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:349,Energy Efficiency,energy,energy,349,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:904,Energy Efficiency,energy,energy,904,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:1134,Energy Efficiency,energy,energy,1134,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:1269,Integrability,wrap,wrapped,1269,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:1545,Integrability,wrap,wrapped,1545,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/notes_py.html:847,Performance,optimiz,optimize,847,"﻿. Notes on Options — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/notes_py.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:983,Availability,avail,available,983,"aluation of One-Electron Properties — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:2748,Deployability,update,updated,2748,"properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1625,Energy Efficiency,charge,charges,1625,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . n",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1669,Energy Efficiency,charge,charges,1669,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theo",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:2316,Energy Efficiency,charge,charge,2316,"properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:664,Modifiability,variab,variables,664,"﻿. Evaluation of One-Electron Properties — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN ke",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1310,Modifiability,variab,variables,1310," Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nu",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1521,Modifiability,variab,variables,1521,"wing syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Sour",MatchSource.WIKI,psi4manual/4.0b3/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:983,Availability,avail,available,983,"aluation of One-Electron Properties — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:2748,Deployability,update,updated,2748,"properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:1625,Energy Efficiency,charge,charges,1625,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . n",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:1669,Energy Efficiency,charge,charges,1669,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theo",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:2316,Energy Efficiency,charge,charge,2316,"properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:664,Modifiability,variab,variables,664,"﻿. Evaluation of One-Electron Properties — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN ke",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:1310,Modifiability,variab,variables,1310," Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nu",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/oeprop.html:1521,Modifiability,variab,variables,1521,"wing syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Sour",MatchSource.WIKI,psi4manual/4.0b3/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:8331,Deployability,update,updated,8331,"l be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. Table Of Contents. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER. Advanced Keywords; OPT_METHOD; DIIS_MAX_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; SOS_SCALE; SOS_SCALE2; NAT_ORBS; OMP2_ORBS_PRINT; OMP3_ORBS_PRINT; TPDM_ABCD_TYPE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; ADC: Ab Initio Polarization Propagator; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:1737,Energy Efficiency,energy,energy,1737,"bed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster ba",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2896,Energy Efficiency,energy,energy,2896," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:3528,Energy Efficiency,energy,energy,3528,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spi",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:3656,Energy Efficiency,energy,energy,3656,"rrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase i",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:3707,Energy Efficiency,energy,energy,3707,"aya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:3878,Energy Efficiency,energy,energy,3878,"etter potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; ",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:5710,Energy Efficiency,energy,energy,5710,"mp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_S",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:428,Performance,optimiz,optimized,428,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:479,Performance,optimiz,optimized,479,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:526,Performance,optimiz,optimized,526,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:1131,Performance,optimiz,optimized,1131,"o FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:1333,Performance,optimiz,optimized,1333,"ariables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-repres",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2321,Performance,optimiz,optimized,2321,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2350,Performance,optimiz,optimized,2350,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2502,Performance,perform,performance,2502,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and d",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2572,Performance,optimiz,optimized,2572,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and d",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:2771,Performance,optimiz,optimized,2771," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:3009,Performance,optimiz,optimized,3009,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:4257,Performance,optimiz,optimized,4257," orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:4960,Performance,optimiz,optimized,4960,ting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence ,MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:6204,Performance,optimiz,optimization,6204,"HF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:6911,Performance,optimiz,optimized-,6911,"RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. Table Of Contents. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER. Advanced Keywords; OPT_METHOD; DIIS_MAX_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; SOS_SCALE; SOS_SCALE2; NAT_ORBS; OMP2_ORBS_PRINT; O",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn-1.html:1157,Safety,avoid,avoids,1157,"o FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b3/ompn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html
https://psicode.org/psi4manual/4.0b3/ompn.html:8331,Deployability,update,updated,8331,"l be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. Table Of Contents. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER. Advanced Keywords; OPT_METHOD; DIIS_MAX_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; SOS_SCALE; SOS_SCALE2; NAT_ORBS; OMP2_ORBS_PRINT; OMP3_ORBS_PRINT; TPDM_ABCD_TYPE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; ADC: Ab Initio Polarization Propagator; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:1737,Energy Efficiency,energy,energy,1737,"bed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster ba",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2896,Energy Efficiency,energy,energy,2896," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:3528,Energy Efficiency,energy,energy,3528,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spi",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:3656,Energy Efficiency,energy,energy,3656,"rrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase i",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:3707,Energy Efficiency,energy,energy,3707,"aya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:3878,Energy Efficiency,energy,energy,3878,"etter potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; ",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:5710,Energy Efficiency,energy,energy,5710,"mp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_S",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:428,Performance,optimiz,optimized,428,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:479,Performance,optimiz,optimized,479,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:526,Performance,optimiz,optimized,526,"﻿. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at ",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:1131,Performance,optimiz,optimized,1131,"o FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:1333,Performance,optimiz,optimized,1333,"ariables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-repres",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2321,Performance,optimiz,optimized,2321,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2350,Performance,optimiz,optimized,2350,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2502,Performance,perform,performance,2502,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and d",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2572,Performance,optimiz,optimized,2572,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and d",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:2771,Performance,optimiz,optimized,2771," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:3009,Performance,optimiz,optimized,3009,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:4257,Performance,optimiz,optimized,4257," orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:4960,Performance,optimiz,optimized,4960,ting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence ,MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:6204,Performance,optimiz,optimization,6204,"HF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:6911,Performance,optimiz,optimized-,6911,"RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. Table Of Contents. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER. Advanced Keywords; OPT_METHOD; DIIS_MAX_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; SOS_SCALE; SOS_SCALE2; NAT_ORBS; OMP2_ORBS_PRINT; O",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/ompn.html:1157,Safety,avoid,avoids,1157,"o FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b3/ompn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:437,Availability,avail,available,437,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8064,Availability,avail,available,8064,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7620,Deployability,continuous,continuous,7620,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7805,Deployability,continuous,continuous,7805,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8848,Deployability,update,updated,8848,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:332,Energy Efficiency,energy,energy,332,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:524,Energy Efficiency,energy,energy,524,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7240,Energy Efficiency,energy,energy,7240,"). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Ana",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7280,Energy Efficiency,energy,energy,7280," PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7410,Energy Efficiency,energy,energy,7410,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8024,Energy Efficiency,energy,energy,8024,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:379,Modifiability,variab,variables,379,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:180,Performance,optimiz,optimize,180,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:250,Performance,perform,perform,250,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:269,Performance,optimiz,optimization,269,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:342,Performance,optimiz,optimized,342,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:704,Performance,optimiz,optimized,704,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:6641,Performance,optimiz,optimization,6641,"ersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. m",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:6691,Performance,optimiz,optimizations,6691,"tional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies opti",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:6854,Performance,optimiz,optimization,6854," Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7335,Performance,perform,performed,7335," PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7432,Performance,perform,performs,7432,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7688,Performance,optimiz,optimization,7688,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7764,Performance,optimiz,optimization,7764,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8097,Performance,optimiz,optimization,8097,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8119,Performance,perform,performed,8119,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8255,Performance,optimiz,optimization,8255,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8273,Performance,optimiz,optimize,8273,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8322,Performance,optimiz,optimization,8322,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8392,Performance,optimiz,optimization,8392,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8410,Performance,optimiz,optimize,8410,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:8474,Performance,optimiz,optimization,8474,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:6668,Safety,unsafe,unsafe,6668,"tional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies opti",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:7383,Security,access,accesses,7383,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt-1.html:6818,Usability,clear,clear,6818," Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('",MatchSource.WIKI,psi4manual/4.0b3/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html
https://psicode.org/psi4manual/4.0b3/opt.html:437,Availability,avail,available,437,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8064,Availability,avail,available,8064,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7620,Deployability,continuous,continuous,7620,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7805,Deployability,continuous,continuous,7805,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8848,Deployability,update,updated,8848,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:332,Energy Efficiency,energy,energy,332,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:524,Energy Efficiency,energy,energy,524,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7240,Energy Efficiency,energy,energy,7240,"). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Ana",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7280,Energy Efficiency,energy,energy,7280," PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7410,Energy Efficiency,energy,energy,7410,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8024,Energy Efficiency,energy,energy,8024,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:379,Modifiability,variab,variables,379,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:180,Performance,optimiz,optimize,180,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:250,Performance,perform,perform,250,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:269,Performance,optimiz,optimization,269,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:342,Performance,optimiz,optimized,342,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:704,Performance,optimiz,optimized,704,"﻿. Optimize — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. omp2; orbital-optimized second order Moller–Plesset perturbation theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). df-mp2; MP2 with density fitting. conv-mp2; conventional MP2 (non-density-fitting). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. name; calls method. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d; B97-D Pure-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b97-d3; B97-D Pure-GG",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:6641,Performance,optimiz,optimization,6641,"ersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. m",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:6691,Performance,optimiz,optimizations,6691,"tional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies opti",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:6854,Performance,optimiz,optimization,6854," Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7335,Performance,perform,performed,7335," PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7432,Performance,perform,performs,7432,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7688,Performance,optimiz,optimization,7688,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7764,Performance,optimiz,optimization,7764,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8097,Performance,optimiz,optimization,8097,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8119,Performance,perform,performed,8119,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8255,Performance,optimiz,optimization,8255,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8273,Performance,optimiz,optimize,8273,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8322,Performance,optimiz,optimization,8322,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8392,Performance,optimiz,optimization,8392,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8410,Performance,optimiz,optimize,8410,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:8474,Performance,optimiz,optimization,8474,"cule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:6668,Safety,unsafe,unsafe,6668,"tional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies opti",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:7383,Security,access,accesses,7383,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/opt.html:6818,Usability,clear,clear,6818," Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('",MatchSource.WIKI,psi4manual/4.0b3/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:894,Availability,avail,available,894,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:6326,Availability,avail,available,6326,"river function is to query for the value of any option the; function may want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:11355,Availability,error,error,11355,"n the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, t",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:11576,Availability,error,error,11576,"F', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:11870,Availability,error,error,11870,"l scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by eith",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:14363,Deployability,update,updated,14363,"the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by either user or code.; Notwithstanding, code is written such that in practice, this returns; whether the option has been touched by the user. PsiMod.revoke_global_option_changed(keyword)¶; Given a string of keyword name, sets the has_changed attribute in the; global options scope to false. Used in python driver when a function; sets the value of an option. Before the function exits, this command is; called on the option so that has_changed reflects whether the user (not; the program) has touched the option. PsiMod.revoke_local_option_changed(module, keyword)¶; Given a string of keyword name and a particular module, sets the; has_changed attribute in the module options scope to false. Used in; python driver when a function sets the value of an option. Before the; function exits, this command is called on the option so that; has_changed reflects whether the user (not the program) has touched the; option. Table Of Contents. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; Programming: Using the Core Libraries; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:1045,Integrability,rout,routine,1045,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:1241,Integrability,rout,routine,1241,"nd all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.add_str(""AO_BASIS"", ""NONE"", ""NONE DISK DIRECT"");; }. In the above example, the following options are declared (in order):. An integer called PRINT with a default value of 1.; A boolean calle",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:10458,Integrability,depend,depending,10458,"ody of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:407,Modifiability,plugin,plugin,407,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:692,Modifiability,plugin,plugin,692,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:1031,Modifiability,plugin,plugins,1031,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:1085,Modifiability,plugin,plugin,1085,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:10440,Modifiability,variab,variable,10440,"ody of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:7755,Performance,perform,performed,7755,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = PsiMod.get_global_option('SCF_TYPE'); l_user_scftype_scf = PsiMod.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = PsiMod.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = PsiMod.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = PsiMod.get_global_option('WFN'); l_user_wfn = PsiMod.get_local_option('MP2', 'WFN'); bg_user_wfn = PsiMod.has_global_option_changed('WFN'); bl_user_wfn = PsiMod.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # PsiMod.scf() and PsiMod.mp2() are run. PsiMod.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'); PsiMod.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; PsiMod.revoke_local_o",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:805,Security,access,accessible,805,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:6381,Security,access,accessible,6381,"t to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:269,Usability,simpl,simplify,269,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:3369,Usability,clear,clear,3369," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:4114,Usability,guid,guidelines,4114,"between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4manual/4.0b3/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:894,Availability,avail,available,894,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:6326,Availability,avail,available,6326,"river function is to query for the value of any option the; function may want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:11355,Availability,error,error,11355,"n the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, t",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:11576,Availability,error,error,11576,"F', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:11870,Availability,error,error,11870,"l scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by eith",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:14363,Deployability,update,updated,14363,"the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by either user or code.; Notwithstanding, code is written such that in practice, this returns; whether the option has been touched by the user. PsiMod.revoke_global_option_changed(keyword)¶; Given a string of keyword name, sets the has_changed attribute in the; global options scope to false. Used in python driver when a function; sets the value of an option. Before the function exits, this command is; called on the option so that has_changed reflects whether the user (not; the program) has touched the option. PsiMod.revoke_local_option_changed(module, keyword)¶; Given a string of keyword name and a particular module, sets the; has_changed attribute in the module options scope to false. Used in; python driver when a function sets the value of an option. Before the; function exits, this command is called on the option so that; has_changed reflects whether the user (not the program) has touched the; option. Table Of Contents. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; Programming: Using the Core Libraries; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:1045,Integrability,rout,routine,1045,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:1241,Integrability,rout,routine,1241,"nd all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.add_str(""AO_BASIS"", ""NONE"", ""NONE DISK DIRECT"");; }. In the above example, the following options are declared (in order):. An integer called PRINT with a default value of 1.; A boolean calle",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:10458,Integrability,depend,depending,10458,"ody of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:407,Modifiability,plugin,plugin,407,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:692,Modifiability,plugin,plugin,692,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:1031,Modifiability,plugin,plugins,1031,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:1085,Modifiability,plugin,plugin,1085,"I4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:10440,Modifiability,variab,variable,10440,"ody of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:7755,Performance,perform,performed,7755,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = PsiMod.get_global_option('SCF_TYPE'); l_user_scftype_scf = PsiMod.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = PsiMod.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = PsiMod.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = PsiMod.get_global_option('WFN'); l_user_wfn = PsiMod.get_local_option('MP2', 'WFN'); bg_user_wfn = PsiMod.has_global_option_changed('WFN'); bl_user_wfn = PsiMod.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # PsiMod.scf() and PsiMod.mp2() are run. PsiMod.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'); PsiMod.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; PsiMod.revoke_local_o",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:805,Security,access,accessible,805,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:6381,Security,access,accessible,6381,"t to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:269,Usability,simpl,simplify,269,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:3369,Usability,clear,clear,3369," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed ",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optionshandling.html:4114,Usability,guid,guidelines,4114,"between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4manual/4.0b3/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:594,Availability,redundant,redundant,594,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:732,Availability,redundant,redundant,732,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:1043,Availability,redundant,redundant,1043,"eta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5165,Availability,avail,available,5165,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5339,Availability,avail,available,5339,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5584,Availability,avail,available,5584," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:8210,Availability,avail,available,8210,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:659,Deployability,update,update,659,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5565,Deployability,update,update,5565," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:11349,Deployability,update,updated,11349,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4677,Energy Efficiency,energy,energy,4677,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4739,Energy Efficiency,energy,energy,4739,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:7486,Energy Efficiency,monitor,monitors,7486,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:7611,Energy Efficiency,energy,energy,7611,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:9098,Energy Efficiency,monitor,monitored,9098,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:9502,Energy Efficiency,monitor,monitored,9502,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:344,Performance,optimiz,optimizations,344,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:1956,Performance,optimiz,optimization,1956," and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:2006,Performance,optimiz,optimizations,2006,"t to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic posit",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:2169,Performance,optimiz,optimization,2169,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:3242,Performance,optimiz,optimization,3242,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:3423,Performance,optimiz,optimization,3423," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:3494,Performance,optimiz,optimization,3494,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:3953,Performance,optimiz,optimization,3953,"points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4551,Performance,optimiz,optimize,4551,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4645,Performance,optimiz,optimize,4645,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4714,Performance,optimiz,optimize,4714,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:4837,Performance,optimiz,optimize,4837,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5007,Performance,optimiz,optimize,5007,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5102,Performance,optimiz,optimize,5102,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5712,Performance,optimiz,optimization,5712,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fra",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5861,Performance,optimiz,optimize,5861,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragme",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:6119,Performance,optimiz,optimize,6119,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:6448,Performance,optimiz,optimize,6448,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:6546,Performance,optimiz,optimize,6546,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:6896,Performance,optimiz,optimizations,6896," the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:7257,Performance,optimiz,optimize,7257,"2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:7551,Performance,optimiz,optimization,7551,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:8188,Performance,optimiz,optimization,8188,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:9482,Performance,optimiz,optimization,9482,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:10682,Performance,optimiz,optimizations,10682,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:10712,Performance,optimiz,optimize,10712,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:594,Safety,redund,redundant,594,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:732,Safety,redund,redundant,732,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:1043,Safety,redund,redundant,1043,"eta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; ",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:1983,Safety,unsafe,unsafe,1983,"t to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic posit",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:9383,Safety,avoid,avoid,9383,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:903,Testability,test,tested,903,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:1305,Testability,test,testing,1305," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian represent",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:2133,Usability,clear,clear,2133,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking-1.html:5466,Usability,simpl,simple,5466,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b3/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html
https://psicode.org/psi4manual/4.0b3/optking.html:594,Availability,redundant,redundant,594,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:732,Availability,redundant,redundant,732,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:1043,Availability,redundant,redundant,1043,"eta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5165,Availability,avail,available,5165,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5339,Availability,avail,available,5339,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5584,Availability,avail,available,5584," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:8210,Availability,avail,available,8210,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:659,Deployability,update,update,659,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5565,Deployability,update,update,5565," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:11349,Deployability,update,updated,11349,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4677,Energy Efficiency,energy,energy,4677,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4739,Energy Efficiency,energy,energy,4739,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:7486,Energy Efficiency,monitor,monitors,7486,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:7611,Energy Efficiency,energy,energy,7611,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:9098,Energy Efficiency,monitor,monitored,9098,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:9502,Energy Efficiency,monitor,monitored,9502,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:344,Performance,optimiz,optimizations,344,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:1956,Performance,optimiz,optimization,1956," and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:2006,Performance,optimiz,optimizations,2006,"t to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic posit",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:2169,Performance,optimiz,optimization,2169,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:3242,Performance,optimiz,optimization,3242,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:3423,Performance,optimiz,optimization,3423," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:3494,Performance,optimiz,optimization,3494,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:3953,Performance,optimiz,optimization,3953,"points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4551,Performance,optimiz,optimize,4551,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4645,Performance,optimiz,optimize,4645,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4714,Performance,optimiz,optimize,4714,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:4837,Performance,optimiz,optimize,4837,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5007,Performance,optimiz,optimize,5007,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5102,Performance,optimiz,optimize,5102,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5712,Performance,optimiz,optimization,5712,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fra",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5861,Performance,optimiz,optimize,5861,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragme",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:6119,Performance,optimiz,optimize,6119,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:6448,Performance,optimiz,optimize,6448,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:6546,Performance,optimiz,optimize,6546,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:6896,Performance,optimiz,optimizations,6896," the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:7257,Performance,optimiz,optimize,7257,"2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:7551,Performance,optimiz,optimization,7551,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:8188,Performance,optimiz,optimization,8188,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:9482,Performance,optimiz,optimization,9482,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:10682,Performance,optimiz,optimizations,10682,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:10712,Performance,optimiz,optimize,10712,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:594,Safety,redund,redundant,594,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:732,Safety,redund,redundant,732,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:1043,Safety,redund,redundant,1043,"eta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; ",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:1983,Safety,unsafe,unsafe,1983,"t to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic posit",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:9383,Safety,avoid,avoid,9383,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:903,Testability,test,tested,903,"﻿. Geometry Optimization — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run mult",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:1305,Testability,test,testing,1305," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian represent",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:2133,Usability,clear,clear,2133,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/optking.html:5466,Usability,simpl,simple,5466,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b3/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:1580,Availability,down,down,1580,"osal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; ",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:3551,Deployability,update,updated,3551,"e statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:520,Integrability,protocol,protocol,520,"﻿. PEP1: Proposing PsiPEP for PSI4 — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». PEP1: Proposing PsiPEP for PSI4¶. PEP:1. Title:Proposing PsiPEP for PSI4. Last-Modified:04-Jul-2012. Author:Lori Burns. Content-Type:text/x-rst. Created:04-Jul-2012. This document proposes using a (much more informal) version of Python’s; PEP (Python Enhancement Proposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices o",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:2287,Integrability,interface,interface,2287,"ther PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a mo",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:2361,Integrability,interface,interface,2361," Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . ",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001-1.html:1603,Usability,simpl,simple,1603,"e is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4manual/4.0b3/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001-1.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:1580,Availability,down,down,1580,"osal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; ",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:3551,Deployability,update,updated,3551,"e statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 01, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:520,Integrability,protocol,protocol,520,"﻿. PEP1: Proposing PsiPEP for PSI4 — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». PEP1: Proposing PsiPEP for PSI4¶. PEP:1. Title:Proposing PsiPEP for PSI4. Last-Modified:04-Jul-2012. Author:Lori Burns. Content-Type:text/x-rst. Created:04-Jul-2012. This document proposes using a (much more informal) version of Python’s; PEP (Python Enhancement Proposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices o",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:2287,Integrability,interface,interface,2287,"ther PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a mo",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:2361,Integrability,interface,interface,2361," Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . ",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/pep0001.html:1603,Usability,simpl,simple,1603,"e is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4manual/4.0b3/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/pep0001.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3196,Availability,avail,available,3196,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6585,Availability,avail,available,6585," or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Cont",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:8096,Deployability,update,updated,8096,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5169,Energy Efficiency,energy,energy,5169,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5210,Energy Efficiency,energy,energy,5210,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6529,Energy Efficiency,energy,energy,6529," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:1159,Integrability,wrap,wrapped,1159,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5598,Integrability,depend,depends,5598,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:1857,Modifiability,plugin,plugin,1857," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2036,Modifiability,plugin,plugins,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2108,Modifiability,plugin,plugins,2108,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2170,Modifiability,plugin,plugins,2170,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2193,Modifiability,config,configure,2193,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2233,Modifiability,plugin,plugins,2233,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2299,Modifiability,plugin,plugins,2299,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2397,Modifiability,plugin,plugin,2397," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.i",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2558,Modifiability,plugin,plugin,2558,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mo",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2643,Modifiability,plugin,plugin,2643,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans lib",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2985,Modifiability,plugin,plugin,2985,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3030,Modifiability,plugin,plugin,3030,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3075,Modifiability,plugin,plugin,3075,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3120,Modifiability,plugin,plugin,3120,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3173,Modifiability,plugin,plugin,3173,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3230,Modifiability,plugin,plugins,3230,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3255,Modifiability,plugin,plugin,3255,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so execut",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3349,Modifiability,plugin,plugin,3349,"pilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3394,Modifiability,plugin,plugins,3394,"n the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure di",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3536,Modifiability,plugin,plugins,3536,"i4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3665,Modifiability,plugin,plugins,3665,"ory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s optio",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3704,Modifiability,plugin,plugin,3704,"into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:3785,Modifiability,plugin,plugins,3785,"mplates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparator",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4004,Modifiability,plugin,plugin,4004," psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4131,Modifiability,plugin,plugin,4131,"yplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hoo",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4194,Modifiability,plugin,plugin,4194,"; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4235,Modifiability,plugin,plugin,4235,"; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4395,Modifiability,config,configure,4395," psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4422,Modifiability,plugin,plugins,4422," psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4471,Modifiability,plugin,plugin,4471,"ts library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless a",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4549,Modifiability,plugin,plugin,4549,"gins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4643,Modifiability,plugin,plugin,4643,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4719,Modifiability,plugin,plugin,4719,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4755,Modifiability,plugin,plugin,4755,"lugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4873,Modifiability,plugin,plugin,4873,"ary to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4908,Modifiability,plugin,plugin,4908,"etry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5059,Modifiability,plugin,plugin,5059,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5116,Modifiability,plugin,plugin,5116,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5342,Modifiability,plugin,plugin,5342,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5379,Modifiability,plugin,plugin,5379,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5505,Modifiability,plugin,plugin,5505,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5591,Modifiability,plugin,plugin,5591,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5628,Modifiability,plugin,plugin,5628,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5706,Modifiability,plugin,plugin,5706,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5742,Modifiability,plugin,plugin,5742,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5948,Modifiability,plugin,plugin,5948,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6166,Modifiability,plugin,plugin,6166,"function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building document",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6224,Modifiability,plugin,plugin,6224," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6273,Modifiability,plugin,plugin,6273," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6342,Modifiability,plugin,plugin,6342,"ctory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading port",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6472,Modifiability,plugin,plugin,6472," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:7250,Modifiability,plugin,plugin,7250,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:7271,Modifiability,plugin,plugin,7271,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:7533,Modifiability,plugin,plugin,7533,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2051,Performance,load,loaded,2051,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:2222,Performance,load,loading,2222,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4634,Performance,load,load,4634,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6486,Performance,load,loaded,6486," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:7378,Performance,load,loading,7378,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:7521,Performance,load,loading,7521,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5192,Security,access,accessed,5192,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:5777,Testability,test,tests,5777,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:6631,Testability,test,testfunction,6631,"dditional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to De",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:1564,Usability,learn,learn,1564,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4951,Usability,simpl,simple,4951,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins-1.html:4979,Usability,simpl,simpler,4979,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b3/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3196,Availability,avail,available,3196,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6585,Availability,avail,available,6585," or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Cont",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:8096,Deployability,update,updated,8096,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5169,Energy Efficiency,energy,energy,5169,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5210,Energy Efficiency,energy,energy,5210,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6529,Energy Efficiency,energy,energy,6529," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:1159,Integrability,wrap,wrapped,1159,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5598,Integrability,depend,depends,5598,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:1857,Modifiability,plugin,plugin,1857," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2036,Modifiability,plugin,plugins,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2108,Modifiability,plugin,plugins,2108,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2170,Modifiability,plugin,plugins,2170,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2193,Modifiability,config,configure,2193,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2233,Modifiability,plugin,plugins,2233,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2299,Modifiability,plugin,plugins,2299,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2397,Modifiability,plugin,plugin,2397," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.i",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2558,Modifiability,plugin,plugin,2558,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mo",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2643,Modifiability,plugin,plugin,2643,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans lib",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2985,Modifiability,plugin,plugin,2985,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3030,Modifiability,plugin,plugin,3030,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3075,Modifiability,plugin,plugin,3075,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3120,Modifiability,plugin,plugin,3120,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3173,Modifiability,plugin,plugin,3173,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3230,Modifiability,plugin,plugins,3230,"ure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3255,Modifiability,plugin,plugin,3255,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so execut",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3349,Modifiability,plugin,plugin,3349,"pilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3394,Modifiability,plugin,plugins,3394,"n the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure di",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3536,Modifiability,plugin,plugins,3536,"i4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3665,Modifiability,plugin,plugins,3665,"ory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s optio",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3704,Modifiability,plugin,plugin,3704,"into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:3785,Modifiability,plugin,plugins,3785,"mplates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparator",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4004,Modifiability,plugin,plugin,4004," psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4131,Modifiability,plugin,plugin,4131,"yplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hoo",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4194,Modifiability,plugin,plugin,4194,"; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4235,Modifiability,plugin,plugin,4235,"; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4395,Modifiability,config,configure,4395," psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4422,Modifiability,plugin,plugins,4422," psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4471,Modifiability,plugin,plugin,4471,"ts library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless a",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4549,Modifiability,plugin,plugin,4549,"gins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4643,Modifiability,plugin,plugin,4643,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4719,Modifiability,plugin,plugin,4719,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4755,Modifiability,plugin,plugin,4755,"lugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4873,Modifiability,plugin,plugin,4873,"ary to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4908,Modifiability,plugin,plugin,4908,"etry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5059,Modifiability,plugin,plugin,5059,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5116,Modifiability,plugin,plugin,5116,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5342,Modifiability,plugin,plugin,5342,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5379,Modifiability,plugin,plugin,5379,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5505,Modifiability,plugin,plugin,5505,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5591,Modifiability,plugin,plugin,5591,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5628,Modifiability,plugin,plugin,5628,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5706,Modifiability,plugin,plugin,5706,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5742,Modifiability,plugin,plugin,5742,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5948,Modifiability,plugin,plugin,5948,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6166,Modifiability,plugin,plugin,6166,"function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building document",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6224,Modifiability,plugin,plugin,6224," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6273,Modifiability,plugin,plugin,6273," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6342,Modifiability,plugin,plugin,6342,"ctory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading port",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6472,Modifiability,plugin,plugin,6472," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:7250,Modifiability,plugin,plugin,7250,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:7271,Modifiability,plugin,plugin,7271,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:7533,Modifiability,plugin,plugin,7533,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2051,Performance,load,loaded,2051,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:2222,Performance,load,loading,2222,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4634,Performance,load,load,4634,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6486,Performance,load,loaded,6486," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:7378,Performance,load,loading,7378,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:7521,Performance,load,loading,7521,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5192,Security,access,accessed,5192,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:5777,Testability,test,tests,5777,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:6631,Testability,test,testfunction,6631,"dditional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to De",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:1564,Usability,learn,learn,1564,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4951,Usability,simpl,simple,4951,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/plugins.html:4979,Usability,simpl,simpler,4979,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b3/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins.html
https://psicode.org/psi4manual/4.0b3/programming-1.html:707,Deployability,update,updated,707,"﻿. Programming: Using the Core Libraries — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; PEP1: Proposing PsiPEP for PSI4; Next topic; LibOptions: globals, locals, has_changed and all that; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/programming-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/programming-1.html
https://psicode.org/psi4manual/4.0b3/programming.html:707,Deployability,update,updated,707,"﻿. Programming: Using the Core Libraries — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; PEP1: Proposing PsiPEP for PSI4; Next topic; LibOptions: globals, locals, has_changed and all that; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/programming.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/programming.html
https://psicode.org/psi4manual/4.0b3/prop-1.html:1602,Deployability,update,updated,1602,"﻿. Property — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 19, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/prop-1.html
https://psicode.org/psi4manual/4.0b3/prop.html:1602,Deployability,update,updated,1602,"﻿. Property — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 19, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/prop.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:51784,Availability,fault,faulty,51784,"on>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (opt",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:52947,Availability,toler,tolerance,52947," Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real an",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:55387,Availability,checkpoint,checkpoint,55387,"Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:55503,Availability,checkpoint,checkpoint,55503,"rientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fr",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:58510,Availability,checkpoint,checkpoint,58510,"_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_atoms( (Molecule)arg1, (str)arg2, (str)arg3) -> None :; | Sets basis set arg2 to all atoms; | ; | set_basis_by_label(...); | set_basis_by_label( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:107344,Availability,error,error,107344," of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns err",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:107929,Availability,error,error,107929,"ion, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope b",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:108052,Availability,avail,available,108052,"tput file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)a",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:108354,Availability,error,error,108354,"ption_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Ret",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:108627,Availability,avail,available,108627,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:115004,Availability,avail,available,115004,"2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradient to the values stored in the N by 3 Matrix argument.; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; Sets a string option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOr",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:105501,Deployability,configurat,configuration,105501," ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:116404,Deployability,update,updated,116404,"ion( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:31638,Energy Efficiency,energy,energy,31638,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:31653,Energy Efficiency,energy,energy,31653,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:41637,Energy Efficiency,power,power,41637,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:41651,Energy Efficiency,power,power,41651,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:51440,Energy Efficiency,charge,charge,51440,".__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:51950,Energy Efficiency,charge,charge,51950,"ost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_ma",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:52731,Energy Efficiency,charge,charge,52731,"a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | ext",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:53113,Energy Efficiency,charge,charge,53113,"molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 f",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:53128,Energy Efficiency,charge,charge,53128," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:53182,Energy Efficiency,charge,charge,53182," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:56040,Energy Efficiency,charge,charge,56040,"up name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cart",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:56646,Energy Efficiency,energy,energy,56646," bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | ru",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:58047,Energy Efficiency,energy,energy,58047,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:58118,Energy Efficiency,energy,energy,58118,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:60300,Energy Efficiency,charge,charge,60300," (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to atom number (1-indexed, incl. dummies) arg2; | ; | set_basis_by_symbol(...); | set_basis_by_symbol( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with symbol (e.g., H) arg2; | ; | set_geometry(...); | set_geometry( (Molecule)arg1, (Matrix)arg2) -> None :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation di",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:77757,Energy Efficiency,energy,energy,77757,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:77772,Energy Efficiency,energy,energy,77772,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:81160,Energy Efficiency,allocate,allocate,81160,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunc",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:81177,Energy Efficiency,allocate,allocate,81177,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1)",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:94496,Energy Efficiency,energy,energy,94496,"ocstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:94511,Energy Efficiency,energy,energy,94511,"| ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:104373,Energy Efficiency,energy,energy,104373,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:104960,Energy Efficiency,energy,energy,104960,":; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a g",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:105771,Energy Efficiency,energy,energy,105771,"Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:105916,Energy Efficiency,energy,energy,105916,"uster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:106256,Energy Efficiency,energy,energy,106256,"ne :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_o",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:106434,Energy Efficiency,energy,energy,106434," matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.;",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:106819,Energy Efficiency,energy,energy,106819,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)a",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:106959,Energy Efficiency,energy,energy,106959,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:113251,Energy Efficiency,adapt,adapted,113251,"ecent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:105363,Integrability,contract,contracts,105363,"ode.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:1543,Modifiability,inherit,inherited,1543,"sSetParser; CdSalcList; Checkpoint; CorrelationFactor; FittedSlaterCorrelationFactor; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); |",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:1723,Modifiability,inherit,inherited,1723,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_deta",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:3417,Modifiability,inherit,inherited,3417,"_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:3597,Modifiability,inherit,inherited,3597,"t :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:4353,Modifiability,inherit,inherited,4353," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:4533,Modifiability,inherit,inherited,4533,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:5431,Modifiability,inherit,inherited,5431,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:5611,Modifiability,inherit,inherited,5611,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:6920,Modifiability,inherit,inherited,6920,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:7100,Modifiability,inherit,inherited,7100,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and ot",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:7870,Modifiability,inherit,inherited,7870," here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:8050,Modifiability,inherit,inherited,8050,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:9198,Modifiability,inherit,inherited,9198,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:9378,Modifiability,inherit,inherited,9378,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:10131,Modifiability,inherit,inherited,10131," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:10360,Modifiability,inherit,inherited,10360,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:10495,Modifiability,inherit,inherited,10495,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:13174,Modifiability,inherit,inherited,13174,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:13562,Modifiability,inherit,inherited,13562," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:14855,Modifiability,inherit,inherited,14855,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | ci",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:15035,Modifiability,inherit,inherited,15035,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:17832,Modifiability,inherit,inherited,17832,"Dispersion)arg1) -> None :; | docstring; | ; | s6(...); | s6( (Dispersion)arg1) -> float :; | docstring; | ; | s8(...); | s8( (Dispersion)arg1) -> float :; | docstring; | ; | set_bibtex(...); | set_bibtex( (Dispersion)arg1, (str)arg2) -> None :; | Set the BibTeX key for the literature reference.; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:18012,Modifiability,inherit,inherited,18012,"set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:18805,Modifiability,inherit,inherited,18805,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:18985,Modifiability,inherit,inherited,18985,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:20341,Modifiability,inherit,inherited,20341,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:20521,Modifiability,inherit,inherited,20521,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Dat",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:21224,Modifiability,inherit,inherited,21224,"ta and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (Fitti",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:21470,Modifiability,inherit,inherited,21470," __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (Fit",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:21650,Modifiability,inherit,inherited,21650,"n method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:23410,Modifiability,inherit,inherited,23410,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:23590,Modifiability,inherit,inherited,23590,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:26386,Modifiability,inherit,inherited,26386," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:26566,Modifiability,inherit,inherited,26566,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:27320,Modifiability,inherit,inherited,27320," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:27500,Modifiability,inherit,inherited,27500,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:29601,Modifiability,inherit,inherited,29601," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:29781,Modifiability,inherit,inherited,29781,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:30511,Modifiability,inherit,inherited,30511,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:33191,Modifiability,inherit,inherited,33191,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:33371,Modifiability,inherit,inherited,33371,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | toccle",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:35224,Modifiability,inherit,inherited,35224,"(IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:35404,Modifiability,inherit,inherited,35404,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:37294,Modifiability,inherit,inherited,37294,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:37474,Modifiability,inherit,inherited,37474," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:38638,Modifiability,inherit,inherited,38638,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:38818,Modifiability,inherit,inherited,38818,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:44065,Modifiability,inherit,inherited,44065,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:44245,Modifiability,inherit,inherited,44245,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:45322,Modifiability,inherit,inherited,45322,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:45502,Modifiability,inherit,inherited,45502,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_f12(...); | ao_f12( (MintsHelper)arg1, (CorrelationFactor)arg2) -> Matrix :; | docstring; | ; | ao_f12_double_commutator(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:50114,Modifiability,inherit,inherited,50114,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:50294,Modifiability,inherit,inherited,50294,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:50964,Modifiability,inherit,inherited,50964,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:51144,Modifiability,inherit,inherited,51144,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:55137,Modifiability,variab,variable,55137,"g2 fragments Real; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplic",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:55636,Modifiability,variab,variable,55636,"(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion en",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:60815,Modifiability,variab,variable,60815,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:60853,Modifiability,variab,variables,60853,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:61242,Modifiability,variab,variable,61242,"et_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:62132,Modifiability,inherit,inherited,62132,"arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:62312,Modifiability,inherit,inherited,62312,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:63068,Modifiability,inherit,inherited,63068,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:63248,Modifiability,inherit,inherited,63248,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:63909,Modifiability,inherit,inherited,63909,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:64089,Modifiability,inherit,inherited,64089,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:65021,Modifiability,inherit,inherited,65021,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:65201,Modifiability,inherit,inherited,65201,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:67054,Modifiability,inherit,inherited,67054,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:67234,Modifiability,inherit,inherited,67234,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:68211,Modifiability,inherit,inherited,68211,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:68391,Modifiability,inherit,inherited,68391,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:69226,Modifiability,inherit,inherited,69226,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:69406,Modifiability,inherit,inherited,69406,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:70229,Modifiability,inherit,inherited,70229,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:70409,Modifiability,inherit,inherited,70409,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:71480,Modifiability,inherit,inherited,71480,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:71660,Modifiability,inherit,inherited,71660,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:72477,Modifiability,inherit,inherited,72477,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:72706,Modifiability,inherit,inherited,72706,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:72841,Modifiability,inherit,inherited,72841,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:75520,Modifiability,inherit,inherited,75520,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:75908,Modifiability,inherit,inherited,75908," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:76630,Modifiability,inherit,inherited,76630,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:79310,Modifiability,inherit,inherited,79310,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:79490,Modifiability,inherit,inherited,79490,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:80325,Modifiability,inherit,inherited,80325," | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:80505,Modifiability,inherit,inherited,80505,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:85338,Modifiability,inherit,inherited,85338,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:85518,Modifiability,inherit,inherited,85518,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:87586,Modifiability,inherit,inherited,87586,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:87766,Modifiability,inherit,inherited,87766,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:89469,Modifiability,inherit,inherited,89469," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ;",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:89649,Modifiability,inherit,inherited,89649,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:91849,Modifiability,inherit,inherited,91849,"__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | Returns a string representation of arg1, suitable for printing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:92029,Modifiability,inherit,inherited,92029,"ing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:92804,Modifiability,inherit,inherited,92804,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:92984,Modifiability,inherit,inherited,92984,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:96289,Modifiability,inherit,inherited,96289,"> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:96469,Modifiability,inherit,inherited,96469,"> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:97482,Modifiability,extend,extend,97482,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:97497,Modifiability,extend,extend,97497,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:97797,Modifiability,inherit,inherited,97797,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:97977,Modifiability,inherit,inherited,97977,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:105501,Modifiability,config,configuration,105501," ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:108528,Modifiability,variab,variables,108528,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:108617,Modifiability,variab,variables,108617,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:111017,Modifiability,plugin,plugin,111017,t :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the so,MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:111030,Modifiability,plugin,plugin,111030, code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() ,MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:111897,Modifiability,variab,variables,111897,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; Returns the current wavefunction object, from the most recent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a p",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:113251,Modifiability,adapt,adapted,113251,"ecent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:115441,Modifiability,variab,variable,115441,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:41217,Performance,load,load,41217,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:41230,Performance,load,load,41230,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:110662,Performance,optimiz,optimized,110662,"(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:110732,Performance,optimiz,optimized,110732,"mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:110808,Performance,optimiz,optimizer,110808,"n active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like not",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:110890,Performance,optimiz,optimization,110890," parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints ",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:11151,Security,hash,hash,11151,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:73497,Security,hash,hash,73497,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:19720,Usability,clear,clear,19720,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod-1.html:19734,Usability,clear,clear,19734,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | M",MatchSource.WIKI,psi4manual/4.0b3/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html
https://psicode.org/psi4manual/4.0b3/psimod.html:51784,Availability,fault,faulty,51784,"on>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (opt",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:52947,Availability,toler,tolerance,52947," Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real an",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:55387,Availability,checkpoint,checkpoint,55387,"Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:55503,Availability,checkpoint,checkpoint,55503,"rientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fr",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:58510,Availability,checkpoint,checkpoint,58510,"_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_atoms( (Molecule)arg1, (str)arg2, (str)arg3) -> None :; | Sets basis set arg2 to all atoms; | ; | set_basis_by_label(...); | set_basis_by_label( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:107344,Availability,error,error,107344," of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns err",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:107929,Availability,error,error,107929,"ion, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope b",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:108052,Availability,avail,available,108052,"tput file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)a",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:108354,Availability,error,error,108354,"ption_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Ret",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:108627,Availability,avail,available,108627,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:115004,Availability,avail,available,115004,"2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradient to the values stored in the N by 3 Matrix argument.; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; Sets a string option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOr",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:105501,Deployability,configurat,configuration,105501," ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:116404,Deployability,update,updated,116404,"ion( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:31638,Energy Efficiency,energy,energy,31638,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:31653,Energy Efficiency,energy,energy,31653,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:41637,Energy Efficiency,power,power,41637,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:41651,Energy Efficiency,power,power,41651,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:51440,Energy Efficiency,charge,charge,51440,".__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:51950,Energy Efficiency,charge,charge,51950,"ost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_ma",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:52731,Energy Efficiency,charge,charge,52731,"a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | ext",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:53113,Energy Efficiency,charge,charge,53113,"molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 f",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:53128,Energy Efficiency,charge,charge,53128," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:53182,Energy Efficiency,charge,charge,53182," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:56040,Energy Efficiency,charge,charge,56040,"up name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cart",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:56646,Energy Efficiency,energy,energy,56646," bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | ru",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:58047,Energy Efficiency,energy,energy,58047,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:58118,Energy Efficiency,energy,energy,58118,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:60300,Energy Efficiency,charge,charge,60300," (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to atom number (1-indexed, incl. dummies) arg2; | ; | set_basis_by_symbol(...); | set_basis_by_symbol( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with symbol (e.g., H) arg2; | ; | set_geometry(...); | set_geometry( (Molecule)arg1, (Matrix)arg2) -> None :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation di",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:77757,Energy Efficiency,energy,energy,77757,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:77772,Energy Efficiency,energy,energy,77772,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:81160,Energy Efficiency,allocate,allocate,81160,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunc",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:81177,Energy Efficiency,allocate,allocate,81177,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1)",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:94496,Energy Efficiency,energy,energy,94496,"ocstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:94511,Energy Efficiency,energy,energy,94511,"| ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:104373,Energy Efficiency,energy,energy,104373,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:104960,Energy Efficiency,energy,energy,104960,":; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a g",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:105771,Energy Efficiency,energy,energy,105771,"Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:105916,Energy Efficiency,energy,energy,105916,"uster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:106256,Energy Efficiency,energy,energy,106256,"ne :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_o",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:106434,Energy Efficiency,energy,energy,106434," matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.;",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:106819,Energy Efficiency,energy,energy,106819,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)a",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:106959,Energy Efficiency,energy,energy,106959,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:113251,Energy Efficiency,adapt,adapted,113251,"ecent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:105363,Integrability,contract,contracts,105363,"ode.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:1543,Modifiability,inherit,inherited,1543,"sSetParser; CdSalcList; Checkpoint; CorrelationFactor; FittedSlaterCorrelationFactor; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); |",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:1723,Modifiability,inherit,inherited,1723,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_deta",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:3417,Modifiability,inherit,inherited,3417,"_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:3597,Modifiability,inherit,inherited,3597,"t :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:4353,Modifiability,inherit,inherited,4353," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:4533,Modifiability,inherit,inherited,4533,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:5431,Modifiability,inherit,inherited,5431,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:5611,Modifiability,inherit,inherited,5611,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:6920,Modifiability,inherit,inherited,6920,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:7100,Modifiability,inherit,inherited,7100,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and ot",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:7870,Modifiability,inherit,inherited,7870," here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:8050,Modifiability,inherit,inherited,8050,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:9198,Modifiability,inherit,inherited,9198,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:9378,Modifiability,inherit,inherited,9378,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:10131,Modifiability,inherit,inherited,10131," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:10360,Modifiability,inherit,inherited,10360,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:10495,Modifiability,inherit,inherited,10495,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:13174,Modifiability,inherit,inherited,13174,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:13562,Modifiability,inherit,inherited,13562," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:14855,Modifiability,inherit,inherited,14855,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | ci",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:15035,Modifiability,inherit,inherited,15035,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:17832,Modifiability,inherit,inherited,17832,"Dispersion)arg1) -> None :; | docstring; | ; | s6(...); | s6( (Dispersion)arg1) -> float :; | docstring; | ; | s8(...); | s8( (Dispersion)arg1) -> float :; | docstring; | ; | set_bibtex(...); | set_bibtex( (Dispersion)arg1, (str)arg2) -> None :; | Set the BibTeX key for the literature reference.; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:18012,Modifiability,inherit,inherited,18012,"set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:18805,Modifiability,inherit,inherited,18805,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:18985,Modifiability,inherit,inherited,18985,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:20341,Modifiability,inherit,inherited,20341,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:20521,Modifiability,inherit,inherited,20521,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Dat",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:21224,Modifiability,inherit,inherited,21224,"ta and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (Fitti",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:21470,Modifiability,inherit,inherited,21470," __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (Fit",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:21650,Modifiability,inherit,inherited,21650,"n method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:23410,Modifiability,inherit,inherited,23410,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:23590,Modifiability,inherit,inherited,23590,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:26386,Modifiability,inherit,inherited,26386," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:26566,Modifiability,inherit,inherited,26566,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:27320,Modifiability,inherit,inherited,27320," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:27500,Modifiability,inherit,inherited,27500,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:29601,Modifiability,inherit,inherited,29601," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:29781,Modifiability,inherit,inherited,29781,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:30511,Modifiability,inherit,inherited,30511,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:33191,Modifiability,inherit,inherited,33191,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:33371,Modifiability,inherit,inherited,33371,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | toccle",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:35224,Modifiability,inherit,inherited,35224,"(IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:35404,Modifiability,inherit,inherited,35404,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:37294,Modifiability,inherit,inherited,37294,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:37474,Modifiability,inherit,inherited,37474," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:38638,Modifiability,inherit,inherited,38638,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:38818,Modifiability,inherit,inherited,38818,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:44065,Modifiability,inherit,inherited,44065,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:44245,Modifiability,inherit,inherited,44245,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:45322,Modifiability,inherit,inherited,45322,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:45502,Modifiability,inherit,inherited,45502,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_f12(...); | ao_f12( (MintsHelper)arg1, (CorrelationFactor)arg2) -> Matrix :; | docstring; | ; | ao_f12_double_commutator(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:50114,Modifiability,inherit,inherited,50114,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:50294,Modifiability,inherit,inherited,50294,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:50964,Modifiability,inherit,inherited,50964,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:51144,Modifiability,inherit,inherited,51144,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:55137,Modifiability,variab,variable,55137,"g2 fragments Real; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplic",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:55636,Modifiability,variab,variable,55636,"(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion en",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:60815,Modifiability,variab,variable,60815,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:60853,Modifiability,variab,variables,60853,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:61242,Modifiability,variab,variable,61242,"et_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:62132,Modifiability,inherit,inherited,62132,"arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:62312,Modifiability,inherit,inherited,62312,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:63068,Modifiability,inherit,inherited,63068,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:63248,Modifiability,inherit,inherited,63248,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:63909,Modifiability,inherit,inherited,63909,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:64089,Modifiability,inherit,inherited,64089,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:65021,Modifiability,inherit,inherited,65021,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:65201,Modifiability,inherit,inherited,65201,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:67054,Modifiability,inherit,inherited,67054,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:67234,Modifiability,inherit,inherited,67234,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:68211,Modifiability,inherit,inherited,68211,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:68391,Modifiability,inherit,inherited,68391,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:69226,Modifiability,inherit,inherited,69226,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:69406,Modifiability,inherit,inherited,69406,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:70229,Modifiability,inherit,inherited,70229,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:70409,Modifiability,inherit,inherited,70409,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:71480,Modifiability,inherit,inherited,71480,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:71660,Modifiability,inherit,inherited,71660,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:72477,Modifiability,inherit,inherited,72477,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:72706,Modifiability,inherit,inherited,72706,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:72841,Modifiability,inherit,inherited,72841,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:75520,Modifiability,inherit,inherited,75520,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:75908,Modifiability,inherit,inherited,75908," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:76630,Modifiability,inherit,inherited,76630,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:79310,Modifiability,inherit,inherited,79310,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:79490,Modifiability,inherit,inherited,79490,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:80325,Modifiability,inherit,inherited,80325," | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:80505,Modifiability,inherit,inherited,80505,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:85338,Modifiability,inherit,inherited,85338,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:85518,Modifiability,inherit,inherited,85518,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:87586,Modifiability,inherit,inherited,87586,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:87766,Modifiability,inherit,inherited,87766,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:89469,Modifiability,inherit,inherited,89469," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ;",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:89649,Modifiability,inherit,inherited,89649,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:91849,Modifiability,inherit,inherited,91849,"__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | Returns a string representation of arg1, suitable for printing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:92029,Modifiability,inherit,inherited,92029,"ing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:92804,Modifiability,inherit,inherited,92804,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:92984,Modifiability,inherit,inherited,92984,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:96289,Modifiability,inherit,inherited,96289,"> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:96469,Modifiability,inherit,inherited,96469,"> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:97482,Modifiability,extend,extend,97482,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:97497,Modifiability,extend,extend,97497,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:97797,Modifiability,inherit,inherited,97797,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:97977,Modifiability,inherit,inherited,97977,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:105501,Modifiability,config,configuration,105501," ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...);",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:108528,Modifiability,variab,variables,108528,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:108617,Modifiability,variab,variables,108617,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:111017,Modifiability,plugin,plugin,111017,t :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the so,MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:111030,Modifiability,plugin,plugin,111030, code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() ,MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:111897,Modifiability,variab,variables,111897,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; Returns the current wavefunction object, from the most recent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a p",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:113251,Modifiability,adapt,adapted,113251,"ecent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:115441,Modifiability,variab,variable,115441,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct ",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:41217,Performance,load,load,41217,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
https://psicode.org/psi4manual/4.0b3/psimod.html:41230,Performance,load,load,41230,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b3/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod.html
